/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createGroupFromDiscriminatorValue, createIdentitySetFromDiscriminatorValue, createPhysicalAddressFromDiscriminatorValue, createPublicErrorFromDiscriminatorValue, createResultInfoFromDiscriminatorValue, createSiteFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, deserializeIntoIdentity, serializeBaseCollectionPaginationCountResponse, serializeEntity, serializeGroup, serializeIdentity, serializeIdentitySet, serializePhysicalAddress, serializePublicError, serializeResultInfo, serializeSite, type BaseCollectionPaginationCountResponse, type Entity, type Group, type Identity, type IdentitySet, type PhysicalAddress, type PublicError, type ResultInfo, type Site } from '../';
// @ts-ignore
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Duration, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';
// @ts-ignore
import { type Guid } from 'guid-typescript';

export type ActionAfterRetentionPeriod = (typeof ActionAfterRetentionPeriodObject)[keyof typeof ActionAfterRetentionPeriodObject];
export type ActionSource = (typeof ActionSourceObject)[keyof typeof ActionSourceObject];
export interface AddContentFooterAction extends InformationProtectionAction, Parsable {
    /**
     * The alignment property
     */
    alignment?: ContentAlignment;
    /**
     * Color of the font to use for the footer.
     */
    fontColor?: string;
    /**
     * Name of the font to use for the footer.
     */
    fontName?: string;
    /**
     * Font size to use for the footer.
     */
    fontSize?: number;
    /**
     * The margin of the header from the bottom of the document.
     */
    margin?: number;
    /**
     * The contents of the footer itself.
     */
    text?: string;
    /**
     * The name of the UI element where the footer should be placed.
     */
    uiElementName?: string;
}
export interface AddContentHeaderAction extends InformationProtectionAction, Parsable {
    /**
     * The alignment property
     */
    alignment?: ContentAlignment;
    /**
     * Color of the font to use for the header.
     */
    fontColor?: string;
    /**
     * Name of the font to use for the header.
     */
    fontName?: string;
    /**
     * Font size to use for the header.
     */
    fontSize?: number;
    /**
     * The margin of the header from the top of the document.
     */
    margin?: number;
    /**
     * The contents of the header itself.
     */
    text?: string;
    /**
     * The name of the UI element where the header should be placed.
     */
    uiElementName?: string;
}
export type AdditionalDataOptions = (typeof AdditionalDataOptionsObject)[keyof typeof AdditionalDataOptionsObject];
export type AdditionalOptions = (typeof AdditionalOptionsObject)[keyof typeof AdditionalOptionsObject];
export interface AddWatermarkAction extends InformationProtectionAction, Parsable {
    /**
     * Color of the font to use for the watermark.
     */
    fontColor?: string;
    /**
     * Name of the font to use for the watermark.
     */
    fontName?: string;
    /**
     * Font size to use for the watermark.
     */
    fontSize?: number;
    /**
     * The layout property
     */
    layout?: WatermarkLayout;
    /**
     * The contents of the watermark itself.
     */
    text?: string;
    /**
     * The name of the UI element where the watermark should be placed.
     */
    uiElementName?: string;
}
export interface Alert extends Entity, Parsable {
    /**
     * The adversary or activity group that is associated with this alert.
     */
    actorDisplayName?: string;
    /**
     * A collection of other alert properties, including user-defined properties. Any custom details defined in the alert, and any dynamic content in the alert details, are stored here.
     */
    additionalDataProperty?: Dictionary;
    /**
     * The ID of the policy that generated the alert, and populated when there is a specific policy that generated the alert, whether configured by a customer or a built-in policy.
     */
    alertPolicyId?: string;
    /**
     * URL for the Microsoft 365 Defender portal alert page.
     */
    alertWebUrl?: string;
    /**
     * Owner of the alert, or null if no owner is assigned.
     */
    assignedTo?: string;
    /**
     * The attack kill-chain category that the alert belongs to. Aligned with the MITRE ATT&CK framework.
     */
    category?: string;
    /**
     * Specifies whether the alert represents a true threat. Possible values are: unknown, falsePositive, truePositive, informationalExpectedActivity, unknownFutureValue.
     */
    classification?: AlertClassification;
    /**
     * Array of comments created by the Security Operations (SecOps) team during the alert management process.
     */
    comments?: AlertComment[];
    /**
     * Time when Microsoft 365 Defender created the alert.
     */
    createdDateTime?: Date;
    /**
     * String value describing each alert.
     */
    description?: string;
    /**
     * Detection technology or sensor that identified the notable component or activity. Possible values are: unknown, microsoftDefenderForEndpoint, antivirus, smartScreen, customTi, microsoftDefenderForOffice365, automatedInvestigation, microsoftThreatExperts, customDetection, microsoftDefenderForIdentity, cloudAppSecurity, microsoft365Defender, azureAdIdentityProtection, manual, microsoftDataLossPrevention, appGovernancePolicy, appGovernanceDetection, unknownFutureValue, microsoftDefenderForCloud, microsoftDefenderForIoT, microsoftDefenderForServers, microsoftDefenderForStorage, microsoftDefenderForDNS, microsoftDefenderForDatabases, microsoftDefenderForContainers, microsoftDefenderForNetwork, microsoftDefenderForAppService, microsoftDefenderForKeyVault, microsoftDefenderForResourceManager, microsoftDefenderForApiManagement, microsoftSentinel, nrtAlerts, scheduledAlerts, microsoftDefenderThreatIntelligenceAnalytics, builtInMl. You must use the Prefer: include-unknown-enum-members request header to get the following value(s) in this evolvable enum: microsoftDefenderForCloud, microsoftDefenderForIoT, microsoftDefenderForServers, microsoftDefenderForStorage, microsoftDefenderForDNS, microsoftDefenderForDatabases, microsoftDefenderForContainers, microsoftDefenderForNetwork, microsoftDefenderForAppService, microsoftDefenderForKeyVault, microsoftDefenderForResourceManager, microsoftDefenderForApiManagement, microsoftSentinel, nrtAlerts, scheduledAlerts, microsoftDefenderThreatIntelligenceAnalytics, builtInMl.
     */
    detectionSource?: DetectionSource;
    /**
     * The ID of the detector that triggered the alert.
     */
    detectorId?: string;
    /**
     * Specifies the result of the investigation, whether the alert represents a true attack, and if so, the nature of the attack. Possible values are: unknown, apt, malware, securityPersonnel, securityTesting, unwantedSoftware, other, multiStagedAttack, compromisedUser, phishing, maliciousUserActivity, clean, insufficientData, confirmedUserActivity, lineOfBusinessApplication, unknownFutureValue.
     */
    determination?: AlertDetermination;
    /**
     * Collection of evidence related to the alert.
     */
    evidence?: AlertEvidence[];
    /**
     * The earliest activity associated with the alert.
     */
    firstActivityDateTime?: Date;
    /**
     * Unique identifier to represent the incident this alert resource is associated with.
     */
    incidentId?: string;
    /**
     * URL for the incident page in the Microsoft 365 Defender portal.
     */
    incidentWebUrl?: string;
    /**
     * The oldest activity associated with the alert.
     */
    lastActivityDateTime?: Date;
    /**
     * Time when the alert was last updated at Microsoft 365 Defender.
     */
    lastUpdateDateTime?: Date;
    /**
     * The attack techniques, as aligned with the MITRE ATT&CK framework.
     */
    mitreTechniques?: string[];
    /**
     * The name of the product which published this alert.
     */
    productName?: string;
    /**
     * The ID of the alert as it appears in the security provider product that generated the alert.
     */
    providerAlertId?: string;
    /**
     * Recommended response and remediation actions to take in the event this alert was generated.
     */
    recommendedActions?: string;
    /**
     * Time when the alert was resolved.
     */
    resolvedDateTime?: Date;
    /**
     * The serviceSource property
     */
    serviceSource?: ServiceSource;
    /**
     * The severity property
     */
    severity?: AlertSeverity;
    /**
     * The status property
     */
    status?: AlertStatus;
    /**
     * The system tags associated with the alert.
     */
    systemTags?: string[];
    /**
     * The Microsoft Entra tenant the alert was created in.
     */
    tenantId?: string;
    /**
     * The threat associated with this alert.
     */
    threatDisplayName?: string;
    /**
     * Threat family associated with this alert.
     */
    threatFamilyName?: string;
    /**
     * Brief identifying string value describing the alert.
     */
    title?: string;
}
export type AlertClassification = (typeof AlertClassificationObject)[keyof typeof AlertClassificationObject];
export interface AlertCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Alert[];
}
export interface AlertComment extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The comment text.
     */
    comment?: string;
    /**
     * The person or app name that submitted the comment.
     */
    createdByDisplayName?: string;
    /**
     * The time when the comment was submitted.
     */
    createdDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type AlertDetermination = (typeof AlertDeterminationObject)[keyof typeof AlertDeterminationObject];
export interface AlertEvidence extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The date and time when the evidence was created and added to the alert. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    createdDateTime?: Date;
    /**
     * Detailed description of the entity role/s in an alert. Values are free-form.
     */
    detailedRoles?: string[];
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The remediationStatus property
     */
    remediationStatus?: EvidenceRemediationStatus;
    /**
     * Details about the remediation status.
     */
    remediationStatusDetails?: string;
    /**
     * The role/s that an evidence entity represents in an alert, for example, an IP address that is associated with an attacker has the evidence role Attacker.
     */
    roles?: EvidenceRole[];
    /**
     * Array of custom tags associated with an evidence instance, for example, to denote a group of devices, high-value assets, etc.
     */
    tags?: string[];
    /**
     * The verdict property
     */
    verdict?: EvidenceVerdict;
}
export type AlertSeverity = (typeof AlertSeverityObject)[keyof typeof AlertSeverityObject];
export type AlertStatus = (typeof AlertStatusObject)[keyof typeof AlertStatusObject];
export interface AlertTemplate extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Category assigned to the alert triggered by the custom detection rule.
     */
    category?: string;
    /**
     * Description of the alert triggered by the custom detection rule.
     */
    description?: string;
    /**
     * Which asset or assets were impacted based on the alert triggered by the custom detection rule.
     */
    impactedAssets?: ImpactedAsset[];
    /**
     * MITRE technique assigned to the alert triggered by the custom detection rule.
     */
    mitreTechniques?: string[];
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Recommended actions to mitigate the threat related to the alert triggered by the custom detection rule.
     */
    recommendedActions?: string;
    /**
     * The severity property
     */
    severity?: AlertSeverity;
    /**
     * Name of the alert triggered by the custom detection rule.
     */
    title?: string;
}
export interface AllowFileResponseAction extends Parsable, ResponseAction {
    /**
     * Device groups to which the actions set in the custom detection rule are applied. More information
     */
    deviceGroupNames?: string[];
    /**
     * The identifier property
     */
    identifier?: FileEntityIdentifier[];
}
export interface AmazonResourceEvidence extends AlertEvidence, Parsable {
    /**
     * The unique identifier for the Amazon account.
     */
    amazonAccountId?: string;
    /**
     * The Amazon resource identifier (ARN) for the cloud resource.
     */
    amazonResourceId?: string;
    /**
     * The name of the resource.
     */
    resourceName?: string;
    /**
     * The type of the resource.
     */
    resourceType?: string;
}
export interface AnalyzedEmail extends Entity, Parsable {
    /**
     * A collection of values that contain the IDs of any alerts associated with the email.
     */
    alertIds?: string[];
    /**
     * A collection of the attachments in the email.
     */
    attachments?: AnalyzedEmailAttachment[];
    /**
     * The number of attachments in the email.
     */
    attachmentsCount?: number;
    /**
     * The authentication details associated with the email.
     */
    authenticationDetails?: AnalyzedEmailAuthenticationDetail;
    /**
     * The bulk complaint level of the email. A higher level is more likely to be spam.
     */
    bulkComplaintLevel?: string;
    /**
     * Provides context of the email.
     */
    contexts?: string[];
    /**
     * The methods of detection used.
     */
    detectionMethods?: string[];
    /**
     * The direction of the emails. The possible values are: unknown, inbound, outbound, intraOrg, unknownFutureValue.
     */
    directionality?: AntispamDirectionality;
    /**
     * The distribution list details to which the email was sent.
     */
    distributionList?: string;
    /**
     * The identifier for the group of similar emails clustered based on heuristic analysis of their content.
     */
    emailClusterId?: string;
    /**
     * The name of the Exchange transport rules (ETRs) associated with the email.
     */
    exchangeTransportRules?: AnalyzedEmailExchangeTransportRuleInfo[];
    /**
     * A public-facing identifier for the email that is sent. The message ID is in the format specified by RFC2822.
     */
    internetMessageId?: string;
    /**
     * The detected language of the email content.
     */
    language?: string;
    /**
     * The latest delivery details of the email.
     */
    latestDelivery?: AnalyzedEmailDeliveryDetail;
    /**
     * Date-time when the email record was logged.
     */
    loggedDateTime?: Date;
    /**
     * An internal identifier for the email generated by Microsoft 365.
     */
    networkMessageId?: string;
    /**
     * The original delivery details of the email.
     */
    originalDelivery?: AnalyzedEmailDeliveryDetail;
    /**
     * An aggregated list of all overrides with source on email.
     */
    overrideSources?: string[];
    /**
     * The phish confidence level associated with the email
     */
    phishConfidenceLevel?: string;
    /**
     * The action policy that took effect.
     */
    policy?: string;
    /**
     * The action taken on the email based on the configured policy.
     */
    policyAction?: string;
    /**
     * Contains the email address of the recipient.
     */
    recipientEmailAddress?: string;
    /**
     * A field that indicates where and how bounced emails are processed.
     */
    returnPath?: string;
    /**
     * Sender details of the email.
     */
    senderDetail?: AnalyzedEmailSenderDetail;
    /**
     * Size of the email in bytes.
     */
    sizeInBytes?: number;
    /**
     * Spam confidence of the email.
     */
    spamConfidenceLevel?: string;
    /**
     * Subject of the email.
     */
    subject?: string;
    /**
     * Indicates the threat types. The possible values are: unknown, spam, malware, phish, none, unknownFutureValue.
     */
    threatTypes?: ThreatType[];
    /**
     * A collection of the URLs in the email.
     */
    urls?: AnalyzedEmailUrl[];
    /**
     * The number of URLs in the email.
     */
    urlsCount?: number;
}
export interface AnalyzedEmailAttachment extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The detonation details of the attachment.
     */
    detonationDetails?: DetonationDetails;
    /**
     * The name of the attachment in the email.
     */
    fileName?: string;
    /**
     * The type of the attachment in the email.
     */
    fileType?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The SHA256 file hash of the attachment.
     */
    sha256?: string;
    /**
     * The threat name associated with the threat type.
     */
    threatName?: string;
    /**
     * The threat type associated with the attachment. The possible values are: unknown, spam, malware, phishing, none, unknownFutureValue.
     */
    threatType?: ThreatType;
}
export interface AnalyzedEmailAuthenticationDetail extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * A value used by Microsoft 365 to combine email authentication such as SPF, DKIM, and DMARC, to determine whether the message is authentic.
     */
    compositeAuthentication?: string;
    /**
     * DomainKeys identified mail (DKIM). Indicates whether it was pass/fail/soft fail.
     */
    dkim?: string;
    /**
     * Domain-based Message Authentication. Indicates whether it was pass/fail/soft fail.
     */
    dmarc?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Sender Policy Framework (SPF). Indicates whether it was pass/fail/soft fail.
     */
    senderPolicyFramework?: string;
}
export interface AnalyzedEmailCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: AnalyzedEmail[];
}
export interface AnalyzedEmailDeliveryDetail extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The delivery action of the email. The possible values are: unknown, deliveredToJunk, delivered, blocked, replaced, unknownFutureValue.
     */
    action?: DeliveryAction;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The delivery location of the email. The possible values are: unknown, inboxfolder, junkFolder, deletedFolder, quarantine, onpremexternal, failed, dropped, others, unknownFutureValue.
     */
    location?: DeliveryLocation;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface AnalyzedEmailExchangeTransportRuleInfo extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Name of the Exchange transport rules (ETRs) that are part of the email.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The ETR rule ID.
     */
    ruleId?: string;
}
export interface AnalyzedEmailSenderDetail extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The sender email address in the mail From header, also known as the envelope sender or the P1 sender.
     */
    fromAddress?: string;
    /**
     * The IPv4 address of the last detected mail server that relayed the message.
     */
    ipv4?: string;
    /**
     * The sender email address in the From header, which is visible to email recipients on their email clients. Also known as P2 sender.
     */
    mailFromAddress?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface AnalyzedEmailUrl extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The method used to detect threats in the URL.
     */
    detectionMethod?: string;
    /**
     * Detonation data associated with the URL.
     */
    detonationDetails?: DetonationDetails;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The type of threat associated with the URL. The possible values are: unknown, spam, malware, phishing, none, unknownFutureValue.
     */
    threatType?: ThreatType;
    /**
     * The URL that is found in the email. This is full URL string, including query parameters.
     */
    url?: string;
}
export interface AnalyzedMessageEvidence extends AlertEvidence, Parsable {
    /**
     * Direction of the email relative to your network. The possible values are: inbound, outbound or intraorg.
     */
    antiSpamDirection?: string;
    /**
     * Number of attachments in the email.
     */
    attachmentsCount?: number;
    /**
     * Delivery action of the email. The possible values are: delivered, deliveredAsSpam, junked, blocked, or replaced.
     */
    deliveryAction?: string;
    /**
     * Location where the email was delivered. The possible values are: inbox, external, junkFolder, quarantine, failed, dropped, deletedFolder or forwarded.
     */
    deliveryLocation?: string;
    /**
     * Public-facing identifier for the email that is set by the sending email system.
     */
    internetMessageId?: string;
    /**
     * Detected language of the email content.
     */
    language?: string;
    /**
     * Unique identifier for the email, generated by Microsoft 365.
     */
    networkMessageId?: string;
    /**
     * The P1 sender.
     */
    p1Sender?: EmailSender;
    /**
     * The P2 sender.
     */
    p2Sender?: EmailSender;
    /**
     * Date and time when the email was received.
     */
    receivedDateTime?: Date;
    /**
     * Email address of the recipient, or email address of the recipient after distribution list expansion.
     */
    recipientEmailAddress?: string;
    /**
     * IP address of the last detected mail server that relayed the message.
     */
    senderIp?: string;
    /**
     * Subject of the email.
     */
    subject?: string;
    /**
     * Collection of methods used to detect malware, phishing, or other threats found in the email.
     */
    threatDetectionMethods?: string[];
    /**
     * Collection of detection names for malware or other threats found.
     */
    threats?: string[];
    /**
     * Number of embedded URLs in the email.
     */
    urlCount?: number;
    /**
     * Collection of the URLs contained in this email.
     */
    urls?: string[];
    /**
     * Uniform resource name (URN) of the automated investigation where the cluster was identified.
     */
    urn?: string;
}
export type AntispamDirectionality = (typeof AntispamDirectionalityObject)[keyof typeof AntispamDirectionalityObject];
export interface ApplyLabelAction extends InformationProtectionAction, Parsable {
    /**
     * The collection of actions that should be implemented by the caller.
     */
    actions?: InformationProtectionAction[];
    /**
     * The actionSource property
     */
    actionSource?: ActionSource;
    /**
     * If the label was the result of an automatic classification, supply the list of sensitive info type GUIDs that resulted in the returned label.
     */
    responsibleSensitiveTypeIds?: string[];
    /**
     * The sensitivityLabelId property
     */
    sensitivityLabelId?: string;
}
export interface Article extends Entity, Parsable {
    /**
     * The body property
     */
    body?: FormattedContent;
    /**
     * The date and time when this article was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    createdDateTime?: Date;
    /**
     * URL of the header image for this article, used for display purposes.
     */
    imageUrl?: string;
    /**
     * Indicators related to this article.
     */
    indicators?: ArticleIndicator[];
    /**
     * Indicates whether this article is currently featured by Microsoft.
     */
    isFeatured?: boolean;
    /**
     * The most recent date and time when this article was updated. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastUpdatedDateTime?: Date;
    /**
     * The summary property
     */
    summary?: FormattedContent;
    /**
     * Tags for this article, communicating keywords, or key concepts.
     */
    tags?: string[];
    /**
     * The title of this article.
     */
    title?: string;
}
export interface ArticleCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Article[];
}
export interface ArticleIndicator extends Indicator, Parsable {
}
export interface ArticleIndicatorCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ArticleIndicator[];
}
export interface Artifact extends Entity, Parsable {
}
export type AssignmentMethod = (typeof AssignmentMethodObject)[keyof typeof AssignmentMethodObject];
export interface AttackSimulationInfo extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The date and time of the attack simulation.
     */
    attackSimDateTime?: Date;
    /**
     * The duration (in time) for the attack simulation.
     */
    attackSimDurationTime?: Duration;
    /**
     * The activity ID for the attack simulation.
     */
    attackSimId?: Guid;
    /**
     * The unique identifier for the user who got the attack simulation email.
     */
    attackSimUserId?: string;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface AuditCoreRoot extends Entity, Parsable {
    /**
     * The queries property
     */
    queries?: AuditLogQuery[];
}
export interface AuditData extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface AuditLogQuery extends Entity, Parsable {
    /**
     * The administrative units tagged to an audit log record.
     */
    administrativeUnitIdFilters?: string[];
    /**
     * The display name of the saved audit log query.
     */
    displayName?: string;
    /**
     * The end date of the date range in the query.
     */
    filterEndDateTime?: Date;
    /**
     * The start date of the date range in the query.
     */
    filterStartDateTime?: Date;
    /**
     * The IP address of the device that was used when the activity was logged.
     */
    ipAddressFilters?: string[];
    /**
     * Free text field to search non-indexed properties of the audit log.
     */
    keywordFilter?: string;
    /**
     * For SharePoint and OneDrive for Business activity, the full path name of the file or folder accessed by the user. For Exchange admin audit logging, the name of the object that was modified by the cmdlet.
     */
    objectIdFilters?: string[];
    /**
     * The name of the user or admin activity. For a description of the most common operations/activities, see Search the audit log in the Office 365 Protection Center.
     */
    operationFilters?: string[];
    /**
     * An individual audit log record.
     */
    records?: AuditLogRecord[];
    /**
     * The type of operation indicated by the record. The possible values are: exchangeAdmin, exchangeItem, exchangeItemGroup, sharePoint, syntheticProbe, sharePointFileOperation, oneDrive, azureActiveDirectory, azureActiveDirectoryAccountLogon, dataCenterSecurityCmdlet, complianceDLPSharePoint, sway, complianceDLPExchange, sharePointSharingOperation, azureActiveDirectoryStsLogon, skypeForBusinessPSTNUsage, skypeForBusinessUsersBlocked, securityComplianceCenterEOPCmdlet, exchangeAggregatedOperation, powerBIAudit, crm, yammer, skypeForBusinessCmdlets, discovery, microsoftTeams, threatIntelligence, mailSubmission, microsoftFlow, aeD, microsoftStream, complianceDLPSharePointClassification, threatFinder, project, sharePointListOperation, sharePointCommentOperation, dataGovernance, kaizala, securityComplianceAlerts, threatIntelligenceUrl, securityComplianceInsights, mipLabel, workplaceAnalytics, powerAppsApp, powerAppsPlan, threatIntelligenceAtpContent, labelContentExplorer, teamsHealthcare, exchangeItemAggregated, hygieneEvent, dataInsightsRestApiAudit, informationBarrierPolicyApplication, sharePointListItemOperation, sharePointContentTypeOperation, sharePointFieldOperation, microsoftTeamsAdmin, hrSignal, microsoftTeamsDevice, microsoftTeamsAnalytics, informationWorkerProtection, campaign, dlpEndpoint, airInvestigation, quarantine, microsoftForms, applicationAudit, complianceSupervisionExchange, customerKeyServiceEncryption, officeNative, mipAutoLabelSharePointItem, mipAutoLabelSharePointPolicyLocation, microsoftTeamsShifts, secureScore, mipAutoLabelExchangeItem, cortanaBriefing, search, wdatpAlerts, powerPlatformAdminDlp, powerPlatformAdminEnvironment, mdatpAudit, sensitivityLabelPolicyMatch, sensitivityLabelAction, sensitivityLabeledFileAction, attackSim, airManualInvestigation, securityComplianceRBAC, userTraining, airAdminActionInvestigation, mstic, physicalBadgingSignal, teamsEasyApprovals, aipDiscover, aipSensitivityLabelAction, aipProtectionAction, aipFileDeleted, aipHeartBeat, mcasAlerts, onPremisesFileShareScannerDlp, onPremisesSharePointScannerDlp, exchangeSearch, sharePointSearch, privacyDataMinimization, labelAnalyticsAggregate, myAnalyticsSettings, securityComplianceUserChange, complianceDLPExchangeClassification, complianceDLPEndpoint, mipExactDataMatch, msdeResponseActions, msdeGeneralSettings, msdeIndicatorsSettings, ms365DCustomDetection, msdeRolesSettings, mapgAlerts, mapgPolicy, mapgRemediation, privacyRemediationAction, privacyDigestEmail, mipAutoLabelSimulationProgress, mipAutoLabelSimulationCompletion, mipAutoLabelProgressFeedback, dlpSensitiveInformationType, mipAutoLabelSimulationStatistics, largeContentMetadata, microsoft365Group, cdpMlInferencingResult, filteringMailMetadata, cdpClassificationMailItem, cdpClassificationDocument, officeScriptsRunAction, filteringPostMailDeliveryAction, cdpUnifiedFeedback, tenantAllowBlockList, consumptionResource, healthcareSignal, dlpImportResult, cdpCompliancePolicyExecution, multiStageDisposition, privacyDataMatch, filteringDocMetadata, filteringEmailFeatures, powerBIDlp, filteringUrlInfo, filteringAttachmentInfo, coreReportingSettings, complianceConnector, powerPlatformLockboxResourceAccessRequest, powerPlatformLockboxResourceCommand, cdpPredictiveCodingLabel, cdpCompliancePolicyUserFeedback, webpageActivityEndpoint, omePortal, cmImprovementActionChange, filteringUrlClick, mipLabelAnalyticsAuditRecord, filteringEntityEvent, filteringRuleHits, filteringMailSubmission, labelExplorer, microsoftManagedServicePlatform, powerPlatformServiceActivity, scorePlatformGenericAuditRecord, filteringTimeTravelDocMetadata, alert, alertStatus, alertIncident, incidentStatus, case, caseInvestigation, recordsManagement, privacyRemediation, dataShareOperation, cdpDlpSensitive, ehrConnector, filteringMailGradingResult, publicFolder, privacyTenantAuditHistoryRecord, aipScannerDiscoverEvent, eduDataLakeDownloadOperation, m365ComplianceConnector, microsoftGraphDataConnectOperation, microsoftPurview, filteringEmailContentFeatures, powerPagesSite, powerAppsResource, plannerPlan, plannerCopyPlan, plannerTask, plannerRoster, plannerPlanList, plannerTaskList, plannerTenantSettings, projectForTheWebProject, projectForTheWebTask, projectForTheWebRoadmap, projectForTheWebRoadmapItem, projectForTheWebProjectSettings, projectForTheWebRoadmapSettings, quarantineMetadata, microsoftTodoAudit, timeTravelFilteringDocMetadata, teamsQuarantineMetadata, sharePointAppPermissionOperation, microsoftTeamsSensitivityLabelAction, filteringTeamsMetadata, filteringTeamsUrlInfo, filteringTeamsPostDeliveryAction, mdcAssessments, mdcRegulatoryComplianceStandards, mdcRegulatoryComplianceControls, mdcRegulatoryComplianceAssessments, mdcSecurityConnectors, mdaDataSecuritySignal, vivaGoals, filteringRuntimeInfo, attackSimAdmin, microsoftGraphDataConnectConsent, filteringAtpDetonationInfo, privacyPortal, managedTenants, unifiedSimulationMatchedItem, unifiedSimulationSummary, updateQuarantineMetadata, ms365DSuppressionRule, purviewDataMapOperation, filteringUrlPostClickAction, irmUserDefinedDetectionSignal, teamsUpdates, plannerRosterSensitivityLabel, ms365DIncident, filteringDelistingMetadata, complianceDLPSharePointClassificationExtended, microsoftDefenderForIdentityAudit, supervisoryReviewDayXInsight, defenderExpertsforXDRAdmin, cdpEdgeBlockedMessage, hostedRpa, cdpContentExplorerAggregateRecord, cdpHygieneAttachmentInfo, cdpHygieneSummary, cdpPostMailDeliveryAction, cdpEmailFeatures, cdpHygieneUrlInfo, cdpUrlClick, cdpPackageManagerHygieneEvent, filteringDocScan, timeTravelFilteringDocScan, mapgOnboard, unknownFutureValue.
     */
    recordTypeFilters?: AuditLogRecordType[];
    /**
     * The serviceFilters property
     */
    serviceFilters?: string[];
    /**
     * Describes the current status of the query. The possible values are: notStarted, running, succeeded, failed, cancelled, unknownFutureValue.
     */
    status?: AuditLogQueryStatus;
    /**
     * The UPN (user principal name) of the user who performed the action (specified in the operation property) that resulted in the record being logged; for example, myname@mydomain_name.
     */
    userPrincipalNameFilters?: string[];
}
export interface AuditLogQueryCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: AuditLogQuery[];
}
export type AuditLogQueryStatus = (typeof AuditLogQueryStatusObject)[keyof typeof AuditLogQueryStatusObject];
export interface AuditLogRecord extends Entity, Parsable {
    /**
     * The administrative units tagged to an audit log record.
     */
    administrativeUnits?: string[];
    /**
     * A JSON object that contains the actual audit log data.
     */
    auditData?: AuditData;
    /**
     * The type of operation indicated by the record. The possible values are: exchangeAdmin, exchangeItem, exchangeItemGroup, sharePoint, syntheticProbe, sharePointFileOperation, oneDrive, azureActiveDirectory, azureActiveDirectoryAccountLogon, dataCenterSecurityCmdlet, complianceDLPSharePoint, sway, complianceDLPExchange, sharePointSharingOperation, azureActiveDirectoryStsLogon, skypeForBusinessPSTNUsage, skypeForBusinessUsersBlocked, securityComplianceCenterEOPCmdlet, exchangeAggregatedOperation, powerBIAudit, crm, yammer, skypeForBusinessCmdlets, discovery, microsoftTeams, threatIntelligence, mailSubmission, microsoftFlow, aeD, microsoftStream, complianceDLPSharePointClassification, threatFinder, project, sharePointListOperation, sharePointCommentOperation, dataGovernance, kaizala, securityComplianceAlerts, threatIntelligenceUrl, securityComplianceInsights, mipLabel, workplaceAnalytics, powerAppsApp, powerAppsPlan, threatIntelligenceAtpContent, labelContentExplorer, teamsHealthcare, exchangeItemAggregated, hygieneEvent, dataInsightsRestApiAudit, informationBarrierPolicyApplication, sharePointListItemOperation, sharePointContentTypeOperation, sharePointFieldOperation, microsoftTeamsAdmin, hrSignal, microsoftTeamsDevice, microsoftTeamsAnalytics, informationWorkerProtection, campaign, dlpEndpoint, airInvestigation, quarantine, microsoftForms, applicationAudit, complianceSupervisionExchange, customerKeyServiceEncryption, officeNative, mipAutoLabelSharePointItem, mipAutoLabelSharePointPolicyLocation, microsoftTeamsShifts, secureScore, mipAutoLabelExchangeItem, cortanaBriefing, search, wdatpAlerts, powerPlatformAdminDlp, powerPlatformAdminEnvironment, mdatpAudit, sensitivityLabelPolicyMatch, sensitivityLabelAction, sensitivityLabeledFileAction, attackSim, airManualInvestigation, securityComplianceRBAC, userTraining, airAdminActionInvestigation, mstic, physicalBadgingSignal, teamsEasyApprovals, aipDiscover, aipSensitivityLabelAction, aipProtectionAction, aipFileDeleted, aipHeartBeat, mcasAlerts, onPremisesFileShareScannerDlp, onPremisesSharePointScannerDlp, exchangeSearch, sharePointSearch, privacyDataMinimization, labelAnalyticsAggregate, myAnalyticsSettings, securityComplianceUserChange, complianceDLPExchangeClassification, complianceDLPEndpoint, mipExactDataMatch, msdeResponseActions, msdeGeneralSettings, msdeIndicatorsSettings, ms365DCustomDetection, msdeRolesSettings, mapgAlerts, mapgPolicy, mapgRemediation, privacyRemediationAction, privacyDigestEmail, mipAutoLabelSimulationProgress, mipAutoLabelSimulationCompletion, mipAutoLabelProgressFeedback, dlpSensitiveInformationType, mipAutoLabelSimulationStatistics, largeContentMetadata, microsoft365Group, cdpMlInferencingResult, filteringMailMetadata, cdpClassificationMailItem, cdpClassificationDocument, officeScriptsRunAction, filteringPostMailDeliveryAction, cdpUnifiedFeedback, tenantAllowBlockList, consumptionResource, healthcareSignal, dlpImportResult, cdpCompliancePolicyExecution, multiStageDisposition, privacyDataMatch, filteringDocMetadata, filteringEmailFeatures, powerBIDlp, filteringUrlInfo, filteringAttachmentInfo, coreReportingSettings, complianceConnector, powerPlatformLockboxResourceAccessRequest, powerPlatformLockboxResourceCommand, cdpPredictiveCodingLabel, cdpCompliancePolicyUserFeedback, webpageActivityEndpoint, omePortal, cmImprovementActionChange, filteringUrlClick, mipLabelAnalyticsAuditRecord, filteringEntityEvent, filteringRuleHits, filteringMailSubmission, labelExplorer, microsoftManagedServicePlatform, powerPlatformServiceActivity, scorePlatformGenericAuditRecord, filteringTimeTravelDocMetadata, alert, alertStatus, alertIncident, incidentStatus, case, caseInvestigation, recordsManagement, privacyRemediation, dataShareOperation, cdpDlpSensitive, ehrConnector, filteringMailGradingResult, publicFolder, privacyTenantAuditHistoryRecord, aipScannerDiscoverEvent, eduDataLakeDownloadOperation, m365ComplianceConnector, microsoftGraphDataConnectOperation, microsoftPurview, filteringEmailContentFeatures, powerPagesSite, powerAppsResource, plannerPlan, plannerCopyPlan, plannerTask, plannerRoster, plannerPlanList, plannerTaskList, plannerTenantSettings, projectForTheWebProject, projectForTheWebTask, projectForTheWebRoadmap, projectForTheWebRoadmapItem, projectForTheWebProjectSettings, projectForTheWebRoadmapSettings, quarantineMetadata, microsoftTodoAudit, timeTravelFilteringDocMetadata, teamsQuarantineMetadata, sharePointAppPermissionOperation, microsoftTeamsSensitivityLabelAction, filteringTeamsMetadata, filteringTeamsUrlInfo, filteringTeamsPostDeliveryAction, mdcAssessments, mdcRegulatoryComplianceStandards, mdcRegulatoryComplianceControls, mdcRegulatoryComplianceAssessments, mdcSecurityConnectors, mdaDataSecuritySignal, vivaGoals, filteringRuntimeInfo, attackSimAdmin, microsoftGraphDataConnectConsent, filteringAtpDetonationInfo, privacyPortal, managedTenants, unifiedSimulationMatchedItem, unifiedSimulationSummary, updateQuarantineMetadata, ms365DSuppressionRule, purviewDataMapOperation, filteringUrlPostClickAction, irmUserDefinedDetectionSignal, teamsUpdates, plannerRosterSensitivityLabel, ms365DIncident, filteringDelistingMetadata, complianceDLPSharePointClassificationExtended, microsoftDefenderForIdentityAudit, supervisoryReviewDayXInsight, defenderExpertsforXDRAdmin, cdpEdgeBlockedMessage, hostedRpa, cdpContentExplorerAggregateRecord, cdpHygieneAttachmentInfo, cdpHygieneSummary, cdpPostMailDeliveryAction, cdpEmailFeatures, cdpHygieneUrlInfo, cdpUrlClick, cdpPackageManagerHygieneEvent, filteringDocScan, timeTravelFilteringDocScan, mapgOnboard, unknownFutureValue.
     */
    auditLogRecordType?: AuditLogRecordType;
    /**
     * The IP address of the device used when the activity was logged. The IP address is displayed in either an IPv4 or IPv6 address format.
     */
    clientIp?: string;
    /**
     * The date and time in UTC when the user performed the activity.
     */
    createdDateTime?: Date;
    /**
     * For Exchange admin audit logging, the name of the object modified by the cmdlet. For SharePoint activity, the full URL path name of the file or folder accessed by a user. For Microsoft Entra activity, the name of the user account that was modified.
     */
    objectId?: string;
    /**
     * The name of the user or admin activity.
     */
    operation?: string;
    /**
     * The GUID for your organization.
     */
    organizationId?: string;
    /**
     * The Microsoft 365 service where the activity occurred.
     */
    service?: string;
    /**
     * The user who performed the action (specified in the Operation property) that resulted in the record being logged. Audit records for activity performed by system accounts (such as SHAREPOINT/system or NT AUTHORITY/SYSTEM) are also included in the audit log. Another common value for the UserId property is app@sharepoint. It indicates that the 'user' who performed the activity was an application with the necessary permissions in SharePoint to perform organization-wide actions (such as searching a SharePoint site or OneDrive account) on behalf of a user, admin, or service.
     */
    userId?: string;
    /**
     * UPN of the user who performed the action.
     */
    userPrincipalName?: string;
    /**
     * The type of user that performed the operation. The possible values are: regular, reserved, admin, dcAdmin, system, application, servicePrincipal, customPolicy, systemPolicy, partnerTechnician, guest, unknownFutureValue.
     */
    userType?: AuditLogUserType;
}
export interface AuditLogRecordCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: AuditLogRecord[];
}
export type AuditLogRecordType = (typeof AuditLogRecordTypeObject)[keyof typeof AuditLogRecordTypeObject];
export type AuditLogUserType = (typeof AuditLogUserTypeObject)[keyof typeof AuditLogUserTypeObject];
export interface AuthorityTemplate extends FilePlanDescriptorTemplate, Parsable {
}
export interface AuthorityTemplateCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: AuthorityTemplate[];
}
export interface AutonomousSystem extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of the autonomous system.
     */
    name?: string;
    /**
     * The autonomous system number, assigned by IANA.
     */
    number?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The name of the autonomous system organization.
     */
    organization?: string;
    /**
     * A displayable value for these autonomous system details.
     */
    value?: string;
}
export interface AzureResourceEvidence extends AlertEvidence, Parsable {
    /**
     * The unique identifier for the Azure resource.
     */
    resourceId?: string;
    /**
     * The name of the resource.
     */
    resourceName?: string;
    /**
     * The type of the resource.
     */
    resourceType?: string;
}
export type BehaviorDuringRetentionPeriod = (typeof BehaviorDuringRetentionPeriodObject)[keyof typeof BehaviorDuringRetentionPeriodObject];
export interface BlobContainerEvidence extends AlertEvidence, Parsable {
    /**
     * The name of the blob container.
     */
    name?: string;
    /**
     * The storage which the blob container belongs to.
     */
    storageResource?: AzureResourceEvidence;
    /**
     * The full URL representation of the blob container.
     */
    url?: string;
}
export interface BlobEvidence extends AlertEvidence, Parsable {
    /**
     * The container which the blob belongs to.
     */
    blobContainer?: BlobContainerEvidence;
    /**
     * The Etag associated with this blob.
     */
    etag?: string;
    /**
     * The file hashes associated with this blob.
     */
    fileHashes?: FileHash[];
    /**
     * The name of the blob.
     */
    name?: string;
    /**
     * The full URL representation of the blob.
     */
    url?: string;
}
export interface BlockFileResponseAction extends Parsable, ResponseAction {
    /**
     * Device groups to which the actions set in the custom detection rule are applied. More information
     */
    deviceGroupNames?: string[];
    /**
     * The identifier property
     */
    identifier?: FileEntityIdentifier[];
}
export type CaseAction = (typeof CaseActionObject)[keyof typeof CaseActionObject];
export interface CaseEscaped extends Entity, Parsable {
    /**
     * The createdDateTime property
     */
    createdDateTime?: Date;
    /**
     * The description property
     */
    description?: string;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The lastModifiedBy property
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The lastModifiedDateTime property
     */
    lastModifiedDateTime?: Date;
    /**
     * The status property
     */
    status?: CaseStatus;
}
export interface CaseOperation extends Entity, Parsable {
    /**
     * The type of action the operation represents. Possible values are: contentExport, applyTags, convertToPdf, index, estimateStatistics, addToReviewSet, holdUpdate, unknownFutureValue, purgeData, exportReport, exportResult. You must use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: purgeData, exportReport, exportResult.
     */
    action?: CaseAction;
    /**
     * The date and time the operation was completed.
     */
    completedDateTime?: Date;
    /**
     * The user that created the operation.
     */
    createdBy?: IdentitySet;
    /**
     * The date and time the operation was created.
     */
    createdDateTime?: Date;
    /**
     * The progress of the operation.
     */
    percentProgress?: number;
    /**
     * Contains success and failure-specific result information.
     */
    resultInfo?: ResultInfo;
    /**
     * The status of the case operation. Possible values are: notStarted, submissionFailed, running, succeeded, partiallySucceeded, failed.
     */
    status?: CaseOperationStatus;
}
export interface CaseOperationCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CaseOperation[];
}
export type CaseOperationStatus = (typeof CaseOperationStatusObject)[keyof typeof CaseOperationStatusObject];
export interface CasesRoot extends Entity, Parsable {
    /**
     * The ediscoveryCases property
     */
    ediscoveryCases?: EdiscoveryCase[];
}
export type CaseStatus = (typeof CaseStatusObject)[keyof typeof CaseStatusObject];
export interface CategoryTemplate extends FilePlanDescriptorTemplate, Parsable {
    /**
     * Represents all subcategories under a particular category.
     */
    subcategories?: SubcategoryTemplate[];
}
export interface CategoryTemplateCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CategoryTemplate[];
}
export type ChildSelectability = (typeof ChildSelectabilityObject)[keyof typeof ChildSelectabilityObject];
export interface CitationTemplate extends FilePlanDescriptorTemplate, Parsable {
    /**
     * Represents the jurisdiction or agency that published the citation.
     */
    citationJurisdiction?: string;
    /**
     * Represents the URL to the published citation.
     */
    citationUrl?: string;
}
export interface CitationTemplateCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CitationTemplate[];
}
export interface ClassificationResult extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The confidence level, 0 to 100, of the result.
     */
    confidenceLevel?: number;
    /**
     * The number of instances of the specific information type in the input.
     */
    count?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The GUID of the discovered sensitive information type.
     */
    sensitiveTypeId?: string;
}
export interface CloudApplicationEvidence extends AlertEvidence, Parsable {
    /**
     * Unique identifier of the application.
     */
    appId?: number;
    /**
     * Name of the application.
     */
    displayName?: string;
    /**
     * Identifier of the instance of the Software as a Service (SaaS) application.
     */
    instanceId?: number;
    /**
     * Name of the instance of the SaaS application.
     */
    instanceName?: string;
    /**
     * The identifier of the SaaS application.
     */
    saasAppId?: number;
    /**
     * The stream property
     */
    stream?: Stream;
}
export interface CollaborationRoot extends Entity, Parsable {
    /**
     * Contains metadata for analyzed emails.
     */
    analyzedEmails?: AnalyzedEmail[];
}
export interface CollectInvestigationPackageResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: DeviceIdEntityIdentifier[];
}
export interface ContainerEvidence extends AlertEvidence, Parsable {
    /**
     * The list of arguments.
     */
    args?: string[];
    /**
     * The list of commands.
     */
    command?: string[];
    /**
     * The container ID.
     */
    containerId?: string;
    /**
     * The image used to run the container.
     */
    image?: ContainerImageEvidence;
    /**
     * The privileged status.
     */
    isPrivileged?: boolean;
    /**
     * The container name.
     */
    name?: string;
    /**
     * The pod that this container belongs to.
     */
    pod?: KubernetesPodEvidence;
}
export interface ContainerImageEvidence extends AlertEvidence, Parsable {
    /**
     * The digest image entity, in case this is a tag image.
     */
    digestImage?: ContainerImageEvidence;
    /**
     * The unique identifier for the container image entity.
     */
    imageId?: string;
    /**
     * The container registry for this image.
     */
    registry?: ContainerRegistryEvidence;
}
export type ContainerPortProtocol = (typeof ContainerPortProtocolObject)[keyof typeof ContainerPortProtocolObject];
export interface ContainerRegistryEvidence extends AlertEvidence, Parsable {
    /**
     * The registry URI.
     */
    registry?: string;
}
export type ContentAlignment = (typeof ContentAlignmentObject)[keyof typeof ContentAlignmentObject];
export type ContentFormat = (typeof ContentFormatObject)[keyof typeof ContentFormatObject];
export interface ContentInfo extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The format of the content to be labeled. Possible values are: file, email.
     */
    contentFormat?: string;
    /**
     * Identifier used for Azure Information Protection Analytics.
     */
    identifier?: string;
    /**
     * Existing Microsoft Purview Information Protection metadata is passed as key-value pairs, where the key is the MSIPLabelGUID_PropName.
     */
    metadata?: KeyValuePair[];
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The state property
     */
    state?: ContentState;
}
export interface ContentLabel extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The assignmentMethod property
     */
    assignmentMethod?: AssignmentMethod;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The createdDateTime property
     */
    createdDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The sensitivityLabelId property
     */
    sensitivityLabelId?: string;
}
export type ContentState = (typeof ContentStateObject)[keyof typeof ContentStateObject];
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AddContentFooterAction}
 */
export function createAddContentFooterActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAddContentFooterAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AddContentHeaderAction}
 */
export function createAddContentHeaderActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAddContentHeaderAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AddWatermarkAction}
 */
export function createAddWatermarkActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAddWatermarkAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertCollectionResponse}
 */
export function createAlertCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertComment}
 */
export function createAlertCommentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertComment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertEvidence}
 */
export function createAlertEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.amazonResourceEvidence":
                    return deserializeIntoAmazonResourceEvidence;
                case "#microsoft.graph.security.analyzedMessageEvidence":
                    return deserializeIntoAnalyzedMessageEvidence;
                case "#microsoft.graph.security.azureResourceEvidence":
                    return deserializeIntoAzureResourceEvidence;
                case "#microsoft.graph.security.blobContainerEvidence":
                    return deserializeIntoBlobContainerEvidence;
                case "#microsoft.graph.security.blobEvidence":
                    return deserializeIntoBlobEvidence;
                case "#microsoft.graph.security.cloudApplicationEvidence":
                    return deserializeIntoCloudApplicationEvidence;
                case "#microsoft.graph.security.containerEvidence":
                    return deserializeIntoContainerEvidence;
                case "#microsoft.graph.security.containerImageEvidence":
                    return deserializeIntoContainerImageEvidence;
                case "#microsoft.graph.security.containerRegistryEvidence":
                    return deserializeIntoContainerRegistryEvidence;
                case "#microsoft.graph.security.deviceEvidence":
                    return deserializeIntoDeviceEvidence;
                case "#microsoft.graph.security.dnsEvidence":
                    return deserializeIntoDnsEvidence;
                case "#microsoft.graph.security.fileEvidence":
                    return deserializeIntoFileEvidence;
                case "#microsoft.graph.security.fileHashEvidence":
                    return deserializeIntoFileHashEvidence;
                case "#microsoft.graph.security.gitHubOrganizationEvidence":
                    return deserializeIntoGitHubOrganizationEvidence;
                case "#microsoft.graph.security.gitHubRepoEvidence":
                    return deserializeIntoGitHubRepoEvidence;
                case "#microsoft.graph.security.gitHubUserEvidence":
                    return deserializeIntoGitHubUserEvidence;
                case "#microsoft.graph.security.googleCloudResourceEvidence":
                    return deserializeIntoGoogleCloudResourceEvidence;
                case "#microsoft.graph.security.hostLogonSessionEvidence":
                    return deserializeIntoHostLogonSessionEvidence;
                case "#microsoft.graph.security.ioTDeviceEvidence":
                    return deserializeIntoIoTDeviceEvidence;
                case "#microsoft.graph.security.ipEvidence":
                    return deserializeIntoIpEvidence;
                case "#microsoft.graph.security.kubernetesClusterEvidence":
                    return deserializeIntoKubernetesClusterEvidence;
                case "#microsoft.graph.security.kubernetesControllerEvidence":
                    return deserializeIntoKubernetesControllerEvidence;
                case "#microsoft.graph.security.kubernetesNamespaceEvidence":
                    return deserializeIntoKubernetesNamespaceEvidence;
                case "#microsoft.graph.security.kubernetesPodEvidence":
                    return deserializeIntoKubernetesPodEvidence;
                case "#microsoft.graph.security.kubernetesSecretEvidence":
                    return deserializeIntoKubernetesSecretEvidence;
                case "#microsoft.graph.security.kubernetesServiceAccountEvidence":
                    return deserializeIntoKubernetesServiceAccountEvidence;
                case "#microsoft.graph.security.kubernetesServiceEvidence":
                    return deserializeIntoKubernetesServiceEvidence;
                case "#microsoft.graph.security.mailboxConfigurationEvidence":
                    return deserializeIntoMailboxConfigurationEvidence;
                case "#microsoft.graph.security.mailboxEvidence":
                    return deserializeIntoMailboxEvidence;
                case "#microsoft.graph.security.mailClusterEvidence":
                    return deserializeIntoMailClusterEvidence;
                case "#microsoft.graph.security.malwareEvidence":
                    return deserializeIntoMalwareEvidence;
                case "#microsoft.graph.security.networkConnectionEvidence":
                    return deserializeIntoNetworkConnectionEvidence;
                case "#microsoft.graph.security.nicEvidence":
                    return deserializeIntoNicEvidence;
                case "#microsoft.graph.security.oauthApplicationEvidence":
                    return deserializeIntoOauthApplicationEvidence;
                case "#microsoft.graph.security.processEvidence":
                    return deserializeIntoProcessEvidence;
                case "#microsoft.graph.security.registryKeyEvidence":
                    return deserializeIntoRegistryKeyEvidence;
                case "#microsoft.graph.security.registryValueEvidence":
                    return deserializeIntoRegistryValueEvidence;
                case "#microsoft.graph.security.sasTokenEvidence":
                    return deserializeIntoSasTokenEvidence;
                case "#microsoft.graph.security.securityGroupEvidence":
                    return deserializeIntoSecurityGroupEvidence;
                case "#microsoft.graph.security.servicePrincipalEvidence":
                    return deserializeIntoServicePrincipalEvidence;
                case "#microsoft.graph.security.submissionMailEvidence":
                    return deserializeIntoSubmissionMailEvidence;
                case "#microsoft.graph.security.urlEvidence":
                    return deserializeIntoUrlEvidence;
                case "#microsoft.graph.security.userEvidence":
                    return deserializeIntoUserEvidence;
            }
        }
    }
    return deserializeIntoAlertEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Alert}
 */
export function createAlertFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlert;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertTemplate}
 */
export function createAlertTemplateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertTemplate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AllowFileResponseAction}
 */
export function createAllowFileResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAllowFileResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AmazonResourceEvidence}
 */
export function createAmazonResourceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAmazonResourceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnalyzedEmailAttachment}
 */
export function createAnalyzedEmailAttachmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnalyzedEmailAttachment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnalyzedEmailAuthenticationDetail}
 */
export function createAnalyzedEmailAuthenticationDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnalyzedEmailAuthenticationDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnalyzedEmailCollectionResponse}
 */
export function createAnalyzedEmailCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnalyzedEmailCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnalyzedEmailDeliveryDetail}
 */
export function createAnalyzedEmailDeliveryDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnalyzedEmailDeliveryDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnalyzedEmailExchangeTransportRuleInfo}
 */
export function createAnalyzedEmailExchangeTransportRuleInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnalyzedEmailExchangeTransportRuleInfo;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnalyzedEmail}
 */
export function createAnalyzedEmailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnalyzedEmail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnalyzedEmailSenderDetail}
 */
export function createAnalyzedEmailSenderDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnalyzedEmailSenderDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnalyzedEmailUrl}
 */
export function createAnalyzedEmailUrlFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnalyzedEmailUrl;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnalyzedMessageEvidence}
 */
export function createAnalyzedMessageEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnalyzedMessageEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ApplyLabelAction}
 */
export function createApplyLabelActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoApplyLabelAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ArticleCollectionResponse}
 */
export function createArticleCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoArticleCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Article}
 */
export function createArticleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoArticle;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ArticleIndicatorCollectionResponse}
 */
export function createArticleIndicatorCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoArticleIndicatorCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ArticleIndicator}
 */
export function createArticleIndicatorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoArticleIndicator;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Artifact}
 */
export function createArtifactFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.host":
                    return deserializeIntoHost;
                case "#microsoft.graph.security.hostComponent":
                    return deserializeIntoHostComponent;
                case "#microsoft.graph.security.hostCookie":
                    return deserializeIntoHostCookie;
                case "#microsoft.graph.security.hostname":
                    return deserializeIntoHostname;
                case "#microsoft.graph.security.hostSslCertificate":
                    return deserializeIntoHostSslCertificate;
                case "#microsoft.graph.security.hostTracker":
                    return deserializeIntoHostTracker;
                case "#microsoft.graph.security.ipAddress":
                    return deserializeIntoIpAddress;
                case "#microsoft.graph.security.passiveDnsRecord":
                    return deserializeIntoPassiveDnsRecord;
                case "#microsoft.graph.security.sslCertificate":
                    return deserializeIntoSslCertificate;
                case "#microsoft.graph.security.unclassifiedArtifact":
                    return deserializeIntoUnclassifiedArtifact;
            }
        }
    }
    return deserializeIntoArtifact;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AttackSimulationInfo}
 */
export function createAttackSimulationInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAttackSimulationInfo;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AuditCoreRoot}
 */
export function createAuditCoreRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAuditCoreRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AuditData}
 */
export function createAuditDataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.defaultAuditData":
                    return deserializeIntoDefaultAuditData;
            }
        }
    }
    return deserializeIntoAuditData;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AuditLogQueryCollectionResponse}
 */
export function createAuditLogQueryCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAuditLogQueryCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AuditLogQuery}
 */
export function createAuditLogQueryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAuditLogQuery;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AuditLogRecordCollectionResponse}
 */
export function createAuditLogRecordCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAuditLogRecordCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AuditLogRecord}
 */
export function createAuditLogRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAuditLogRecord;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AuthorityTemplateCollectionResponse}
 */
export function createAuthorityTemplateCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAuthorityTemplateCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AuthorityTemplate}
 */
export function createAuthorityTemplateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAuthorityTemplate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AutonomousSystem}
 */
export function createAutonomousSystemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAutonomousSystem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AzureResourceEvidence}
 */
export function createAzureResourceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAzureResourceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BlobContainerEvidence}
 */
export function createBlobContainerEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBlobContainerEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BlobEvidence}
 */
export function createBlobEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBlobEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BlockFileResponseAction}
 */
export function createBlockFileResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBlockFileResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseEscaped}
 */
export function createCaseEscapedFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryCase":
                    return deserializeIntoEdiscoveryCase;
            }
        }
    }
    return deserializeIntoCaseEscaped;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseOperationCollectionResponse}
 */
export function createCaseOperationCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCaseOperationCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseOperation}
 */
export function createCaseOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryAddToReviewSetOperation":
                    return deserializeIntoEdiscoveryAddToReviewSetOperation;
                case "#microsoft.graph.security.ediscoveryEstimateOperation":
                    return deserializeIntoEdiscoveryEstimateOperation;
                case "#microsoft.graph.security.ediscoveryExportOperation":
                    return deserializeIntoEdiscoveryExportOperation;
                case "#microsoft.graph.security.ediscoveryHoldOperation":
                    return deserializeIntoEdiscoveryHoldOperation;
                case "#microsoft.graph.security.ediscoveryIndexOperation":
                    return deserializeIntoEdiscoveryIndexOperation;
                case "#microsoft.graph.security.ediscoveryPurgeDataOperation":
                    return deserializeIntoEdiscoveryPurgeDataOperation;
                case "#microsoft.graph.security.ediscoverySearchExportOperation":
                    return deserializeIntoEdiscoverySearchExportOperation;
                case "#microsoft.graph.security.ediscoveryTagOperation":
                    return deserializeIntoEdiscoveryTagOperation;
            }
        }
    }
    return deserializeIntoCaseOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CasesRoot}
 */
export function createCasesRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCasesRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CategoryTemplateCollectionResponse}
 */
export function createCategoryTemplateCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCategoryTemplateCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CategoryTemplate}
 */
export function createCategoryTemplateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCategoryTemplate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CitationTemplateCollectionResponse}
 */
export function createCitationTemplateCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCitationTemplateCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CitationTemplate}
 */
export function createCitationTemplateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCitationTemplate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ClassificationResult}
 */
export function createClassificationResultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoClassificationResult;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CloudApplicationEvidence}
 */
export function createCloudApplicationEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCloudApplicationEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CollaborationRoot}
 */
export function createCollaborationRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCollaborationRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CollectInvestigationPackageResponseAction}
 */
export function createCollectInvestigationPackageResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCollectInvestigationPackageResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContainerEvidence}
 */
export function createContainerEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContainerEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContainerImageEvidence}
 */
export function createContainerImageEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContainerImageEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContainerRegistryEvidence}
 */
export function createContainerRegistryEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContainerRegistryEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContentInfo}
 */
export function createContentInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContentInfo;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContentLabel}
 */
export function createContentLabelFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContentLabel;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CustomAction}
 */
export function createCustomActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCustomAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CvssSummary}
 */
export function createCvssSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCvssSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DataSet}
 */
export function createDataSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryReviewSet":
                    return deserializeIntoEdiscoveryReviewSet;
            }
        }
    }
    return deserializeIntoDataSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DataSourceCollectionResponse}
 */
export function createDataSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDataSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DataSourceContainer}
 */
export function createDataSourceContainerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryCustodian":
                    return deserializeIntoEdiscoveryCustodian;
                case "#microsoft.graph.security.ediscoveryNoncustodialDataSource":
                    return deserializeIntoEdiscoveryNoncustodialDataSource;
            }
        }
    }
    return deserializeIntoDataSourceContainer;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DataSource}
 */
export function createDataSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.siteSource":
                    return deserializeIntoSiteSource;
                case "#microsoft.graph.security.unifiedGroupSource":
                    return deserializeIntoUnifiedGroupSource;
                case "#microsoft.graph.security.userSource":
                    return deserializeIntoUserSource;
            }
        }
    }
    return deserializeIntoDataSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DefaultAuditData}
 */
export function createDefaultAuditDataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDefaultAuditData;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DepartmentTemplateCollectionResponse}
 */
export function createDepartmentTemplateCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDepartmentTemplateCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DepartmentTemplate}
 */
export function createDepartmentTemplateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDepartmentTemplate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentAccessKeyType}
 */
export function createDeploymentAccessKeyTypeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentAccessKeyType;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DetectionAction}
 */
export function createDetectionActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDetectionAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DetectionRuleCollectionResponse}
 */
export function createDetectionRuleCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDetectionRuleCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DetectionRule}
 */
export function createDetectionRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDetectionRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DetonationChain}
 */
export function createDetonationChainFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDetonationChain;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DetonationDetails}
 */
export function createDetonationDetailsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDetonationDetails;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DetonationObservables}
 */
export function createDetonationObservablesFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDetonationObservables;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeviceEvidence}
 */
export function createDeviceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeviceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Dictionary}
 */
export function createDictionaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDictionary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DisableUserResponseAction}
 */
export function createDisableUserResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDisableUserResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DispositionReviewStageCollectionResponse}
 */
export function createDispositionReviewStageCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDispositionReviewStageCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DispositionReviewStage}
 */
export function createDispositionReviewStageFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDispositionReviewStage;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DnsEvidence}
 */
export function createDnsEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDnsEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DowngradeJustification}
 */
export function createDowngradeJustificationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDowngradeJustification;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryAddToReviewSetOperation}
 */
export function createEdiscoveryAddToReviewSetOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryAddToReviewSetOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryCaseCollectionResponse}
 */
export function createEdiscoveryCaseCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryCaseCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryCase}
 */
export function createEdiscoveryCaseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryCase;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryCaseSettings}
 */
export function createEdiscoveryCaseSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryCaseSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryCustodianCollectionResponse}
 */
export function createEdiscoveryCustodianCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryCustodianCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryCustodian}
 */
export function createEdiscoveryCustodianFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryCustodian;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryEstimateOperation}
 */
export function createEdiscoveryEstimateOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryEstimateOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryExportOperation}
 */
export function createEdiscoveryExportOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryExportOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryFileCollectionResponse}
 */
export function createEdiscoveryFileCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryFileCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryFile}
 */
export function createEdiscoveryFileFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryFile;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryHoldOperation}
 */
export function createEdiscoveryHoldOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryHoldOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryHoldPolicyCollectionResponse}
 */
export function createEdiscoveryHoldPolicyCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryHoldPolicyCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryHoldPolicy}
 */
export function createEdiscoveryHoldPolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryHoldPolicy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryIndexOperation}
 */
export function createEdiscoveryIndexOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryIndexOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryNoncustodialDataSourceCollectionResponse}
 */
export function createEdiscoveryNoncustodialDataSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryNoncustodialDataSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryNoncustodialDataSource}
 */
export function createEdiscoveryNoncustodialDataSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryNoncustodialDataSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryPurgeDataOperation}
 */
export function createEdiscoveryPurgeDataOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryPurgeDataOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewSetCollectionResponse}
 */
export function createEdiscoveryReviewSetCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewSetCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewSet}
 */
export function createEdiscoveryReviewSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewSetQueryCollectionResponse}
 */
export function createEdiscoveryReviewSetQueryCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewSetQueryCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewSetQuery}
 */
export function createEdiscoveryReviewSetQueryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewSetQuery;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewTagCollectionResponse}
 */
export function createEdiscoveryReviewTagCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewTagCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewTag}
 */
export function createEdiscoveryReviewTagFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewTag;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoverySearchCollectionResponse}
 */
export function createEdiscoverySearchCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoverySearchCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoverySearchExportOperation}
 */
export function createEdiscoverySearchExportOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoverySearchExportOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoverySearch}
 */
export function createEdiscoverySearchFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoverySearch;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryTagOperation}
 */
export function createEdiscoveryTagOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryTagOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EmailContentThreatSubmission}
 */
export function createEmailContentThreatSubmissionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEmailContentThreatSubmission;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EmailSender}
 */
export function createEmailSenderFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEmailSender;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EmailThreatSubmissionCollectionResponse}
 */
export function createEmailThreatSubmissionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEmailThreatSubmissionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EmailThreatSubmission}
 */
export function createEmailThreatSubmissionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.emailContentThreatSubmission":
                    return deserializeIntoEmailContentThreatSubmission;
                case "#microsoft.graph.security.emailUrlThreatSubmission":
                    return deserializeIntoEmailUrlThreatSubmission;
            }
        }
    }
    return deserializeIntoEmailThreatSubmission;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EmailThreatSubmissionPolicyCollectionResponse}
 */
export function createEmailThreatSubmissionPolicyCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEmailThreatSubmissionPolicyCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EmailThreatSubmissionPolicy}
 */
export function createEmailThreatSubmissionPolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEmailThreatSubmissionPolicy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EmailUrlThreatSubmission}
 */
export function createEmailUrlThreatSubmissionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEmailUrlThreatSubmission;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EventPropagationResult}
 */
export function createEventPropagationResultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEventPropagationResult;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EventQuery}
 */
export function createEventQueryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEventQuery;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExportFileMetadata}
 */
export function createExportFileMetadataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExportFileMetadata;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileContentThreatSubmission}
 */
export function createFileContentThreatSubmissionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileContentThreatSubmission;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileDetails}
 */
export function createFileDetailsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileDetails;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileEvidence}
 */
export function createFileEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {File}
 */
export function createFileFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryFile":
                    return deserializeIntoEdiscoveryFile;
            }
        }
    }
    return deserializeIntoFile;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileHashEvidence}
 */
export function createFileHashEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileHashEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileHash}
 */
export function createFileHashFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileHash;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilePlanAppliedCategory}
 */
export function createFilePlanAppliedCategoryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilePlanAppliedCategory;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilePlanAuthority}
 */
export function createFilePlanAuthorityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilePlanAuthority;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilePlanCitation}
 */
export function createFilePlanCitationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilePlanCitation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilePlanDepartment}
 */
export function createFilePlanDepartmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilePlanDepartment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilePlanDescriptorBase}
 */
export function createFilePlanDescriptorBaseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.filePlanAppliedCategory":
                    return deserializeIntoFilePlanAppliedCategory;
                case "#microsoft.graph.security.filePlanAuthority":
                    return deserializeIntoFilePlanAuthority;
                case "#microsoft.graph.security.filePlanCitation":
                    return deserializeIntoFilePlanCitation;
                case "#microsoft.graph.security.filePlanDepartment":
                    return deserializeIntoFilePlanDepartment;
                case "#microsoft.graph.security.filePlanReference":
                    return deserializeIntoFilePlanReference;
                case "#microsoft.graph.security.filePlanSubcategory":
                    return deserializeIntoFilePlanSubcategory;
            }
        }
    }
    return deserializeIntoFilePlanDescriptorBase;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilePlanDescriptor}
 */
export function createFilePlanDescriptorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilePlanDescriptor;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilePlanDescriptorTemplate}
 */
export function createFilePlanDescriptorTemplateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.authorityTemplate":
                    return deserializeIntoAuthorityTemplate;
                case "#microsoft.graph.security.categoryTemplate":
                    return deserializeIntoCategoryTemplate;
                case "#microsoft.graph.security.citationTemplate":
                    return deserializeIntoCitationTemplate;
                case "#microsoft.graph.security.departmentTemplate":
                    return deserializeIntoDepartmentTemplate;
                case "#microsoft.graph.security.filePlanReferenceTemplate":
                    return deserializeIntoFilePlanReferenceTemplate;
                case "#microsoft.graph.security.subcategoryTemplate":
                    return deserializeIntoSubcategoryTemplate;
            }
        }
    }
    return deserializeIntoFilePlanDescriptorTemplate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilePlanReference}
 */
export function createFilePlanReferenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilePlanReference;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilePlanReferenceTemplateCollectionResponse}
 */
export function createFilePlanReferenceTemplateCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilePlanReferenceTemplateCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilePlanReferenceTemplate}
 */
export function createFilePlanReferenceTemplateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilePlanReferenceTemplate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilePlanSubcategory}
 */
export function createFilePlanSubcategoryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilePlanSubcategory;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileThreatSubmissionCollectionResponse}
 */
export function createFileThreatSubmissionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileThreatSubmissionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileThreatSubmission}
 */
export function createFileThreatSubmissionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.fileContentThreatSubmission":
                    return deserializeIntoFileContentThreatSubmission;
                case "#microsoft.graph.security.fileUrlThreatSubmission":
                    return deserializeIntoFileUrlThreatSubmission;
            }
        }
    }
    return deserializeIntoFileThreatSubmission;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileUrlThreatSubmission}
 */
export function createFileUrlThreatSubmissionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileUrlThreatSubmission;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ForceUserPasswordResetResponseAction}
 */
export function createForceUserPasswordResetResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoForceUserPasswordResetResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FormattedContent}
 */
export function createFormattedContentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFormattedContent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GeoLocation}
 */
export function createGeoLocationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGeoLocation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GitHubOrganizationEvidence}
 */
export function createGitHubOrganizationEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGitHubOrganizationEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GitHubRepoEvidence}
 */
export function createGitHubRepoEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGitHubRepoEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GitHubUserEvidence}
 */
export function createGitHubUserEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGitHubUserEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GoogleCloudResourceEvidence}
 */
export function createGoogleCloudResourceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGoogleCloudResourceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HardDeleteResponseAction}
 */
export function createHardDeleteResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHardDeleteResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HealthIssueCollectionResponse}
 */
export function createHealthIssueCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHealthIssueCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HealthIssue}
 */
export function createHealthIssueFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHealthIssue;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostCollectionResponse}
 */
export function createHostCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostComponentCollectionResponse}
 */
export function createHostComponentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostComponentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostComponent}
 */
export function createHostComponentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostComponent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostCookieCollectionResponse}
 */
export function createHostCookieCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostCookieCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostCookie}
 */
export function createHostCookieFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostCookie;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Host}
 */
export function createHostFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.hostname":
                    return deserializeIntoHostname;
                case "#microsoft.graph.security.ipAddress":
                    return deserializeIntoIpAddress;
            }
        }
    }
    return deserializeIntoHost;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostLogonSessionEvidence}
 */
export function createHostLogonSessionEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostLogonSessionEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Hostname}
 */
export function createHostnameFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostname;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPairCollectionResponse}
 */
export function createHostPairCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPairCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPair}
 */
export function createHostPairFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPair;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPortBanner}
 */
export function createHostPortBannerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPortBanner;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPortCollectionResponse}
 */
export function createHostPortCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPortCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPortComponent}
 */
export function createHostPortComponentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPortComponent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPort}
 */
export function createHostPortFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPort;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostReputation}
 */
export function createHostReputationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostReputation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostReputationRule}
 */
export function createHostReputationRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostReputationRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostSslCertificateCollectionResponse}
 */
export function createHostSslCertificateCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostSslCertificateCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostSslCertificate}
 */
export function createHostSslCertificateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostSslCertificate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostSslCertificatePort}
 */
export function createHostSslCertificatePortFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostSslCertificatePort;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostTrackerCollectionResponse}
 */
export function createHostTrackerCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostTrackerCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostTracker}
 */
export function createHostTrackerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostTracker;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HuntingQueryResults}
 */
export function createHuntingQueryResultsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHuntingQueryResults;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HuntingRowResult}
 */
export function createHuntingRowResultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHuntingRowResult;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Hyperlink}
 */
export function createHyperlinkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHyperlink;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IdentityContainer}
 */
export function createIdentityContainerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIdentityContainer;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ImpactedAsset}
 */
export function createImpactedAssetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.impactedDeviceAsset":
                    return deserializeIntoImpactedDeviceAsset;
                case "#microsoft.graph.security.impactedMailboxAsset":
                    return deserializeIntoImpactedMailboxAsset;
                case "#microsoft.graph.security.impactedUserAsset":
                    return deserializeIntoImpactedUserAsset;
            }
        }
    }
    return deserializeIntoImpactedAsset;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ImpactedDeviceAsset}
 */
export function createImpactedDeviceAssetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoImpactedDeviceAsset;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ImpactedMailboxAsset}
 */
export function createImpactedMailboxAssetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoImpactedMailboxAsset;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ImpactedUserAsset}
 */
export function createImpactedUserAssetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoImpactedUserAsset;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IncidentCollectionResponse}
 */
export function createIncidentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIncidentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Incident}
 */
export function createIncidentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIncident;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Indicator}
 */
export function createIndicatorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.articleIndicator":
                    return deserializeIntoArticleIndicator;
                case "#microsoft.graph.security.intelligenceProfileIndicator":
                    return deserializeIntoIntelligenceProfileIndicator;
            }
        }
    }
    return deserializeIntoIndicator;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {InformationProtectionAction}
 */
export function createInformationProtectionActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.addContentFooterAction":
                    return deserializeIntoAddContentFooterAction;
                case "#microsoft.graph.security.addContentHeaderAction":
                    return deserializeIntoAddContentHeaderAction;
                case "#microsoft.graph.security.addWatermarkAction":
                    return deserializeIntoAddWatermarkAction;
                case "#microsoft.graph.security.applyLabelAction":
                    return deserializeIntoApplyLabelAction;
                case "#microsoft.graph.security.customAction":
                    return deserializeIntoCustomAction;
                case "#microsoft.graph.security.justifyAction":
                    return deserializeIntoJustifyAction;
                case "#microsoft.graph.security.metadataAction":
                    return deserializeIntoMetadataAction;
                case "#microsoft.graph.security.protectAdhocAction":
                    return deserializeIntoProtectAdhocAction;
                case "#microsoft.graph.security.protectByTemplateAction":
                    return deserializeIntoProtectByTemplateAction;
                case "#microsoft.graph.security.protectDoNotForwardAction":
                    return deserializeIntoProtectDoNotForwardAction;
                case "#microsoft.graph.security.recommendLabelAction":
                    return deserializeIntoRecommendLabelAction;
                case "#microsoft.graph.security.removeContentFooterAction":
                    return deserializeIntoRemoveContentFooterAction;
                case "#microsoft.graph.security.removeContentHeaderAction":
                    return deserializeIntoRemoveContentHeaderAction;
                case "#microsoft.graph.security.removeProtectionAction":
                    return deserializeIntoRemoveProtectionAction;
                case "#microsoft.graph.security.removeWatermarkAction":
                    return deserializeIntoRemoveWatermarkAction;
            }
        }
    }
    return deserializeIntoInformationProtectionAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {InformationProtection}
 */
export function createInformationProtectionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoInformationProtection;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {InformationProtectionPolicySetting}
 */
export function createInformationProtectionPolicySettingFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoInformationProtectionPolicySetting;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {InitiateInvestigationResponseAction}
 */
export function createInitiateInvestigationResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoInitiateInvestigationResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IntelligenceProfileCollectionResponse}
 */
export function createIntelligenceProfileCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIntelligenceProfileCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IntelligenceProfileCountryOrRegionOfOrigin}
 */
export function createIntelligenceProfileCountryOrRegionOfOriginFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIntelligenceProfileCountryOrRegionOfOrigin;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IntelligenceProfile}
 */
export function createIntelligenceProfileFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIntelligenceProfile;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IntelligenceProfileIndicatorCollectionResponse}
 */
export function createIntelligenceProfileIndicatorCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIntelligenceProfileIndicatorCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IntelligenceProfileIndicator}
 */
export function createIntelligenceProfileIndicatorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIntelligenceProfileIndicator;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IoTDeviceEvidence}
 */
export function createIoTDeviceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIoTDeviceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IpAddress}
 */
export function createIpAddressFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIpAddress;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IpEvidence}
 */
export function createIpEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIpEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IsolateDeviceResponseAction}
 */
export function createIsolateDeviceResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIsolateDeviceResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {JustifyAction}
 */
export function createJustifyActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoJustifyAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KeyValuePair}
 */
export function createKeyValuePairFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKeyValuePair;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesClusterEvidence}
 */
export function createKubernetesClusterEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesClusterEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesControllerEvidence}
 */
export function createKubernetesControllerEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesControllerEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesNamespaceEvidence}
 */
export function createKubernetesNamespaceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesNamespaceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesPodEvidence}
 */
export function createKubernetesPodEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesPodEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesSecretEvidence}
 */
export function createKubernetesSecretEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesSecretEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesServiceAccountEvidence}
 */
export function createKubernetesServiceAccountEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesServiceAccountEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesServiceEvidence}
 */
export function createKubernetesServiceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesServiceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesServicePort}
 */
export function createKubernetesServicePortFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesServicePort;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LabelingOptions}
 */
export function createLabelingOptionsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLabelingOptions;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LabelsRoot}
 */
export function createLabelsRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLabelsRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LoggedOnUser}
 */
export function createLoggedOnUserFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLoggedOnUser;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MailboxConfigurationEvidence}
 */
export function createMailboxConfigurationEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMailboxConfigurationEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MailboxEvidence}
 */
export function createMailboxEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMailboxEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MailClusterEvidence}
 */
export function createMailClusterEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMailClusterEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MalwareEvidence}
 */
export function createMalwareEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMalwareEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MarkUserAsCompromisedResponseAction}
 */
export function createMarkUserAsCompromisedResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMarkUserAsCompromisedResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MetadataAction}
 */
export function createMetadataActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMetadataAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MoveToDeletedItemsResponseAction}
 */
export function createMoveToDeletedItemsResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMoveToDeletedItemsResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MoveToInboxResponseAction}
 */
export function createMoveToInboxResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMoveToInboxResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MoveToJunkResponseAction}
 */
export function createMoveToJunkResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMoveToJunkResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NetworkAdapter}
 */
export function createNetworkAdapterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNetworkAdapter;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NetworkConnectionEvidence}
 */
export function createNetworkConnectionEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNetworkConnectionEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NicEvidence}
 */
export function createNicEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNicEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OauthApplicationEvidence}
 */
export function createOauthApplicationEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOauthApplicationEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OcrSettings}
 */
export function createOcrSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOcrSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OrganizationalScope}
 */
export function createOrganizationalScopeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOrganizationalScope;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PassiveDnsRecordCollectionResponse}
 */
export function createPassiveDnsRecordCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPassiveDnsRecordCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PassiveDnsRecord}
 */
export function createPassiveDnsRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPassiveDnsRecord;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PolicyBase}
 */
export function createPolicyBaseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryHoldPolicy":
                    return deserializeIntoEdiscoveryHoldPolicy;
            }
        }
    }
    return deserializeIntoPolicyBase;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProcessEvidence}
 */
export function createProcessEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProcessEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProtectAdhocAction}
 */
export function createProtectAdhocActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProtectAdhocAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProtectByTemplateAction}
 */
export function createProtectByTemplateActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProtectByTemplateAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProtectDoNotForwardAction}
 */
export function createProtectDoNotForwardActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProtectDoNotForwardAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProtectionRule}
 */
export function createProtectionRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.detectionRule":
                    return deserializeIntoDetectionRule;
            }
        }
    }
    return deserializeIntoProtectionRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {QueryCondition}
 */
export function createQueryConditionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQueryCondition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RecommendedHuntingQuery}
 */
export function createRecommendedHuntingQueryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRecommendedHuntingQuery;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RecommendLabelAction}
 */
export function createRecommendLabelActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRecommendLabelAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RedundancyDetectionSettings}
 */
export function createRedundancyDetectionSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRedundancyDetectionSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RegistryKeyEvidence}
 */
export function createRegistryKeyEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRegistryKeyEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RegistryValueEvidence}
 */
export function createRegistryValueEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRegistryValueEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RemoveContentFooterAction}
 */
export function createRemoveContentFooterActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRemoveContentFooterAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RemoveContentHeaderAction}
 */
export function createRemoveContentHeaderActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRemoveContentHeaderAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RemoveProtectionAction}
 */
export function createRemoveProtectionActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRemoveProtectionAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RemoveWatermarkAction}
 */
export function createRemoveWatermarkActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRemoveWatermarkAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ResponseAction}
 */
export function createResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.allowFileResponseAction":
                    return deserializeIntoAllowFileResponseAction;
                case "#microsoft.graph.security.blockFileResponseAction":
                    return deserializeIntoBlockFileResponseAction;
                case "#microsoft.graph.security.collectInvestigationPackageResponseAction":
                    return deserializeIntoCollectInvestigationPackageResponseAction;
                case "#microsoft.graph.security.disableUserResponseAction":
                    return deserializeIntoDisableUserResponseAction;
                case "#microsoft.graph.security.forceUserPasswordResetResponseAction":
                    return deserializeIntoForceUserPasswordResetResponseAction;
                case "#microsoft.graph.security.hardDeleteResponseAction":
                    return deserializeIntoHardDeleteResponseAction;
                case "#microsoft.graph.security.initiateInvestigationResponseAction":
                    return deserializeIntoInitiateInvestigationResponseAction;
                case "#microsoft.graph.security.isolateDeviceResponseAction":
                    return deserializeIntoIsolateDeviceResponseAction;
                case "#microsoft.graph.security.markUserAsCompromisedResponseAction":
                    return deserializeIntoMarkUserAsCompromisedResponseAction;
                case "#microsoft.graph.security.moveToDeletedItemsResponseAction":
                    return deserializeIntoMoveToDeletedItemsResponseAction;
                case "#microsoft.graph.security.moveToInboxResponseAction":
                    return deserializeIntoMoveToInboxResponseAction;
                case "#microsoft.graph.security.moveToJunkResponseAction":
                    return deserializeIntoMoveToJunkResponseAction;
                case "#microsoft.graph.security.restrictAppExecutionResponseAction":
                    return deserializeIntoRestrictAppExecutionResponseAction;
                case "#microsoft.graph.security.runAntivirusScanResponseAction":
                    return deserializeIntoRunAntivirusScanResponseAction;
                case "#microsoft.graph.security.softDeleteResponseAction":
                    return deserializeIntoSoftDeleteResponseAction;
                case "#microsoft.graph.security.stopAndQuarantineFileResponseAction":
                    return deserializeIntoStopAndQuarantineFileResponseAction;
            }
        }
    }
    return deserializeIntoResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RestrictAppExecutionResponseAction}
 */
export function createRestrictAppExecutionResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRestrictAppExecutionResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionDurationForever}
 */
export function createRetentionDurationForeverFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionDurationForever;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionDuration}
 */
export function createRetentionDurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.retentionDurationForever":
                    return deserializeIntoRetentionDurationForever;
                case "#microsoft.graph.security.retentionDurationInDays":
                    return deserializeIntoRetentionDurationInDays;
            }
        }
    }
    return deserializeIntoRetentionDuration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionDurationInDays}
 */
export function createRetentionDurationInDaysFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionDurationInDays;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionEventCollectionResponse}
 */
export function createRetentionEventCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionEventCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionEvent}
 */
export function createRetentionEventFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionEvent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionEventStatus}
 */
export function createRetentionEventStatusFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionEventStatus;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionEventTypeCollectionResponse}
 */
export function createRetentionEventTypeCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionEventTypeCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionEventType}
 */
export function createRetentionEventTypeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionEventType;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionLabelCollectionResponse}
 */
export function createRetentionLabelCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionLabelCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionLabel}
 */
export function createRetentionLabelFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionLabel;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RuleSchedule}
 */
export function createRuleScheduleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRuleSchedule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RulesRoot}
 */
export function createRulesRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRulesRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RunAntivirusScanResponseAction}
 */
export function createRunAntivirusScanResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRunAntivirusScanResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RunDetails}
 */
export function createRunDetailsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRunDetails;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SasTokenEvidence}
 */
export function createSasTokenEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSasTokenEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Search}
 */
export function createSearchFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryReviewSetQuery":
                    return deserializeIntoEdiscoveryReviewSetQuery;
                case "#microsoft.graph.security.ediscoverySearch":
                    return deserializeIntoEdiscoverySearch;
            }
        }
    }
    return deserializeIntoSearch;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Security}
 */
export function createSecurityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSecurity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SecurityGroupEvidence}
 */
export function createSecurityGroupEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSecurityGroupEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SensitivityLabelCollectionResponse}
 */
export function createSensitivityLabelCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSensitivityLabelCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SensitivityLabel}
 */
export function createSensitivityLabelFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSensitivityLabel;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SensorCollectionResponse}
 */
export function createSensorCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSensorCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SensorDeploymentPackage}
 */
export function createSensorDeploymentPackageFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSensorDeploymentPackage;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Sensor}
 */
export function createSensorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSensor;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SensorSettings}
 */
export function createSensorSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSensorSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServicePrincipalEvidence}
 */
export function createServicePrincipalEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServicePrincipalEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SinglePropertySchema}
 */
export function createSinglePropertySchemaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSinglePropertySchema;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SiteSourceCollectionResponse}
 */
export function createSiteSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSiteSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SiteSource}
 */
export function createSiteSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSiteSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SoftDeleteResponseAction}
 */
export function createSoftDeleteResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSoftDeleteResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SslCertificateCollectionResponse}
 */
export function createSslCertificateCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSslCertificateCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SslCertificateEntity}
 */
export function createSslCertificateEntityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSslCertificateEntity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SslCertificate}
 */
export function createSslCertificateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSslCertificate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StopAndQuarantineFileResponseAction}
 */
export function createStopAndQuarantineFileResponseActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStopAndQuarantineFileResponseAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Stream}
 */
export function createStreamFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStream;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StringValueDictionary}
 */
export function createStringValueDictionaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStringValueDictionary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubcategoryTemplateCollectionResponse}
 */
export function createSubcategoryTemplateCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubcategoryTemplateCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubcategoryTemplate}
 */
export function createSubcategoryTemplateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubcategoryTemplate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubdomainCollectionResponse}
 */
export function createSubdomainCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubdomainCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Subdomain}
 */
export function createSubdomainFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubdomain;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubmissionAdminReview}
 */
export function createSubmissionAdminReviewFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubmissionAdminReview;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubmissionDetectedFile}
 */
export function createSubmissionDetectedFileFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubmissionDetectedFile;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubmissionMailEvidence}
 */
export function createSubmissionMailEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubmissionMailEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubmissionResult}
 */
export function createSubmissionResultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubmissionResult;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubmissionUserIdentity}
 */
export function createSubmissionUserIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubmissionUserIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Tag}
 */
export function createTagFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryReviewTag":
                    return deserializeIntoEdiscoveryReviewTag;
            }
        }
    }
    return deserializeIntoTag;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TenantAllowBlockListEntryResult}
 */
export function createTenantAllowBlockListEntryResultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTenantAllowBlockListEntryResult;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TenantAllowOrBlockListAction}
 */
export function createTenantAllowOrBlockListActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTenantAllowOrBlockListAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatIntelligence}
 */
export function createThreatIntelligenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThreatIntelligence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatSubmission}
 */
export function createThreatSubmissionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.emailContentThreatSubmission":
                    return deserializeIntoEmailContentThreatSubmission;
                case "#microsoft.graph.security.emailThreatSubmission":
                    return deserializeIntoEmailThreatSubmission;
                case "#microsoft.graph.security.emailUrlThreatSubmission":
                    return deserializeIntoEmailUrlThreatSubmission;
                case "#microsoft.graph.security.fileContentThreatSubmission":
                    return deserializeIntoFileContentThreatSubmission;
                case "#microsoft.graph.security.fileThreatSubmission":
                    return deserializeIntoFileThreatSubmission;
                case "#microsoft.graph.security.fileUrlThreatSubmission":
                    return deserializeIntoFileUrlThreatSubmission;
                case "#microsoft.graph.security.urlThreatSubmission":
                    return deserializeIntoUrlThreatSubmission;
            }
        }
    }
    return deserializeIntoThreatSubmission;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatSubmissionRoot}
 */
export function createThreatSubmissionRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThreatSubmissionRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TopicModelingSettings}
 */
export function createTopicModelingSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTopicModelingSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TriggersRoot}
 */
export function createTriggersRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTriggersRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TriggerTypesRoot}
 */
export function createTriggerTypesRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTriggerTypesRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UnclassifiedArtifact}
 */
export function createUnclassifiedArtifactFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUnclassifiedArtifact;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UnifiedGroupSourceCollectionResponse}
 */
export function createUnifiedGroupSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUnifiedGroupSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UnifiedGroupSource}
 */
export function createUnifiedGroupSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUnifiedGroupSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UrlEvidence}
 */
export function createUrlEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUrlEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UrlThreatSubmissionCollectionResponse}
 */
export function createUrlThreatSubmissionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUrlThreatSubmissionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UrlThreatSubmission}
 */
export function createUrlThreatSubmissionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUrlThreatSubmission;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserAccount}
 */
export function createUserAccountFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserAccount;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserEvidence}
 */
export function createUserEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserSourceCollectionResponse}
 */
export function createUserSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserSource}
 */
export function createUserSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {VmMetadata}
 */
export function createVmMetadataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoVmMetadata;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {VulnerabilityCollectionResponse}
 */
export function createVulnerabilityCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoVulnerabilityCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {VulnerabilityComponentCollectionResponse}
 */
export function createVulnerabilityComponentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoVulnerabilityComponentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {VulnerabilityComponent}
 */
export function createVulnerabilityComponentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoVulnerabilityComponent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Vulnerability}
 */
export function createVulnerabilityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoVulnerability;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisBaseRecord}
 */
export function createWhoisBaseRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.whoisHistoryRecord":
                    return deserializeIntoWhoisHistoryRecord;
                case "#microsoft.graph.security.whoisRecord":
                    return deserializeIntoWhoisRecord;
            }
        }
    }
    return deserializeIntoWhoisBaseRecord;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisContact}
 */
export function createWhoisContactFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisContact;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisHistoryRecordCollectionResponse}
 */
export function createWhoisHistoryRecordCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisHistoryRecordCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisHistoryRecord}
 */
export function createWhoisHistoryRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisHistoryRecord;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisNameserver}
 */
export function createWhoisNameserverFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisNameserver;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisRecordCollectionResponse}
 */
export function createWhoisRecordCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisRecordCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisRecord}
 */
export function createWhoisRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisRecord;
}
export interface CustomAction extends InformationProtectionAction, Parsable {
    /**
     * Name of the custom action.
     */
    name?: string;
    /**
     * Properties, in key-value pair format, of the action.
     */
    properties?: KeyValuePair[];
}
export interface CvssSummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The CVSS score about this vulnerability.
     */
    score?: number;
    /**
     * The CVSS severity rating for this vulnerability. The possible values are: none, low, medium, high, critical, unknownFutureValue.
     */
    severity?: VulnerabilitySeverity;
    /**
     * The CVSS vector string for this vulnerability.
     */
    vectorString?: string;
}
export interface DataSet extends Entity, Parsable {
    /**
     * The createdBy property
     */
    createdBy?: IdentitySet;
    /**
     * The createdDateTime property
     */
    createdDateTime?: Date;
    /**
     * The displayName property
     */
    displayName?: string;
}
export interface DataSource extends Entity, Parsable {
    /**
     * The user who created the dataSource.
     */
    createdBy?: IdentitySet;
    /**
     * The date and time the dataSource was created.
     */
    createdDateTime?: Date;
    /**
     * The display name of the dataSource and is the name of the SharePoint site.
     */
    displayName?: string;
    /**
     * The hold status of the dataSource.The possible values are: notApplied, applied, applying, removing, partial
     */
    holdStatus?: DataSourceHoldStatus;
}
export interface DataSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: DataSource[];
}
export interface DataSourceContainer extends Entity, Parsable {
    /**
     * Created date and time of the dataSourceContainer entity.
     */
    createdDateTime?: Date;
    /**
     * Display name of the dataSourceContainer entity.
     */
    displayName?: string;
    /**
     * The hold status of the dataSourceContainer. The possible values are: notApplied, applied, applying, removing, partial
     */
    holdStatus?: DataSourceHoldStatus;
    /**
     * Last modified date and time of the dataSourceContainer.
     */
    lastModifiedDateTime?: Date;
    /**
     * Date and time that the dataSourceContainer was released from the case.
     */
    releasedDateTime?: Date;
    /**
     * Latest status of the dataSourceContainer. Possible values are: Active, Released.
     */
    status?: DataSourceContainerStatus;
}
export type DataSourceContainerStatus = (typeof DataSourceContainerStatusObject)[keyof typeof DataSourceContainerStatusObject];
export type DataSourceHoldStatus = (typeof DataSourceHoldStatusObject)[keyof typeof DataSourceHoldStatusObject];
export type DataSourceScopes = (typeof DataSourceScopesObject)[keyof typeof DataSourceScopesObject];
export interface DefaultAuditData extends AuditData, Parsable {
}
export type DefaultRecordBehavior = (typeof DefaultRecordBehaviorObject)[keyof typeof DefaultRecordBehaviorObject];
export type DefenderAvStatus = (typeof DefenderAvStatusObject)[keyof typeof DefenderAvStatusObject];
export type DeliveryAction = (typeof DeliveryActionObject)[keyof typeof DeliveryActionObject];
export type DeliveryLocation = (typeof DeliveryLocationObject)[keyof typeof DeliveryLocationObject];
export interface DepartmentTemplate extends FilePlanDescriptorTemplate, Parsable {
}
export interface DepartmentTemplateCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: DepartmentTemplate[];
}
export interface DeploymentAccessKeyType extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The deploymentAccessKey property
     */
    deploymentAccessKey?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type DeploymentStatus = (typeof DeploymentStatusObject)[keyof typeof DeploymentStatusObject];
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAddContentFooterAction(addContentFooterAction: Partial<AddContentFooterAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(addContentFooterAction),
        "alignment": n => { addContentFooterAction.alignment = n.getEnumValue<ContentAlignment>(ContentAlignmentObject); },
        "fontColor": n => { addContentFooterAction.fontColor = n.getStringValue(); },
        "fontName": n => { addContentFooterAction.fontName = n.getStringValue(); },
        "fontSize": n => { addContentFooterAction.fontSize = n.getNumberValue(); },
        "margin": n => { addContentFooterAction.margin = n.getNumberValue(); },
        "text": n => { addContentFooterAction.text = n.getStringValue(); },
        "uiElementName": n => { addContentFooterAction.uiElementName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAddContentHeaderAction(addContentHeaderAction: Partial<AddContentHeaderAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(addContentHeaderAction),
        "alignment": n => { addContentHeaderAction.alignment = n.getEnumValue<ContentAlignment>(ContentAlignmentObject); },
        "fontColor": n => { addContentHeaderAction.fontColor = n.getStringValue(); },
        "fontName": n => { addContentHeaderAction.fontName = n.getStringValue(); },
        "fontSize": n => { addContentHeaderAction.fontSize = n.getNumberValue(); },
        "margin": n => { addContentHeaderAction.margin = n.getNumberValue(); },
        "text": n => { addContentHeaderAction.text = n.getStringValue(); },
        "uiElementName": n => { addContentHeaderAction.uiElementName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAddWatermarkAction(addWatermarkAction: Partial<AddWatermarkAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(addWatermarkAction),
        "fontColor": n => { addWatermarkAction.fontColor = n.getStringValue(); },
        "fontName": n => { addWatermarkAction.fontName = n.getStringValue(); },
        "fontSize": n => { addWatermarkAction.fontSize = n.getNumberValue(); },
        "layout": n => { addWatermarkAction.layout = n.getEnumValue<WatermarkLayout>(WatermarkLayoutObject); },
        "text": n => { addWatermarkAction.text = n.getStringValue(); },
        "uiElementName": n => { addWatermarkAction.uiElementName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAlert(alert: Partial<Alert> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(alert),
        "actorDisplayName": n => { alert.actorDisplayName = n.getStringValue(); },
        "additionalData": n => { alert.additionalDataProperty = n.getObjectValue<Dictionary>(createDictionaryFromDiscriminatorValue); },
        "alertPolicyId": n => { alert.alertPolicyId = n.getStringValue(); },
        "alertWebUrl": n => { alert.alertWebUrl = n.getStringValue(); },
        "assignedTo": n => { alert.assignedTo = n.getStringValue(); },
        "category": n => { alert.category = n.getStringValue(); },
        "classification": n => { alert.classification = n.getEnumValue<AlertClassification>(AlertClassificationObject); },
        "comments": n => { alert.comments = n.getCollectionOfObjectValues<AlertComment>(createAlertCommentFromDiscriminatorValue); },
        "createdDateTime": n => { alert.createdDateTime = n.getDateValue(); },
        "description": n => { alert.description = n.getStringValue(); },
        "detectionSource": n => { alert.detectionSource = n.getEnumValue<DetectionSource>(DetectionSourceObject); },
        "detectorId": n => { alert.detectorId = n.getStringValue(); },
        "determination": n => { alert.determination = n.getEnumValue<AlertDetermination>(AlertDeterminationObject); },
        "evidence": n => { alert.evidence = n.getCollectionOfObjectValues<AlertEvidence>(createAlertEvidenceFromDiscriminatorValue); },
        "firstActivityDateTime": n => { alert.firstActivityDateTime = n.getDateValue(); },
        "incidentId": n => { alert.incidentId = n.getStringValue(); },
        "incidentWebUrl": n => { alert.incidentWebUrl = n.getStringValue(); },
        "lastActivityDateTime": n => { alert.lastActivityDateTime = n.getDateValue(); },
        "lastUpdateDateTime": n => { alert.lastUpdateDateTime = n.getDateValue(); },
        "mitreTechniques": n => { alert.mitreTechniques = n.getCollectionOfPrimitiveValues<string>(); },
        "productName": n => { alert.productName = n.getStringValue(); },
        "providerAlertId": n => { alert.providerAlertId = n.getStringValue(); },
        "recommendedActions": n => { alert.recommendedActions = n.getStringValue(); },
        "resolvedDateTime": n => { alert.resolvedDateTime = n.getDateValue(); },
        "serviceSource": n => { alert.serviceSource = n.getEnumValue<ServiceSource>(ServiceSourceObject); },
        "severity": n => { alert.severity = n.getEnumValue<AlertSeverity>(AlertSeverityObject); },
        "status": n => { alert.status = n.getEnumValue<AlertStatus>(AlertStatusObject); },
        "systemTags": n => { alert.systemTags = n.getCollectionOfPrimitiveValues<string>(); },
        "tenantId": n => { alert.tenantId = n.getStringValue(); },
        "threatDisplayName": n => { alert.threatDisplayName = n.getStringValue(); },
        "threatFamilyName": n => { alert.threatFamilyName = n.getStringValue(); },
        "title": n => { alert.title = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAlertCollectionResponse(alertCollectionResponse: Partial<AlertCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(alertCollectionResponse),
        "value": n => { alertCollectionResponse.value = n.getCollectionOfObjectValues<Alert>(createAlertFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAlertComment(alertComment: Partial<AlertComment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { alertComment.backingStoreEnabled = true; },
        "comment": n => { alertComment.comment = n.getStringValue(); },
        "createdByDisplayName": n => { alertComment.createdByDisplayName = n.getStringValue(); },
        "createdDateTime": n => { alertComment.createdDateTime = n.getDateValue(); },
        "@odata.type": n => { alertComment.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAlertEvidence(alertEvidence: Partial<AlertEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { alertEvidence.backingStoreEnabled = true; },
        "createdDateTime": n => { alertEvidence.createdDateTime = n.getDateValue(); },
        "detailedRoles": n => { alertEvidence.detailedRoles = n.getCollectionOfPrimitiveValues<string>(); },
        "@odata.type": n => { alertEvidence.odataType = n.getStringValue(); },
        "remediationStatus": n => { alertEvidence.remediationStatus = n.getEnumValue<EvidenceRemediationStatus>(EvidenceRemediationStatusObject); },
        "remediationStatusDetails": n => { alertEvidence.remediationStatusDetails = n.getStringValue(); },
        "roles": n => { alertEvidence.roles = n.getCollectionOfEnumValues<EvidenceRole>(EvidenceRoleObject); },
        "tags": n => { alertEvidence.tags = n.getCollectionOfPrimitiveValues<string>(); },
        "verdict": n => { alertEvidence.verdict = n.getEnumValue<EvidenceVerdict>(EvidenceVerdictObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAlertTemplate(alertTemplate: Partial<AlertTemplate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { alertTemplate.backingStoreEnabled = true; },
        "category": n => { alertTemplate.category = n.getStringValue(); },
        "description": n => { alertTemplate.description = n.getStringValue(); },
        "impactedAssets": n => { alertTemplate.impactedAssets = n.getCollectionOfObjectValues<ImpactedAsset>(createImpactedAssetFromDiscriminatorValue); },
        "mitreTechniques": n => { alertTemplate.mitreTechniques = n.getCollectionOfPrimitiveValues<string>(); },
        "@odata.type": n => { alertTemplate.odataType = n.getStringValue(); },
        "recommendedActions": n => { alertTemplate.recommendedActions = n.getStringValue(); },
        "severity": n => { alertTemplate.severity = n.getEnumValue<AlertSeverity>(AlertSeverityObject); },
        "title": n => { alertTemplate.title = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAllowFileResponseAction(allowFileResponseAction: Partial<AllowFileResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(allowFileResponseAction),
        "deviceGroupNames": n => { allowFileResponseAction.deviceGroupNames = n.getCollectionOfPrimitiveValues<string>(); },
        "identifier": n => { allowFileResponseAction.identifier = n.getCollectionOfEnumValues<FileEntityIdentifier>(FileEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAmazonResourceEvidence(amazonResourceEvidence: Partial<AmazonResourceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(amazonResourceEvidence),
        "amazonAccountId": n => { amazonResourceEvidence.amazonAccountId = n.getStringValue(); },
        "amazonResourceId": n => { amazonResourceEvidence.amazonResourceId = n.getStringValue(); },
        "resourceName": n => { amazonResourceEvidence.resourceName = n.getStringValue(); },
        "resourceType": n => { amazonResourceEvidence.resourceType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnalyzedEmail(analyzedEmail: Partial<AnalyzedEmail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(analyzedEmail),
        "alertIds": n => { analyzedEmail.alertIds = n.getCollectionOfPrimitiveValues<string>(); },
        "attachments": n => { analyzedEmail.attachments = n.getCollectionOfObjectValues<AnalyzedEmailAttachment>(createAnalyzedEmailAttachmentFromDiscriminatorValue); },
        "attachmentsCount": n => { analyzedEmail.attachmentsCount = n.getNumberValue(); },
        "authenticationDetails": n => { analyzedEmail.authenticationDetails = n.getObjectValue<AnalyzedEmailAuthenticationDetail>(createAnalyzedEmailAuthenticationDetailFromDiscriminatorValue); },
        "bulkComplaintLevel": n => { analyzedEmail.bulkComplaintLevel = n.getStringValue(); },
        "contexts": n => { analyzedEmail.contexts = n.getCollectionOfPrimitiveValues<string>(); },
        "detectionMethods": n => { analyzedEmail.detectionMethods = n.getCollectionOfPrimitiveValues<string>(); },
        "directionality": n => { analyzedEmail.directionality = n.getEnumValue<AntispamDirectionality>(AntispamDirectionalityObject); },
        "distributionList": n => { analyzedEmail.distributionList = n.getStringValue(); },
        "emailClusterId": n => { analyzedEmail.emailClusterId = n.getStringValue(); },
        "exchangeTransportRules": n => { analyzedEmail.exchangeTransportRules = n.getCollectionOfObjectValues<AnalyzedEmailExchangeTransportRuleInfo>(createAnalyzedEmailExchangeTransportRuleInfoFromDiscriminatorValue); },
        "internetMessageId": n => { analyzedEmail.internetMessageId = n.getStringValue(); },
        "language": n => { analyzedEmail.language = n.getStringValue(); },
        "latestDelivery": n => { analyzedEmail.latestDelivery = n.getObjectValue<AnalyzedEmailDeliveryDetail>(createAnalyzedEmailDeliveryDetailFromDiscriminatorValue); },
        "loggedDateTime": n => { analyzedEmail.loggedDateTime = n.getDateValue(); },
        "networkMessageId": n => { analyzedEmail.networkMessageId = n.getStringValue(); },
        "originalDelivery": n => { analyzedEmail.originalDelivery = n.getObjectValue<AnalyzedEmailDeliveryDetail>(createAnalyzedEmailDeliveryDetailFromDiscriminatorValue); },
        "overrideSources": n => { analyzedEmail.overrideSources = n.getCollectionOfPrimitiveValues<string>(); },
        "phishConfidenceLevel": n => { analyzedEmail.phishConfidenceLevel = n.getStringValue(); },
        "policy": n => { analyzedEmail.policy = n.getStringValue(); },
        "policyAction": n => { analyzedEmail.policyAction = n.getStringValue(); },
        "recipientEmailAddress": n => { analyzedEmail.recipientEmailAddress = n.getStringValue(); },
        "returnPath": n => { analyzedEmail.returnPath = n.getStringValue(); },
        "senderDetail": n => { analyzedEmail.senderDetail = n.getObjectValue<AnalyzedEmailSenderDetail>(createAnalyzedEmailSenderDetailFromDiscriminatorValue); },
        "sizeInBytes": n => { analyzedEmail.sizeInBytes = n.getNumberValue(); },
        "spamConfidenceLevel": n => { analyzedEmail.spamConfidenceLevel = n.getStringValue(); },
        "subject": n => { analyzedEmail.subject = n.getStringValue(); },
        "threatTypes": n => { analyzedEmail.threatTypes = n.getCollectionOfEnumValues<ThreatType>(ThreatTypeObject); },
        "urls": n => { analyzedEmail.urls = n.getCollectionOfObjectValues<AnalyzedEmailUrl>(createAnalyzedEmailUrlFromDiscriminatorValue); },
        "urlsCount": n => { analyzedEmail.urlsCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnalyzedEmailAttachment(analyzedEmailAttachment: Partial<AnalyzedEmailAttachment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { analyzedEmailAttachment.backingStoreEnabled = true; },
        "detonationDetails": n => { analyzedEmailAttachment.detonationDetails = n.getObjectValue<DetonationDetails>(createDetonationDetailsFromDiscriminatorValue); },
        "fileName": n => { analyzedEmailAttachment.fileName = n.getStringValue(); },
        "fileType": n => { analyzedEmailAttachment.fileType = n.getStringValue(); },
        "@odata.type": n => { analyzedEmailAttachment.odataType = n.getStringValue(); },
        "sha256": n => { analyzedEmailAttachment.sha256 = n.getStringValue(); },
        "threatName": n => { analyzedEmailAttachment.threatName = n.getStringValue(); },
        "threatType": n => { analyzedEmailAttachment.threatType = n.getEnumValue<ThreatType>(ThreatTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnalyzedEmailAuthenticationDetail(analyzedEmailAuthenticationDetail: Partial<AnalyzedEmailAuthenticationDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { analyzedEmailAuthenticationDetail.backingStoreEnabled = true; },
        "compositeAuthentication": n => { analyzedEmailAuthenticationDetail.compositeAuthentication = n.getStringValue(); },
        "dkim": n => { analyzedEmailAuthenticationDetail.dkim = n.getStringValue(); },
        "dmarc": n => { analyzedEmailAuthenticationDetail.dmarc = n.getStringValue(); },
        "@odata.type": n => { analyzedEmailAuthenticationDetail.odataType = n.getStringValue(); },
        "senderPolicyFramework": n => { analyzedEmailAuthenticationDetail.senderPolicyFramework = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnalyzedEmailCollectionResponse(analyzedEmailCollectionResponse: Partial<AnalyzedEmailCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(analyzedEmailCollectionResponse),
        "value": n => { analyzedEmailCollectionResponse.value = n.getCollectionOfObjectValues<AnalyzedEmail>(createAnalyzedEmailFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnalyzedEmailDeliveryDetail(analyzedEmailDeliveryDetail: Partial<AnalyzedEmailDeliveryDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "action": n => { analyzedEmailDeliveryDetail.action = n.getEnumValue<DeliveryAction>(DeliveryActionObject); },
        "backingStoreEnabled": n => { analyzedEmailDeliveryDetail.backingStoreEnabled = true; },
        "location": n => { analyzedEmailDeliveryDetail.location = n.getEnumValue<DeliveryLocation>(DeliveryLocationObject); },
        "@odata.type": n => { analyzedEmailDeliveryDetail.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnalyzedEmailExchangeTransportRuleInfo(analyzedEmailExchangeTransportRuleInfo: Partial<AnalyzedEmailExchangeTransportRuleInfo> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { analyzedEmailExchangeTransportRuleInfo.backingStoreEnabled = true; },
        "name": n => { analyzedEmailExchangeTransportRuleInfo.name = n.getStringValue(); },
        "@odata.type": n => { analyzedEmailExchangeTransportRuleInfo.odataType = n.getStringValue(); },
        "ruleId": n => { analyzedEmailExchangeTransportRuleInfo.ruleId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnalyzedEmailSenderDetail(analyzedEmailSenderDetail: Partial<AnalyzedEmailSenderDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { analyzedEmailSenderDetail.backingStoreEnabled = true; },
        "fromAddress": n => { analyzedEmailSenderDetail.fromAddress = n.getStringValue(); },
        "ipv4": n => { analyzedEmailSenderDetail.ipv4 = n.getStringValue(); },
        "mailFromAddress": n => { analyzedEmailSenderDetail.mailFromAddress = n.getStringValue(); },
        "@odata.type": n => { analyzedEmailSenderDetail.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnalyzedEmailUrl(analyzedEmailUrl: Partial<AnalyzedEmailUrl> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { analyzedEmailUrl.backingStoreEnabled = true; },
        "detectionMethod": n => { analyzedEmailUrl.detectionMethod = n.getStringValue(); },
        "detonationDetails": n => { analyzedEmailUrl.detonationDetails = n.getObjectValue<DetonationDetails>(createDetonationDetailsFromDiscriminatorValue); },
        "@odata.type": n => { analyzedEmailUrl.odataType = n.getStringValue(); },
        "threatType": n => { analyzedEmailUrl.threatType = n.getEnumValue<ThreatType>(ThreatTypeObject); },
        "url": n => { analyzedEmailUrl.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnalyzedMessageEvidence(analyzedMessageEvidence: Partial<AnalyzedMessageEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(analyzedMessageEvidence),
        "antiSpamDirection": n => { analyzedMessageEvidence.antiSpamDirection = n.getStringValue(); },
        "attachmentsCount": n => { analyzedMessageEvidence.attachmentsCount = n.getNumberValue(); },
        "deliveryAction": n => { analyzedMessageEvidence.deliveryAction = n.getStringValue(); },
        "deliveryLocation": n => { analyzedMessageEvidence.deliveryLocation = n.getStringValue(); },
        "internetMessageId": n => { analyzedMessageEvidence.internetMessageId = n.getStringValue(); },
        "language": n => { analyzedMessageEvidence.language = n.getStringValue(); },
        "networkMessageId": n => { analyzedMessageEvidence.networkMessageId = n.getStringValue(); },
        "p1Sender": n => { analyzedMessageEvidence.p1Sender = n.getObjectValue<EmailSender>(createEmailSenderFromDiscriminatorValue); },
        "p2Sender": n => { analyzedMessageEvidence.p2Sender = n.getObjectValue<EmailSender>(createEmailSenderFromDiscriminatorValue); },
        "receivedDateTime": n => { analyzedMessageEvidence.receivedDateTime = n.getDateValue(); },
        "recipientEmailAddress": n => { analyzedMessageEvidence.recipientEmailAddress = n.getStringValue(); },
        "senderIp": n => { analyzedMessageEvidence.senderIp = n.getStringValue(); },
        "subject": n => { analyzedMessageEvidence.subject = n.getStringValue(); },
        "threatDetectionMethods": n => { analyzedMessageEvidence.threatDetectionMethods = n.getCollectionOfPrimitiveValues<string>(); },
        "threats": n => { analyzedMessageEvidence.threats = n.getCollectionOfPrimitiveValues<string>(); },
        "urlCount": n => { analyzedMessageEvidence.urlCount = n.getNumberValue(); },
        "urls": n => { analyzedMessageEvidence.urls = n.getCollectionOfPrimitiveValues<string>(); },
        "urn": n => { analyzedMessageEvidence.urn = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoApplyLabelAction(applyLabelAction: Partial<ApplyLabelAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(applyLabelAction),
        "actions": n => { applyLabelAction.actions = n.getCollectionOfObjectValues<InformationProtectionAction>(createInformationProtectionActionFromDiscriminatorValue); },
        "actionSource": n => { applyLabelAction.actionSource = n.getEnumValue<ActionSource>(ActionSourceObject); },
        "responsibleSensitiveTypeIds": n => { applyLabelAction.responsibleSensitiveTypeIds = n.getCollectionOfPrimitiveValues<string>(); },
        "sensitivityLabelId": n => { applyLabelAction.sensitivityLabelId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoArticle(article: Partial<Article> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(article),
        "body": n => { article.body = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "createdDateTime": n => { article.createdDateTime = n.getDateValue(); },
        "imageUrl": n => { article.imageUrl = n.getStringValue(); },
        "indicators": n => { article.indicators = n.getCollectionOfObjectValues<ArticleIndicator>(createArticleIndicatorFromDiscriminatorValue); },
        "isFeatured": n => { article.isFeatured = n.getBooleanValue(); },
        "lastUpdatedDateTime": n => { article.lastUpdatedDateTime = n.getDateValue(); },
        "summary": n => { article.summary = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "tags": n => { article.tags = n.getCollectionOfPrimitiveValues<string>(); },
        "title": n => { article.title = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoArticleCollectionResponse(articleCollectionResponse: Partial<ArticleCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(articleCollectionResponse),
        "value": n => { articleCollectionResponse.value = n.getCollectionOfObjectValues<Article>(createArticleFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoArticleIndicator(articleIndicator: Partial<ArticleIndicator> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIndicator(articleIndicator),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoArticleIndicatorCollectionResponse(articleIndicatorCollectionResponse: Partial<ArticleIndicatorCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(articleIndicatorCollectionResponse),
        "value": n => { articleIndicatorCollectionResponse.value = n.getCollectionOfObjectValues<ArticleIndicator>(createArticleIndicatorFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoArtifact(artifact: Partial<Artifact> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(artifact),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAttackSimulationInfo(attackSimulationInfo: Partial<AttackSimulationInfo> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "attackSimDateTime": n => { attackSimulationInfo.attackSimDateTime = n.getDateValue(); },
        "attackSimDurationTime": n => { attackSimulationInfo.attackSimDurationTime = n.getDurationValue(); },
        "attackSimId": n => { attackSimulationInfo.attackSimId = n.getGuidValue(); },
        "attackSimUserId": n => { attackSimulationInfo.attackSimUserId = n.getStringValue(); },
        "backingStoreEnabled": n => { attackSimulationInfo.backingStoreEnabled = true; },
        "@odata.type": n => { attackSimulationInfo.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAuditCoreRoot(auditCoreRoot: Partial<AuditCoreRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(auditCoreRoot),
        "queries": n => { auditCoreRoot.queries = n.getCollectionOfObjectValues<AuditLogQuery>(createAuditLogQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAuditData(auditData: Partial<AuditData> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { auditData.backingStoreEnabled = true; },
        "@odata.type": n => { auditData.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAuditLogQuery(auditLogQuery: Partial<AuditLogQuery> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(auditLogQuery),
        "administrativeUnitIdFilters": n => { auditLogQuery.administrativeUnitIdFilters = n.getCollectionOfPrimitiveValues<string>(); },
        "displayName": n => { auditLogQuery.displayName = n.getStringValue(); },
        "filterEndDateTime": n => { auditLogQuery.filterEndDateTime = n.getDateValue(); },
        "filterStartDateTime": n => { auditLogQuery.filterStartDateTime = n.getDateValue(); },
        "ipAddressFilters": n => { auditLogQuery.ipAddressFilters = n.getCollectionOfPrimitiveValues<string>(); },
        "keywordFilter": n => { auditLogQuery.keywordFilter = n.getStringValue(); },
        "objectIdFilters": n => { auditLogQuery.objectIdFilters = n.getCollectionOfPrimitiveValues<string>(); },
        "operationFilters": n => { auditLogQuery.operationFilters = n.getCollectionOfPrimitiveValues<string>(); },
        "records": n => { auditLogQuery.records = n.getCollectionOfObjectValues<AuditLogRecord>(createAuditLogRecordFromDiscriminatorValue); },
        "recordTypeFilters": n => { auditLogQuery.recordTypeFilters = n.getCollectionOfEnumValues<AuditLogRecordType>(AuditLogRecordTypeObject); },
        "serviceFilters": n => { auditLogQuery.serviceFilters = n.getCollectionOfPrimitiveValues<string>(); },
        "status": n => { auditLogQuery.status = n.getEnumValue<AuditLogQueryStatus>(AuditLogQueryStatusObject); },
        "userPrincipalNameFilters": n => { auditLogQuery.userPrincipalNameFilters = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAuditLogQueryCollectionResponse(auditLogQueryCollectionResponse: Partial<AuditLogQueryCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(auditLogQueryCollectionResponse),
        "value": n => { auditLogQueryCollectionResponse.value = n.getCollectionOfObjectValues<AuditLogQuery>(createAuditLogQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAuditLogRecord(auditLogRecord: Partial<AuditLogRecord> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(auditLogRecord),
        "administrativeUnits": n => { auditLogRecord.administrativeUnits = n.getCollectionOfPrimitiveValues<string>(); },
        "auditData": n => { auditLogRecord.auditData = n.getObjectValue<AuditData>(createAuditDataFromDiscriminatorValue); },
        "auditLogRecordType": n => { auditLogRecord.auditLogRecordType = n.getEnumValue<AuditLogRecordType>(AuditLogRecordTypeObject); },
        "clientIp": n => { auditLogRecord.clientIp = n.getStringValue(); },
        "createdDateTime": n => { auditLogRecord.createdDateTime = n.getDateValue(); },
        "objectId": n => { auditLogRecord.objectId = n.getStringValue(); },
        "operation": n => { auditLogRecord.operation = n.getStringValue(); },
        "organizationId": n => { auditLogRecord.organizationId = n.getStringValue(); },
        "service": n => { auditLogRecord.service = n.getStringValue(); },
        "userId": n => { auditLogRecord.userId = n.getStringValue(); },
        "userPrincipalName": n => { auditLogRecord.userPrincipalName = n.getStringValue(); },
        "userType": n => { auditLogRecord.userType = n.getEnumValue<AuditLogUserType>(AuditLogUserTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAuditLogRecordCollectionResponse(auditLogRecordCollectionResponse: Partial<AuditLogRecordCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(auditLogRecordCollectionResponse),
        "value": n => { auditLogRecordCollectionResponse.value = n.getCollectionOfObjectValues<AuditLogRecord>(createAuditLogRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAuthorityTemplate(authorityTemplate: Partial<AuthorityTemplate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorTemplate(authorityTemplate),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAuthorityTemplateCollectionResponse(authorityTemplateCollectionResponse: Partial<AuthorityTemplateCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(authorityTemplateCollectionResponse),
        "value": n => { authorityTemplateCollectionResponse.value = n.getCollectionOfObjectValues<AuthorityTemplate>(createAuthorityTemplateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAutonomousSystem(autonomousSystem: Partial<AutonomousSystem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { autonomousSystem.backingStoreEnabled = true; },
        "name": n => { autonomousSystem.name = n.getStringValue(); },
        "number": n => { autonomousSystem.number = n.getNumberValue(); },
        "@odata.type": n => { autonomousSystem.odataType = n.getStringValue(); },
        "organization": n => { autonomousSystem.organization = n.getStringValue(); },
        "value": n => { autonomousSystem.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAzureResourceEvidence(azureResourceEvidence: Partial<AzureResourceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(azureResourceEvidence),
        "resourceId": n => { azureResourceEvidence.resourceId = n.getStringValue(); },
        "resourceName": n => { azureResourceEvidence.resourceName = n.getStringValue(); },
        "resourceType": n => { azureResourceEvidence.resourceType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoBlobContainerEvidence(blobContainerEvidence: Partial<BlobContainerEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(blobContainerEvidence),
        "name": n => { blobContainerEvidence.name = n.getStringValue(); },
        "storageResource": n => { blobContainerEvidence.storageResource = n.getObjectValue<AzureResourceEvidence>(createAzureResourceEvidenceFromDiscriminatorValue); },
        "url": n => { blobContainerEvidence.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoBlobEvidence(blobEvidence: Partial<BlobEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(blobEvidence),
        "blobContainer": n => { blobEvidence.blobContainer = n.getObjectValue<BlobContainerEvidence>(createBlobContainerEvidenceFromDiscriminatorValue); },
        "etag": n => { blobEvidence.etag = n.getStringValue(); },
        "fileHashes": n => { blobEvidence.fileHashes = n.getCollectionOfObjectValues<FileHash>(createFileHashFromDiscriminatorValue); },
        "name": n => { blobEvidence.name = n.getStringValue(); },
        "url": n => { blobEvidence.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoBlockFileResponseAction(blockFileResponseAction: Partial<BlockFileResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(blockFileResponseAction),
        "deviceGroupNames": n => { blockFileResponseAction.deviceGroupNames = n.getCollectionOfPrimitiveValues<string>(); },
        "identifier": n => { blockFileResponseAction.identifier = n.getCollectionOfEnumValues<FileEntityIdentifier>(FileEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCaseEscaped(caseEscaped: Partial<CaseEscaped> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(caseEscaped),
        "createdDateTime": n => { caseEscaped.createdDateTime = n.getDateValue(); },
        "description": n => { caseEscaped.description = n.getStringValue(); },
        "displayName": n => { caseEscaped.displayName = n.getStringValue(); },
        "lastModifiedBy": n => { caseEscaped.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { caseEscaped.lastModifiedDateTime = n.getDateValue(); },
        "status": n => { caseEscaped.status = n.getEnumValue<CaseStatus>(CaseStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCaseOperation(caseOperation: Partial<CaseOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(caseOperation),
        "action": n => { caseOperation.action = n.getEnumValue<CaseAction>(CaseActionObject); },
        "completedDateTime": n => { caseOperation.completedDateTime = n.getDateValue(); },
        "createdBy": n => { caseOperation.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { caseOperation.createdDateTime = n.getDateValue(); },
        "percentProgress": n => { caseOperation.percentProgress = n.getNumberValue(); },
        "resultInfo": n => { caseOperation.resultInfo = n.getObjectValue<ResultInfo>(createResultInfoFromDiscriminatorValue); },
        "status": n => { caseOperation.status = n.getEnumValue<CaseOperationStatus>(CaseOperationStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCaseOperationCollectionResponse(caseOperationCollectionResponse: Partial<CaseOperationCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(caseOperationCollectionResponse),
        "value": n => { caseOperationCollectionResponse.value = n.getCollectionOfObjectValues<CaseOperation>(createCaseOperationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCasesRoot(casesRoot: Partial<CasesRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(casesRoot),
        "ediscoveryCases": n => { casesRoot.ediscoveryCases = n.getCollectionOfObjectValues<EdiscoveryCase>(createEdiscoveryCaseFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCategoryTemplate(categoryTemplate: Partial<CategoryTemplate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorTemplate(categoryTemplate),
        "subcategories": n => { categoryTemplate.subcategories = n.getCollectionOfObjectValues<SubcategoryTemplate>(createSubcategoryTemplateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCategoryTemplateCollectionResponse(categoryTemplateCollectionResponse: Partial<CategoryTemplateCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(categoryTemplateCollectionResponse),
        "value": n => { categoryTemplateCollectionResponse.value = n.getCollectionOfObjectValues<CategoryTemplate>(createCategoryTemplateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCitationTemplate(citationTemplate: Partial<CitationTemplate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorTemplate(citationTemplate),
        "citationJurisdiction": n => { citationTemplate.citationJurisdiction = n.getStringValue(); },
        "citationUrl": n => { citationTemplate.citationUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCitationTemplateCollectionResponse(citationTemplateCollectionResponse: Partial<CitationTemplateCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(citationTemplateCollectionResponse),
        "value": n => { citationTemplateCollectionResponse.value = n.getCollectionOfObjectValues<CitationTemplate>(createCitationTemplateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoClassificationResult(classificationResult: Partial<ClassificationResult> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { classificationResult.backingStoreEnabled = true; },
        "confidenceLevel": n => { classificationResult.confidenceLevel = n.getNumberValue(); },
        "count": n => { classificationResult.count = n.getNumberValue(); },
        "@odata.type": n => { classificationResult.odataType = n.getStringValue(); },
        "sensitiveTypeId": n => { classificationResult.sensitiveTypeId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCloudApplicationEvidence(cloudApplicationEvidence: Partial<CloudApplicationEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(cloudApplicationEvidence),
        "appId": n => { cloudApplicationEvidence.appId = n.getNumberValue(); },
        "displayName": n => { cloudApplicationEvidence.displayName = n.getStringValue(); },
        "instanceId": n => { cloudApplicationEvidence.instanceId = n.getNumberValue(); },
        "instanceName": n => { cloudApplicationEvidence.instanceName = n.getStringValue(); },
        "saasAppId": n => { cloudApplicationEvidence.saasAppId = n.getNumberValue(); },
        "stream": n => { cloudApplicationEvidence.stream = n.getObjectValue<Stream>(createStreamFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCollaborationRoot(collaborationRoot: Partial<CollaborationRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(collaborationRoot),
        "analyzedEmails": n => { collaborationRoot.analyzedEmails = n.getCollectionOfObjectValues<AnalyzedEmail>(createAnalyzedEmailFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCollectInvestigationPackageResponseAction(collectInvestigationPackageResponseAction: Partial<CollectInvestigationPackageResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(collectInvestigationPackageResponseAction),
        "identifier": n => { collectInvestigationPackageResponseAction.identifier = n.getCollectionOfEnumValues<DeviceIdEntityIdentifier>(DeviceIdEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContainerEvidence(containerEvidence: Partial<ContainerEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(containerEvidence),
        "args": n => { containerEvidence.args = n.getCollectionOfPrimitiveValues<string>(); },
        "command": n => { containerEvidence.command = n.getCollectionOfPrimitiveValues<string>(); },
        "containerId": n => { containerEvidence.containerId = n.getStringValue(); },
        "image": n => { containerEvidence.image = n.getObjectValue<ContainerImageEvidence>(createContainerImageEvidenceFromDiscriminatorValue); },
        "isPrivileged": n => { containerEvidence.isPrivileged = n.getBooleanValue(); },
        "name": n => { containerEvidence.name = n.getStringValue(); },
        "pod": n => { containerEvidence.pod = n.getObjectValue<KubernetesPodEvidence>(createKubernetesPodEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContainerImageEvidence(containerImageEvidence: Partial<ContainerImageEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(containerImageEvidence),
        "digestImage": n => { containerImageEvidence.digestImage = n.getObjectValue<ContainerImageEvidence>(createContainerImageEvidenceFromDiscriminatorValue); },
        "imageId": n => { containerImageEvidence.imageId = n.getStringValue(); },
        "registry": n => { containerImageEvidence.registry = n.getObjectValue<ContainerRegistryEvidence>(createContainerRegistryEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContainerRegistryEvidence(containerRegistryEvidence: Partial<ContainerRegistryEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(containerRegistryEvidence),
        "registry": n => { containerRegistryEvidence.registry = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContentInfo(contentInfo: Partial<ContentInfo> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { contentInfo.backingStoreEnabled = true; },
        "contentFormat": n => { contentInfo.contentFormat = n.getStringValue(); },
        "identifier": n => { contentInfo.identifier = n.getStringValue(); },
        "metadata": n => { contentInfo.metadata = n.getCollectionOfObjectValues<KeyValuePair>(createKeyValuePairFromDiscriminatorValue); },
        "@odata.type": n => { contentInfo.odataType = n.getStringValue(); },
        "state": n => { contentInfo.state = n.getEnumValue<ContentState>(ContentStateObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContentLabel(contentLabel: Partial<ContentLabel> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "assignmentMethod": n => { contentLabel.assignmentMethod = n.getEnumValue<AssignmentMethod>(AssignmentMethodObject); },
        "backingStoreEnabled": n => { contentLabel.backingStoreEnabled = true; },
        "createdDateTime": n => { contentLabel.createdDateTime = n.getDateValue(); },
        "@odata.type": n => { contentLabel.odataType = n.getStringValue(); },
        "sensitivityLabelId": n => { contentLabel.sensitivityLabelId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCustomAction(customAction: Partial<CustomAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(customAction),
        "name": n => { customAction.name = n.getStringValue(); },
        "properties": n => { customAction.properties = n.getCollectionOfObjectValues<KeyValuePair>(createKeyValuePairFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCvssSummary(cvssSummary: Partial<CvssSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { cvssSummary.backingStoreEnabled = true; },
        "@odata.type": n => { cvssSummary.odataType = n.getStringValue(); },
        "score": n => { cvssSummary.score = n.getNumberValue(); },
        "severity": n => { cvssSummary.severity = n.getEnumValue<VulnerabilitySeverity>(VulnerabilitySeverityObject); },
        "vectorString": n => { cvssSummary.vectorString = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDataSet(dataSet: Partial<DataSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(dataSet),
        "createdBy": n => { dataSet.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { dataSet.createdDateTime = n.getDateValue(); },
        "displayName": n => { dataSet.displayName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDataSource(dataSource: Partial<DataSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(dataSource),
        "createdBy": n => { dataSource.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { dataSource.createdDateTime = n.getDateValue(); },
        "displayName": n => { dataSource.displayName = n.getStringValue(); },
        "holdStatus": n => { dataSource.holdStatus = n.getEnumValue<DataSourceHoldStatus>(DataSourceHoldStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDataSourceCollectionResponse(dataSourceCollectionResponse: Partial<DataSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(dataSourceCollectionResponse),
        "value": n => { dataSourceCollectionResponse.value = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDataSourceContainer(dataSourceContainer: Partial<DataSourceContainer> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(dataSourceContainer),
        "createdDateTime": n => { dataSourceContainer.createdDateTime = n.getDateValue(); },
        "displayName": n => { dataSourceContainer.displayName = n.getStringValue(); },
        "holdStatus": n => { dataSourceContainer.holdStatus = n.getEnumValue<DataSourceHoldStatus>(DataSourceHoldStatusObject); },
        "lastModifiedDateTime": n => { dataSourceContainer.lastModifiedDateTime = n.getDateValue(); },
        "releasedDateTime": n => { dataSourceContainer.releasedDateTime = n.getDateValue(); },
        "status": n => { dataSourceContainer.status = n.getEnumValue<DataSourceContainerStatus>(DataSourceContainerStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDefaultAuditData(defaultAuditData: Partial<DefaultAuditData> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAuditData(defaultAuditData),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDepartmentTemplate(departmentTemplate: Partial<DepartmentTemplate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorTemplate(departmentTemplate),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDepartmentTemplateCollectionResponse(departmentTemplateCollectionResponse: Partial<DepartmentTemplateCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(departmentTemplateCollectionResponse),
        "value": n => { departmentTemplateCollectionResponse.value = n.getCollectionOfObjectValues<DepartmentTemplate>(createDepartmentTemplateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeploymentAccessKeyType(deploymentAccessKeyType: Partial<DeploymentAccessKeyType> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { deploymentAccessKeyType.backingStoreEnabled = true; },
        "deploymentAccessKey": n => { deploymentAccessKeyType.deploymentAccessKey = n.getStringValue(); },
        "@odata.type": n => { deploymentAccessKeyType.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDetectionAction(detectionAction: Partial<DetectionAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "alertTemplate": n => { detectionAction.alertTemplate = n.getObjectValue<AlertTemplate>(createAlertTemplateFromDiscriminatorValue); },
        "backingStoreEnabled": n => { detectionAction.backingStoreEnabled = true; },
        "@odata.type": n => { detectionAction.odataType = n.getStringValue(); },
        "organizationalScope": n => { detectionAction.organizationalScope = n.getObjectValue<OrganizationalScope>(createOrganizationalScopeFromDiscriminatorValue); },
        "responseActions": n => { detectionAction.responseActions = n.getCollectionOfObjectValues<ResponseAction>(createResponseActionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDetectionRule(detectionRule: Partial<DetectionRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoProtectionRule(detectionRule),
        "detectionAction": n => { detectionRule.detectionAction = n.getObjectValue<DetectionAction>(createDetectionActionFromDiscriminatorValue); },
        "detectorId": n => { detectionRule.detectorId = n.getStringValue(); },
        "lastRunDetails": n => { detectionRule.lastRunDetails = n.getObjectValue<RunDetails>(createRunDetailsFromDiscriminatorValue); },
        "queryCondition": n => { detectionRule.queryCondition = n.getObjectValue<QueryCondition>(createQueryConditionFromDiscriminatorValue); },
        "schedule": n => { detectionRule.schedule = n.getObjectValue<RuleSchedule>(createRuleScheduleFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDetectionRuleCollectionResponse(detectionRuleCollectionResponse: Partial<DetectionRuleCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(detectionRuleCollectionResponse),
        "value": n => { detectionRuleCollectionResponse.value = n.getCollectionOfObjectValues<DetectionRule>(createDetectionRuleFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDetonationChain(detonationChain: Partial<DetonationChain> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { detonationChain.backingStoreEnabled = true; },
        "childNodes": n => { detonationChain.childNodes = n.getCollectionOfObjectValues<DetonationChain>(createDetonationChainFromDiscriminatorValue); },
        "@odata.type": n => { detonationChain.odataType = n.getStringValue(); },
        "value": n => { detonationChain.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDetonationDetails(detonationDetails: Partial<DetonationDetails> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "analysisDateTime": n => { detonationDetails.analysisDateTime = n.getDateValue(); },
        "backingStoreEnabled": n => { detonationDetails.backingStoreEnabled = true; },
        "detonationChain": n => { detonationDetails.detonationChain = n.getObjectValue<DetonationChain>(createDetonationChainFromDiscriminatorValue); },
        "detonationObservables": n => { detonationDetails.detonationObservables = n.getObjectValue<DetonationObservables>(createDetonationObservablesFromDiscriminatorValue); },
        "detonationVerdict": n => { detonationDetails.detonationVerdict = n.getStringValue(); },
        "detonationVerdictReason": n => { detonationDetails.detonationVerdictReason = n.getStringValue(); },
        "@odata.type": n => { detonationDetails.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDetonationObservables(detonationObservables: Partial<DetonationObservables> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { detonationObservables.backingStoreEnabled = true; },
        "contactedIps": n => { detonationObservables.contactedIps = n.getCollectionOfPrimitiveValues<string>(); },
        "contactedUrls": n => { detonationObservables.contactedUrls = n.getCollectionOfPrimitiveValues<string>(); },
        "droppedfiles": n => { detonationObservables.droppedfiles = n.getCollectionOfPrimitiveValues<string>(); },
        "@odata.type": n => { detonationObservables.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeviceEvidence(deviceEvidence: Partial<DeviceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(deviceEvidence),
        "azureAdDeviceId": n => { deviceEvidence.azureAdDeviceId = n.getStringValue(); },
        "defenderAvStatus": n => { deviceEvidence.defenderAvStatus = n.getEnumValue<DefenderAvStatus>(DefenderAvStatusObject); },
        "deviceDnsName": n => { deviceEvidence.deviceDnsName = n.getStringValue(); },
        "firstSeenDateTime": n => { deviceEvidence.firstSeenDateTime = n.getDateValue(); },
        "healthStatus": n => { deviceEvidence.healthStatus = n.getEnumValue<DeviceHealthStatus>(DeviceHealthStatusObject); },
        "ipInterfaces": n => { deviceEvidence.ipInterfaces = n.getCollectionOfPrimitiveValues<string>(); },
        "lastExternalIpAddress": n => { deviceEvidence.lastExternalIpAddress = n.getStringValue(); },
        "lastIpAddress": n => { deviceEvidence.lastIpAddress = n.getStringValue(); },
        "loggedOnUsers": n => { deviceEvidence.loggedOnUsers = n.getCollectionOfObjectValues<LoggedOnUser>(createLoggedOnUserFromDiscriminatorValue); },
        "mdeDeviceId": n => { deviceEvidence.mdeDeviceId = n.getStringValue(); },
        "onboardingStatus": n => { deviceEvidence.onboardingStatus = n.getEnumValue<OnboardingStatus>(OnboardingStatusObject); },
        "osBuild": n => { deviceEvidence.osBuild = n.getNumberValue(); },
        "osPlatform": n => { deviceEvidence.osPlatform = n.getStringValue(); },
        "rbacGroupId": n => { deviceEvidence.rbacGroupId = n.getNumberValue(); },
        "rbacGroupName": n => { deviceEvidence.rbacGroupName = n.getStringValue(); },
        "riskScore": n => { deviceEvidence.riskScore = n.getEnumValue<DeviceRiskScore>(DeviceRiskScoreObject); },
        "version": n => { deviceEvidence.version = n.getStringValue(); },
        "vmMetadata": n => { deviceEvidence.vmMetadata = n.getObjectValue<VmMetadata>(createVmMetadataFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDictionary(dictionary: Partial<Dictionary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { dictionary.backingStoreEnabled = true; },
        "@odata.type": n => { dictionary.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDisableUserResponseAction(disableUserResponseAction: Partial<DisableUserResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(disableUserResponseAction),
        "identifier": n => { disableUserResponseAction.identifier = n.getCollectionOfEnumValues<DisableUserEntityIdentifier>(DisableUserEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDispositionReviewStage(dispositionReviewStage: Partial<DispositionReviewStage> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(dispositionReviewStage),
        "name": n => { dispositionReviewStage.name = n.getStringValue(); },
        "reviewersEmailAddresses": n => { dispositionReviewStage.reviewersEmailAddresses = n.getCollectionOfPrimitiveValues<string>(); },
        "stageNumber": n => { dispositionReviewStage.stageNumber = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDispositionReviewStageCollectionResponse(dispositionReviewStageCollectionResponse: Partial<DispositionReviewStageCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(dispositionReviewStageCollectionResponse),
        "value": n => { dispositionReviewStageCollectionResponse.value = n.getCollectionOfObjectValues<DispositionReviewStage>(createDispositionReviewStageFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDnsEvidence(dnsEvidence: Partial<DnsEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(dnsEvidence),
        "dnsServerIp": n => { dnsEvidence.dnsServerIp = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "domainName": n => { dnsEvidence.domainName = n.getStringValue(); },
        "hostIpAddress": n => { dnsEvidence.hostIpAddress = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "ipAddresses": n => { dnsEvidence.ipAddresses = n.getCollectionOfObjectValues<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDowngradeJustification(downgradeJustification: Partial<DowngradeJustification> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { downgradeJustification.backingStoreEnabled = true; },
        "isDowngradeJustified": n => { downgradeJustification.isDowngradeJustified = n.getBooleanValue(); },
        "justificationMessage": n => { downgradeJustification.justificationMessage = n.getStringValue(); },
        "@odata.type": n => { downgradeJustification.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryAddToReviewSetOperation(ediscoveryAddToReviewSetOperation: Partial<EdiscoveryAddToReviewSetOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryAddToReviewSetOperation),
        "reviewSet": n => { ediscoveryAddToReviewSetOperation.reviewSet = n.getObjectValue<EdiscoveryReviewSet>(createEdiscoveryReviewSetFromDiscriminatorValue); },
        "search": n => { ediscoveryAddToReviewSetOperation.search = n.getObjectValue<EdiscoverySearch>(createEdiscoverySearchFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryCase(ediscoveryCase: Partial<EdiscoveryCase> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseEscaped(ediscoveryCase),
        "closedBy": n => { ediscoveryCase.closedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "closedDateTime": n => { ediscoveryCase.closedDateTime = n.getDateValue(); },
        "custodians": n => { ediscoveryCase.custodians = n.getCollectionOfObjectValues<EdiscoveryCustodian>(createEdiscoveryCustodianFromDiscriminatorValue); },
        "externalId": n => { ediscoveryCase.externalId = n.getStringValue(); },
        "legalHolds": n => { ediscoveryCase.legalHolds = n.getCollectionOfObjectValues<EdiscoveryHoldPolicy>(createEdiscoveryHoldPolicyFromDiscriminatorValue); },
        "noncustodialDataSources": n => { ediscoveryCase.noncustodialDataSources = n.getCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>(createEdiscoveryNoncustodialDataSourceFromDiscriminatorValue); },
        "operations": n => { ediscoveryCase.operations = n.getCollectionOfObjectValues<CaseOperation>(createCaseOperationFromDiscriminatorValue); },
        "reviewSets": n => { ediscoveryCase.reviewSets = n.getCollectionOfObjectValues<EdiscoveryReviewSet>(createEdiscoveryReviewSetFromDiscriminatorValue); },
        "searches": n => { ediscoveryCase.searches = n.getCollectionOfObjectValues<EdiscoverySearch>(createEdiscoverySearchFromDiscriminatorValue); },
        "settings": n => { ediscoveryCase.settings = n.getObjectValue<EdiscoveryCaseSettings>(createEdiscoveryCaseSettingsFromDiscriminatorValue); },
        "tags": n => { ediscoveryCase.tags = n.getCollectionOfObjectValues<EdiscoveryReviewTag>(createEdiscoveryReviewTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryCaseCollectionResponse(ediscoveryCaseCollectionResponse: Partial<EdiscoveryCaseCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryCaseCollectionResponse),
        "value": n => { ediscoveryCaseCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryCase>(createEdiscoveryCaseFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryCaseSettings(ediscoveryCaseSettings: Partial<EdiscoveryCaseSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(ediscoveryCaseSettings),
        "ocr": n => { ediscoveryCaseSettings.ocr = n.getObjectValue<OcrSettings>(createOcrSettingsFromDiscriminatorValue); },
        "redundancyDetection": n => { ediscoveryCaseSettings.redundancyDetection = n.getObjectValue<RedundancyDetectionSettings>(createRedundancyDetectionSettingsFromDiscriminatorValue); },
        "topicModeling": n => { ediscoveryCaseSettings.topicModeling = n.getObjectValue<TopicModelingSettings>(createTopicModelingSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryCustodian(ediscoveryCustodian: Partial<EdiscoveryCustodian> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSourceContainer(ediscoveryCustodian),
        "acknowledgedDateTime": n => { ediscoveryCustodian.acknowledgedDateTime = n.getDateValue(); },
        "email": n => { ediscoveryCustodian.email = n.getStringValue(); },
        "lastIndexOperation": n => { ediscoveryCustodian.lastIndexOperation = n.getObjectValue<EdiscoveryIndexOperation>(createEdiscoveryIndexOperationFromDiscriminatorValue); },
        "siteSources": n => { ediscoveryCustodian.siteSources = n.getCollectionOfObjectValues<SiteSource>(createSiteSourceFromDiscriminatorValue); },
        "unifiedGroupSources": n => { ediscoveryCustodian.unifiedGroupSources = n.getCollectionOfObjectValues<UnifiedGroupSource>(createUnifiedGroupSourceFromDiscriminatorValue); },
        "userSources": n => { ediscoveryCustodian.userSources = n.getCollectionOfObjectValues<UserSource>(createUserSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryCustodianCollectionResponse(ediscoveryCustodianCollectionResponse: Partial<EdiscoveryCustodianCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryCustodianCollectionResponse),
        "value": n => { ediscoveryCustodianCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryCustodian>(createEdiscoveryCustodianFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryEstimateOperation(ediscoveryEstimateOperation: Partial<EdiscoveryEstimateOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryEstimateOperation),
        "indexedItemCount": n => { ediscoveryEstimateOperation.indexedItemCount = n.getNumberValue(); },
        "indexedItemsSize": n => { ediscoveryEstimateOperation.indexedItemsSize = n.getNumberValue(); },
        "mailboxCount": n => { ediscoveryEstimateOperation.mailboxCount = n.getNumberValue(); },
        "search": n => { ediscoveryEstimateOperation.search = n.getObjectValue<EdiscoverySearch>(createEdiscoverySearchFromDiscriminatorValue); },
        "siteCount": n => { ediscoveryEstimateOperation.siteCount = n.getNumberValue(); },
        "unindexedItemCount": n => { ediscoveryEstimateOperation.unindexedItemCount = n.getNumberValue(); },
        "unindexedItemsSize": n => { ediscoveryEstimateOperation.unindexedItemsSize = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryExportOperation(ediscoveryExportOperation: Partial<EdiscoveryExportOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryExportOperation),
        "azureBlobContainer": n => { ediscoveryExportOperation.azureBlobContainer = n.getStringValue(); },
        "azureBlobToken": n => { ediscoveryExportOperation.azureBlobToken = n.getStringValue(); },
        "description": n => { ediscoveryExportOperation.description = n.getStringValue(); },
        "exportFileMetadata": n => { ediscoveryExportOperation.exportFileMetadata = n.getCollectionOfObjectValues<ExportFileMetadata>(createExportFileMetadataFromDiscriminatorValue); },
        "exportOptions": n => { ediscoveryExportOperation.exportOptions = n.getCollectionOfEnumValues<ExportOptions>(ExportOptionsObject); },
        "exportStructure": n => { ediscoveryExportOperation.exportStructure = n.getEnumValue<ExportFileStructure>(ExportFileStructureObject); },
        "outputFolderId": n => { ediscoveryExportOperation.outputFolderId = n.getStringValue(); },
        "outputName": n => { ediscoveryExportOperation.outputName = n.getStringValue(); },
        "reviewSet": n => { ediscoveryExportOperation.reviewSet = n.getObjectValue<EdiscoveryReviewSet>(createEdiscoveryReviewSetFromDiscriminatorValue); },
        "reviewSetQuery": n => { ediscoveryExportOperation.reviewSetQuery = n.getObjectValue<EdiscoveryReviewSetQuery>(createEdiscoveryReviewSetQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryFile(ediscoveryFile: Partial<EdiscoveryFile> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFile(ediscoveryFile),
        "custodian": n => { ediscoveryFile.custodian = n.getObjectValue<EdiscoveryCustodian>(createEdiscoveryCustodianFromDiscriminatorValue); },
        "tags": n => { ediscoveryFile.tags = n.getCollectionOfObjectValues<EdiscoveryReviewTag>(createEdiscoveryReviewTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryFileCollectionResponse(ediscoveryFileCollectionResponse: Partial<EdiscoveryFileCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryFileCollectionResponse),
        "value": n => { ediscoveryFileCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryFile>(createEdiscoveryFileFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryHoldOperation(ediscoveryHoldOperation: Partial<EdiscoveryHoldOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryHoldOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryHoldPolicy(ediscoveryHoldPolicy: Partial<EdiscoveryHoldPolicy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicyBase(ediscoveryHoldPolicy),
        "contentQuery": n => { ediscoveryHoldPolicy.contentQuery = n.getStringValue(); },
        "errors": n => { ediscoveryHoldPolicy.errors = n.getCollectionOfPrimitiveValues<string>(); },
        "isEnabled": n => { ediscoveryHoldPolicy.isEnabled = n.getBooleanValue(); },
        "siteSources": n => { ediscoveryHoldPolicy.siteSources = n.getCollectionOfObjectValues<SiteSource>(createSiteSourceFromDiscriminatorValue); },
        "userSources": n => { ediscoveryHoldPolicy.userSources = n.getCollectionOfObjectValues<UserSource>(createUserSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryHoldPolicyCollectionResponse(ediscoveryHoldPolicyCollectionResponse: Partial<EdiscoveryHoldPolicyCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryHoldPolicyCollectionResponse),
        "value": n => { ediscoveryHoldPolicyCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryHoldPolicy>(createEdiscoveryHoldPolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryIndexOperation(ediscoveryIndexOperation: Partial<EdiscoveryIndexOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryIndexOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryNoncustodialDataSource(ediscoveryNoncustodialDataSource: Partial<EdiscoveryNoncustodialDataSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSourceContainer(ediscoveryNoncustodialDataSource),
        "dataSource": n => { ediscoveryNoncustodialDataSource.dataSource = n.getObjectValue<DataSource>(createDataSourceFromDiscriminatorValue); },
        "lastIndexOperation": n => { ediscoveryNoncustodialDataSource.lastIndexOperation = n.getObjectValue<EdiscoveryIndexOperation>(createEdiscoveryIndexOperationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryNoncustodialDataSourceCollectionResponse(ediscoveryNoncustodialDataSourceCollectionResponse: Partial<EdiscoveryNoncustodialDataSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryNoncustodialDataSourceCollectionResponse),
        "value": n => { ediscoveryNoncustodialDataSourceCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>(createEdiscoveryNoncustodialDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryPurgeDataOperation(ediscoveryPurgeDataOperation: Partial<EdiscoveryPurgeDataOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryPurgeDataOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewSet(ediscoveryReviewSet: Partial<EdiscoveryReviewSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSet(ediscoveryReviewSet),
        "files": n => { ediscoveryReviewSet.files = n.getCollectionOfObjectValues<EdiscoveryFile>(createEdiscoveryFileFromDiscriminatorValue); },
        "queries": n => { ediscoveryReviewSet.queries = n.getCollectionOfObjectValues<EdiscoveryReviewSetQuery>(createEdiscoveryReviewSetQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewSetCollectionResponse(ediscoveryReviewSetCollectionResponse: Partial<EdiscoveryReviewSetCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryReviewSetCollectionResponse),
        "value": n => { ediscoveryReviewSetCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryReviewSet>(createEdiscoveryReviewSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewSetQuery(ediscoveryReviewSetQuery: Partial<EdiscoveryReviewSetQuery> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSearch(ediscoveryReviewSetQuery),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewSetQueryCollectionResponse(ediscoveryReviewSetQueryCollectionResponse: Partial<EdiscoveryReviewSetQueryCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryReviewSetQueryCollectionResponse),
        "value": n => { ediscoveryReviewSetQueryCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryReviewSetQuery>(createEdiscoveryReviewSetQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewTag(ediscoveryReviewTag: Partial<EdiscoveryReviewTag> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoTag(ediscoveryReviewTag),
        "childSelectability": n => { ediscoveryReviewTag.childSelectability = n.getEnumValue<ChildSelectability>(ChildSelectabilityObject); },
        "childTags": n => { ediscoveryReviewTag.childTags = n.getCollectionOfObjectValues<EdiscoveryReviewTag>(createEdiscoveryReviewTagFromDiscriminatorValue); },
        "parent": n => { ediscoveryReviewTag.parent = n.getObjectValue<EdiscoveryReviewTag>(createEdiscoveryReviewTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewTagCollectionResponse(ediscoveryReviewTagCollectionResponse: Partial<EdiscoveryReviewTagCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryReviewTagCollectionResponse),
        "value": n => { ediscoveryReviewTagCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryReviewTag>(createEdiscoveryReviewTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoverySearch(ediscoverySearch: Partial<EdiscoverySearch> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSearch(ediscoverySearch),
        "additionalSources": n => { ediscoverySearch.additionalSources = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
        "addToReviewSetOperation": n => { ediscoverySearch.addToReviewSetOperation = n.getObjectValue<EdiscoveryAddToReviewSetOperation>(createEdiscoveryAddToReviewSetOperationFromDiscriminatorValue); },
        "custodianSources": n => { ediscoverySearch.custodianSources = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
        "dataSourceScopes": n => { ediscoverySearch.dataSourceScopes = n.getCollectionOfEnumValues<DataSourceScopes>(DataSourceScopesObject); },
        "lastEstimateStatisticsOperation": n => { ediscoverySearch.lastEstimateStatisticsOperation = n.getObjectValue<EdiscoveryEstimateOperation>(createEdiscoveryEstimateOperationFromDiscriminatorValue); },
        "noncustodialSources": n => { ediscoverySearch.noncustodialSources = n.getCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>(createEdiscoveryNoncustodialDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoverySearchCollectionResponse(ediscoverySearchCollectionResponse: Partial<EdiscoverySearchCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoverySearchCollectionResponse),
        "value": n => { ediscoverySearchCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoverySearch>(createEdiscoverySearchFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoverySearchExportOperation(ediscoverySearchExportOperation: Partial<EdiscoverySearchExportOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoverySearchExportOperation),
        "additionalOptions": n => { ediscoverySearchExportOperation.additionalOptions = n.getCollectionOfEnumValues<AdditionalOptions>(AdditionalOptionsObject); },
        "description": n => { ediscoverySearchExportOperation.description = n.getStringValue(); },
        "displayName": n => { ediscoverySearchExportOperation.displayName = n.getStringValue(); },
        "exportCriteria": n => { ediscoverySearchExportOperation.exportCriteria = n.getCollectionOfEnumValues<ExportCriteria>(ExportCriteriaObject); },
        "exportFileMetadata": n => { ediscoverySearchExportOperation.exportFileMetadata = n.getCollectionOfObjectValues<ExportFileMetadata>(createExportFileMetadataFromDiscriminatorValue); },
        "exportFormat": n => { ediscoverySearchExportOperation.exportFormat = n.getEnumValue<ExportFormat>(ExportFormatObject); },
        "exportLocation": n => { ediscoverySearchExportOperation.exportLocation = n.getCollectionOfEnumValues<ExportLocation>(ExportLocationObject); },
        "exportSingleItems": n => { ediscoverySearchExportOperation.exportSingleItems = n.getBooleanValue(); },
        "search": n => { ediscoverySearchExportOperation.search = n.getObjectValue<EdiscoverySearch>(createEdiscoverySearchFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryTagOperation(ediscoveryTagOperation: Partial<EdiscoveryTagOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryTagOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEmailContentThreatSubmission(emailContentThreatSubmission: Partial<EmailContentThreatSubmission> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEmailThreatSubmission(emailContentThreatSubmission),
        "fileContent": n => { emailContentThreatSubmission.fileContent = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEmailSender(emailSender: Partial<EmailSender> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { emailSender.backingStoreEnabled = true; },
        "displayName": n => { emailSender.displayName = n.getStringValue(); },
        "domainName": n => { emailSender.domainName = n.getStringValue(); },
        "emailAddress": n => { emailSender.emailAddress = n.getStringValue(); },
        "@odata.type": n => { emailSender.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEmailThreatSubmission(emailThreatSubmission: Partial<EmailThreatSubmission> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoThreatSubmission(emailThreatSubmission),
        "attackSimulationInfo": n => { emailThreatSubmission.attackSimulationInfo = n.getObjectValue<AttackSimulationInfo>(createAttackSimulationInfoFromDiscriminatorValue); },
        "internetMessageId": n => { emailThreatSubmission.internetMessageId = n.getStringValue(); },
        "originalCategory": n => { emailThreatSubmission.originalCategory = n.getEnumValue<SubmissionCategory>(SubmissionCategoryObject); },
        "receivedDateTime": n => { emailThreatSubmission.receivedDateTime = n.getDateValue(); },
        "recipientEmailAddress": n => { emailThreatSubmission.recipientEmailAddress = n.getStringValue(); },
        "sender": n => { emailThreatSubmission.sender = n.getStringValue(); },
        "senderIP": n => { emailThreatSubmission.senderIP = n.getStringValue(); },
        "subject": n => { emailThreatSubmission.subject = n.getStringValue(); },
        "tenantAllowOrBlockListAction": n => { emailThreatSubmission.tenantAllowOrBlockListAction = n.getObjectValue<TenantAllowOrBlockListAction>(createTenantAllowOrBlockListActionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEmailThreatSubmissionCollectionResponse(emailThreatSubmissionCollectionResponse: Partial<EmailThreatSubmissionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(emailThreatSubmissionCollectionResponse),
        "value": n => { emailThreatSubmissionCollectionResponse.value = n.getCollectionOfObjectValues<EmailThreatSubmission>(createEmailThreatSubmissionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEmailThreatSubmissionPolicy(emailThreatSubmissionPolicy: Partial<EmailThreatSubmissionPolicy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(emailThreatSubmissionPolicy),
        "customizedNotificationSenderEmailAddress": n => { emailThreatSubmissionPolicy.customizedNotificationSenderEmailAddress = n.getStringValue(); },
        "customizedReportRecipientEmailAddress": n => { emailThreatSubmissionPolicy.customizedReportRecipientEmailAddress = n.getStringValue(); },
        "isAlwaysReportEnabledForUsers": n => { emailThreatSubmissionPolicy.isAlwaysReportEnabledForUsers = n.getBooleanValue(); },
        "isAskMeEnabledForUsers": n => { emailThreatSubmissionPolicy.isAskMeEnabledForUsers = n.getBooleanValue(); },
        "isCustomizedMessageEnabled": n => { emailThreatSubmissionPolicy.isCustomizedMessageEnabled = n.getBooleanValue(); },
        "isCustomizedMessageEnabledForPhishing": n => { emailThreatSubmissionPolicy.isCustomizedMessageEnabledForPhishing = n.getBooleanValue(); },
        "isCustomizedNotificationSenderEnabled": n => { emailThreatSubmissionPolicy.isCustomizedNotificationSenderEnabled = n.getBooleanValue(); },
        "isNeverReportEnabledForUsers": n => { emailThreatSubmissionPolicy.isNeverReportEnabledForUsers = n.getBooleanValue(); },
        "isOrganizationBrandingEnabled": n => { emailThreatSubmissionPolicy.isOrganizationBrandingEnabled = n.getBooleanValue(); },
        "isReportFromQuarantineEnabled": n => { emailThreatSubmissionPolicy.isReportFromQuarantineEnabled = n.getBooleanValue(); },
        "isReportToCustomizedEmailAddressEnabled": n => { emailThreatSubmissionPolicy.isReportToCustomizedEmailAddressEnabled = n.getBooleanValue(); },
        "isReportToMicrosoftEnabled": n => { emailThreatSubmissionPolicy.isReportToMicrosoftEnabled = n.getBooleanValue(); },
        "isReviewEmailNotificationEnabled": n => { emailThreatSubmissionPolicy.isReviewEmailNotificationEnabled = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEmailThreatSubmissionPolicyCollectionResponse(emailThreatSubmissionPolicyCollectionResponse: Partial<EmailThreatSubmissionPolicyCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(emailThreatSubmissionPolicyCollectionResponse),
        "value": n => { emailThreatSubmissionPolicyCollectionResponse.value = n.getCollectionOfObjectValues<EmailThreatSubmissionPolicy>(createEmailThreatSubmissionPolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEmailUrlThreatSubmission(emailUrlThreatSubmission: Partial<EmailUrlThreatSubmission> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEmailThreatSubmission(emailUrlThreatSubmission),
        "messageUrl": n => { emailUrlThreatSubmission.messageUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEventPropagationResult(eventPropagationResult: Partial<EventPropagationResult> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { eventPropagationResult.backingStoreEnabled = true; },
        "location": n => { eventPropagationResult.location = n.getStringValue(); },
        "@odata.type": n => { eventPropagationResult.odataType = n.getStringValue(); },
        "serviceName": n => { eventPropagationResult.serviceName = n.getStringValue(); },
        "status": n => { eventPropagationResult.status = n.getEnumValue<EventPropagationStatus>(EventPropagationStatusObject); },
        "statusInformation": n => { eventPropagationResult.statusInformation = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEventQuery(eventQuery: Partial<EventQuery> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { eventQuery.backingStoreEnabled = true; },
        "@odata.type": n => { eventQuery.odataType = n.getStringValue(); },
        "query": n => { eventQuery.query = n.getStringValue(); },
        "queryType": n => { eventQuery.queryType = n.getEnumValue<QueryType>(QueryTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExportFileMetadata(exportFileMetadata: Partial<ExportFileMetadata> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { exportFileMetadata.backingStoreEnabled = true; },
        "downloadUrl": n => { exportFileMetadata.downloadUrl = n.getStringValue(); },
        "fileName": n => { exportFileMetadata.fileName = n.getStringValue(); },
        "@odata.type": n => { exportFileMetadata.odataType = n.getStringValue(); },
        "size": n => { exportFileMetadata.size = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFile(file: Partial<File> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(file),
        "content": n => { file.content = n.getStringValue(); },
        "dateTime": n => { file.dateTime = n.getDateValue(); },
        "extension": n => { file.extension = n.getStringValue(); },
        "extractedTextContent": n => { file.extractedTextContent = n.getStringValue(); },
        "mediaType": n => { file.mediaType = n.getStringValue(); },
        "name": n => { file.name = n.getStringValue(); },
        "otherProperties": n => { file.otherProperties = n.getObjectValue<StringValueDictionary>(createStringValueDictionaryFromDiscriminatorValue); },
        "processingStatus": n => { file.processingStatus = n.getEnumValue<FileProcessingStatus>(FileProcessingStatusObject); },
        "senderOrAuthors": n => { file.senderOrAuthors = n.getCollectionOfPrimitiveValues<string>(); },
        "size": n => { file.size = n.getNumberValue(); },
        "sourceType": n => { file.sourceType = n.getCollectionOfEnumValues<SourceType>(SourceTypeObject); },
        "subjectTitle": n => { file.subjectTitle = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileContentThreatSubmission(fileContentThreatSubmission: Partial<FileContentThreatSubmission> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFileThreatSubmission(fileContentThreatSubmission),
        "fileContent": n => { fileContentThreatSubmission.fileContent = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileDetails(fileDetails: Partial<FileDetails> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { fileDetails.backingStoreEnabled = true; },
        "fileName": n => { fileDetails.fileName = n.getStringValue(); },
        "filePath": n => { fileDetails.filePath = n.getStringValue(); },
        "filePublisher": n => { fileDetails.filePublisher = n.getStringValue(); },
        "fileSize": n => { fileDetails.fileSize = n.getNumberValue(); },
        "issuer": n => { fileDetails.issuer = n.getStringValue(); },
        "@odata.type": n => { fileDetails.odataType = n.getStringValue(); },
        "sha1": n => { fileDetails.sha1 = n.getStringValue(); },
        "sha256": n => { fileDetails.sha256 = n.getStringValue(); },
        "signer": n => { fileDetails.signer = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileEvidence(fileEvidence: Partial<FileEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(fileEvidence),
        "detectionStatus": n => { fileEvidence.detectionStatus = n.getEnumValue<DetectionStatus>(DetectionStatusObject); },
        "fileDetails": n => { fileEvidence.fileDetails = n.getObjectValue<FileDetails>(createFileDetailsFromDiscriminatorValue); },
        "mdeDeviceId": n => { fileEvidence.mdeDeviceId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileHash(fileHash: Partial<FileHash> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "algorithm": n => { fileHash.algorithm = n.getEnumValue<FileHashAlgorithm>(FileHashAlgorithmObject); },
        "backingStoreEnabled": n => { fileHash.backingStoreEnabled = true; },
        "@odata.type": n => { fileHash.odataType = n.getStringValue(); },
        "value": n => { fileHash.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileHashEvidence(fileHashEvidence: Partial<FileHashEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(fileHashEvidence),
        "algorithm": n => { fileHashEvidence.algorithm = n.getEnumValue<FileHashAlgorithm>(FileHashAlgorithmObject); },
        "value": n => { fileHashEvidence.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFilePlanAppliedCategory(filePlanAppliedCategory: Partial<FilePlanAppliedCategory> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorBase(filePlanAppliedCategory),
        "subcategory": n => { filePlanAppliedCategory.subcategory = n.getObjectValue<FilePlanSubcategory>(createFilePlanSubcategoryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFilePlanAuthority(filePlanAuthority: Partial<FilePlanAuthority> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorBase(filePlanAuthority),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFilePlanCitation(filePlanCitation: Partial<FilePlanCitation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorBase(filePlanCitation),
        "citationJurisdiction": n => { filePlanCitation.citationJurisdiction = n.getStringValue(); },
        "citationUrl": n => { filePlanCitation.citationUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFilePlanDepartment(filePlanDepartment: Partial<FilePlanDepartment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorBase(filePlanDepartment),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFilePlanDescriptor(filePlanDescriptor: Partial<FilePlanDescriptor> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(filePlanDescriptor),
        "authority": n => { filePlanDescriptor.authority = n.getObjectValue<FilePlanAuthority>(createFilePlanAuthorityFromDiscriminatorValue); },
        "authorityTemplate": n => { filePlanDescriptor.authorityTemplate = n.getObjectValue<AuthorityTemplate>(createAuthorityTemplateFromDiscriminatorValue); },
        "category": n => { filePlanDescriptor.category = n.getObjectValue<FilePlanAppliedCategory>(createFilePlanAppliedCategoryFromDiscriminatorValue); },
        "categoryTemplate": n => { filePlanDescriptor.categoryTemplate = n.getObjectValue<CategoryTemplate>(createCategoryTemplateFromDiscriminatorValue); },
        "citation": n => { filePlanDescriptor.citation = n.getObjectValue<FilePlanCitation>(createFilePlanCitationFromDiscriminatorValue); },
        "citationTemplate": n => { filePlanDescriptor.citationTemplate = n.getObjectValue<CitationTemplate>(createCitationTemplateFromDiscriminatorValue); },
        "department": n => { filePlanDescriptor.department = n.getObjectValue<FilePlanDepartment>(createFilePlanDepartmentFromDiscriminatorValue); },
        "departmentTemplate": n => { filePlanDescriptor.departmentTemplate = n.getObjectValue<DepartmentTemplate>(createDepartmentTemplateFromDiscriminatorValue); },
        "filePlanReference": n => { filePlanDescriptor.filePlanReference = n.getObjectValue<FilePlanReference>(createFilePlanReferenceFromDiscriminatorValue); },
        "filePlanReferenceTemplate": n => { filePlanDescriptor.filePlanReferenceTemplate = n.getObjectValue<FilePlanReferenceTemplate>(createFilePlanReferenceTemplateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFilePlanDescriptorBase(filePlanDescriptorBase: Partial<FilePlanDescriptorBase> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { filePlanDescriptorBase.backingStoreEnabled = true; },
        "displayName": n => { filePlanDescriptorBase.displayName = n.getStringValue(); },
        "@odata.type": n => { filePlanDescriptorBase.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFilePlanDescriptorTemplate(filePlanDescriptorTemplate: Partial<FilePlanDescriptorTemplate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(filePlanDescriptorTemplate),
        "createdBy": n => { filePlanDescriptorTemplate.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { filePlanDescriptorTemplate.createdDateTime = n.getDateValue(); },
        "displayName": n => { filePlanDescriptorTemplate.displayName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFilePlanReference(filePlanReference: Partial<FilePlanReference> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorBase(filePlanReference),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFilePlanReferenceTemplate(filePlanReferenceTemplate: Partial<FilePlanReferenceTemplate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorTemplate(filePlanReferenceTemplate),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFilePlanReferenceTemplateCollectionResponse(filePlanReferenceTemplateCollectionResponse: Partial<FilePlanReferenceTemplateCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(filePlanReferenceTemplateCollectionResponse),
        "value": n => { filePlanReferenceTemplateCollectionResponse.value = n.getCollectionOfObjectValues<FilePlanReferenceTemplate>(createFilePlanReferenceTemplateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFilePlanSubcategory(filePlanSubcategory: Partial<FilePlanSubcategory> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorBase(filePlanSubcategory),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileThreatSubmission(fileThreatSubmission: Partial<FileThreatSubmission> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoThreatSubmission(fileThreatSubmission),
        "fileName": n => { fileThreatSubmission.fileName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileThreatSubmissionCollectionResponse(fileThreatSubmissionCollectionResponse: Partial<FileThreatSubmissionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(fileThreatSubmissionCollectionResponse),
        "value": n => { fileThreatSubmissionCollectionResponse.value = n.getCollectionOfObjectValues<FileThreatSubmission>(createFileThreatSubmissionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileUrlThreatSubmission(fileUrlThreatSubmission: Partial<FileUrlThreatSubmission> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFileThreatSubmission(fileUrlThreatSubmission),
        "fileUrl": n => { fileUrlThreatSubmission.fileUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoForceUserPasswordResetResponseAction(forceUserPasswordResetResponseAction: Partial<ForceUserPasswordResetResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(forceUserPasswordResetResponseAction),
        "identifier": n => { forceUserPasswordResetResponseAction.identifier = n.getCollectionOfEnumValues<ForceUserPasswordResetEntityIdentifier>(ForceUserPasswordResetEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFormattedContent(formattedContent: Partial<FormattedContent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { formattedContent.backingStoreEnabled = true; },
        "content": n => { formattedContent.content = n.getStringValue(); },
        "format": n => { formattedContent.format = n.getEnumValue<ContentFormat>(ContentFormatObject); },
        "@odata.type": n => { formattedContent.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoGeoLocation(geoLocation: Partial<GeoLocation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { geoLocation.backingStoreEnabled = true; },
        "city": n => { geoLocation.city = n.getStringValue(); },
        "countryName": n => { geoLocation.countryName = n.getStringValue(); },
        "latitude": n => { geoLocation.latitude = n.getNumberValue(); },
        "longitude": n => { geoLocation.longitude = n.getNumberValue(); },
        "@odata.type": n => { geoLocation.odataType = n.getStringValue(); },
        "state": n => { geoLocation.state = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoGitHubOrganizationEvidence(gitHubOrganizationEvidence: Partial<GitHubOrganizationEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(gitHubOrganizationEvidence),
        "company": n => { gitHubOrganizationEvidence.company = n.getStringValue(); },
        "displayName": n => { gitHubOrganizationEvidence.displayName = n.getStringValue(); },
        "email": n => { gitHubOrganizationEvidence.email = n.getStringValue(); },
        "login": n => { gitHubOrganizationEvidence.login = n.getStringValue(); },
        "orgId": n => { gitHubOrganizationEvidence.orgId = n.getStringValue(); },
        "webUrl": n => { gitHubOrganizationEvidence.webUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoGitHubRepoEvidence(gitHubRepoEvidence: Partial<GitHubRepoEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(gitHubRepoEvidence),
        "baseUrl": n => { gitHubRepoEvidence.baseUrl = n.getStringValue(); },
        "login": n => { gitHubRepoEvidence.login = n.getStringValue(); },
        "owner": n => { gitHubRepoEvidence.owner = n.getStringValue(); },
        "ownerType": n => { gitHubRepoEvidence.ownerType = n.getStringValue(); },
        "repoId": n => { gitHubRepoEvidence.repoId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoGitHubUserEvidence(gitHubUserEvidence: Partial<GitHubUserEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(gitHubUserEvidence),
        "email": n => { gitHubUserEvidence.email = n.getStringValue(); },
        "login": n => { gitHubUserEvidence.login = n.getStringValue(); },
        "name": n => { gitHubUserEvidence.name = n.getStringValue(); },
        "userId": n => { gitHubUserEvidence.userId = n.getStringValue(); },
        "webUrl": n => { gitHubUserEvidence.webUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoGoogleCloudResourceEvidence(googleCloudResourceEvidence: Partial<GoogleCloudResourceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(googleCloudResourceEvidence),
        "fullResourceName": n => { googleCloudResourceEvidence.fullResourceName = n.getStringValue(); },
        "location": n => { googleCloudResourceEvidence.location = n.getStringValue(); },
        "locationType": n => { googleCloudResourceEvidence.locationType = n.getEnumValue<GoogleCloudLocationType>(GoogleCloudLocationTypeObject); },
        "projectId": n => { googleCloudResourceEvidence.projectId = n.getStringValue(); },
        "projectNumber": n => { googleCloudResourceEvidence.projectNumber = n.getNumberValue(); },
        "resourceName": n => { googleCloudResourceEvidence.resourceName = n.getStringValue(); },
        "resourceType": n => { googleCloudResourceEvidence.resourceType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHardDeleteResponseAction(hardDeleteResponseAction: Partial<HardDeleteResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(hardDeleteResponseAction),
        "identifier": n => { hardDeleteResponseAction.identifier = n.getCollectionOfEnumValues<EmailEntityIdentifier>(EmailEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHealthIssue(healthIssue: Partial<HealthIssue> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(healthIssue),
        "additionalInformation": n => { healthIssue.additionalInformation = n.getCollectionOfPrimitiveValues<string>(); },
        "createdDateTime": n => { healthIssue.createdDateTime = n.getDateValue(); },
        "description": n => { healthIssue.description = n.getStringValue(); },
        "displayName": n => { healthIssue.displayName = n.getStringValue(); },
        "domainNames": n => { healthIssue.domainNames = n.getCollectionOfPrimitiveValues<string>(); },
        "healthIssueType": n => { healthIssue.healthIssueType = n.getEnumValue<HealthIssueType>(HealthIssueTypeObject); },
        "issueTypeId": n => { healthIssue.issueTypeId = n.getStringValue(); },
        "lastModifiedDateTime": n => { healthIssue.lastModifiedDateTime = n.getDateValue(); },
        "recommendations": n => { healthIssue.recommendations = n.getCollectionOfPrimitiveValues<string>(); },
        "recommendedActionCommands": n => { healthIssue.recommendedActionCommands = n.getCollectionOfPrimitiveValues<string>(); },
        "sensorDNSNames": n => { healthIssue.sensorDNSNames = n.getCollectionOfPrimitiveValues<string>(); },
        "severity": n => { healthIssue.severity = n.getEnumValue<HealthIssueSeverity>(HealthIssueSeverityObject); },
        "status": n => { healthIssue.status = n.getEnumValue<HealthIssueStatus>(HealthIssueStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHealthIssueCollectionResponse(healthIssueCollectionResponse: Partial<HealthIssueCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(healthIssueCollectionResponse),
        "value": n => { healthIssueCollectionResponse.value = n.getCollectionOfObjectValues<HealthIssue>(createHealthIssueFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHost(host: Partial<Host> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(host),
        "childHostPairs": n => { host.childHostPairs = n.getCollectionOfObjectValues<HostPair>(createHostPairFromDiscriminatorValue); },
        "components": n => { host.components = n.getCollectionOfObjectValues<HostComponent>(createHostComponentFromDiscriminatorValue); },
        "cookies": n => { host.cookies = n.getCollectionOfObjectValues<HostCookie>(createHostCookieFromDiscriminatorValue); },
        "firstSeenDateTime": n => { host.firstSeenDateTime = n.getDateValue(); },
        "hostPairs": n => { host.hostPairs = n.getCollectionOfObjectValues<HostPair>(createHostPairFromDiscriminatorValue); },
        "lastSeenDateTime": n => { host.lastSeenDateTime = n.getDateValue(); },
        "parentHostPairs": n => { host.parentHostPairs = n.getCollectionOfObjectValues<HostPair>(createHostPairFromDiscriminatorValue); },
        "passiveDns": n => { host.passiveDns = n.getCollectionOfObjectValues<PassiveDnsRecord>(createPassiveDnsRecordFromDiscriminatorValue); },
        "passiveDnsReverse": n => { host.passiveDnsReverse = n.getCollectionOfObjectValues<PassiveDnsRecord>(createPassiveDnsRecordFromDiscriminatorValue); },
        "ports": n => { host.ports = n.getCollectionOfObjectValues<HostPort>(createHostPortFromDiscriminatorValue); },
        "reputation": n => { host.reputation = n.getObjectValue<HostReputation>(createHostReputationFromDiscriminatorValue); },
        "sslCertificates": n => { host.sslCertificates = n.getCollectionOfObjectValues<HostSslCertificate>(createHostSslCertificateFromDiscriminatorValue); },
        "subdomains": n => { host.subdomains = n.getCollectionOfObjectValues<Subdomain>(createSubdomainFromDiscriminatorValue); },
        "trackers": n => { host.trackers = n.getCollectionOfObjectValues<HostTracker>(createHostTrackerFromDiscriminatorValue); },
        "whois": n => { host.whois = n.getObjectValue<WhoisRecord>(createWhoisRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostCollectionResponse(hostCollectionResponse: Partial<HostCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostCollectionResponse),
        "value": n => { hostCollectionResponse.value = n.getCollectionOfObjectValues<Host>(createHostFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostComponent(hostComponent: Partial<HostComponent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(hostComponent),
        "category": n => { hostComponent.category = n.getStringValue(); },
        "firstSeenDateTime": n => { hostComponent.firstSeenDateTime = n.getDateValue(); },
        "host": n => { hostComponent.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastSeenDateTime": n => { hostComponent.lastSeenDateTime = n.getDateValue(); },
        "name": n => { hostComponent.name = n.getStringValue(); },
        "version": n => { hostComponent.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostComponentCollectionResponse(hostComponentCollectionResponse: Partial<HostComponentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostComponentCollectionResponse),
        "value": n => { hostComponentCollectionResponse.value = n.getCollectionOfObjectValues<HostComponent>(createHostComponentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostCookie(hostCookie: Partial<HostCookie> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(hostCookie),
        "domain": n => { hostCookie.domain = n.getStringValue(); },
        "firstSeenDateTime": n => { hostCookie.firstSeenDateTime = n.getDateValue(); },
        "host": n => { hostCookie.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastSeenDateTime": n => { hostCookie.lastSeenDateTime = n.getDateValue(); },
        "name": n => { hostCookie.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostCookieCollectionResponse(hostCookieCollectionResponse: Partial<HostCookieCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostCookieCollectionResponse),
        "value": n => { hostCookieCollectionResponse.value = n.getCollectionOfObjectValues<HostCookie>(createHostCookieFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostLogonSessionEvidence(hostLogonSessionEvidence: Partial<HostLogonSessionEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(hostLogonSessionEvidence),
        "account": n => { hostLogonSessionEvidence.account = n.getObjectValue<UserEvidence>(createUserEvidenceFromDiscriminatorValue); },
        "endUtcDateTime": n => { hostLogonSessionEvidence.endUtcDateTime = n.getDateValue(); },
        "host": n => { hostLogonSessionEvidence.host = n.getObjectValue<DeviceEvidence>(createDeviceEvidenceFromDiscriminatorValue); },
        "sessionId": n => { hostLogonSessionEvidence.sessionId = n.getStringValue(); },
        "startUtcDateTime": n => { hostLogonSessionEvidence.startUtcDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostname(hostname: Partial<Hostname> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoHost(hostname),
        "registrant": n => { hostname.registrant = n.getStringValue(); },
        "registrar": n => { hostname.registrar = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPair(hostPair: Partial<HostPair> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(hostPair),
        "childHost": n => { hostPair.childHost = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "firstSeenDateTime": n => { hostPair.firstSeenDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { hostPair.lastSeenDateTime = n.getDateValue(); },
        "linkKind": n => { hostPair.linkKind = n.getStringValue(); },
        "parentHost": n => { hostPair.parentHost = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPairCollectionResponse(hostPairCollectionResponse: Partial<HostPairCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostPairCollectionResponse),
        "value": n => { hostPairCollectionResponse.value = n.getCollectionOfObjectValues<HostPair>(createHostPairFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPort(hostPort: Partial<HostPort> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(hostPort),
        "banners": n => { hostPort.banners = n.getCollectionOfObjectValues<HostPortBanner>(createHostPortBannerFromDiscriminatorValue); },
        "firstSeenDateTime": n => { hostPort.firstSeenDateTime = n.getDateValue(); },
        "host": n => { hostPort.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastScanDateTime": n => { hostPort.lastScanDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { hostPort.lastSeenDateTime = n.getDateValue(); },
        "mostRecentSslCertificate": n => { hostPort.mostRecentSslCertificate = n.getObjectValue<SslCertificate>(createSslCertificateFromDiscriminatorValue); },
        "port": n => { hostPort.port = n.getNumberValue(); },
        "protocol": n => { hostPort.protocol = n.getEnumValue<HostPortProtocol>(HostPortProtocolObject); },
        "services": n => { hostPort.services = n.getCollectionOfObjectValues<HostPortComponent>(createHostPortComponentFromDiscriminatorValue); },
        "status": n => { hostPort.status = n.getEnumValue<HostPortStatus>(HostPortStatusObject); },
        "timesObserved": n => { hostPort.timesObserved = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPortBanner(hostPortBanner: Partial<HostPortBanner> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { hostPortBanner.backingStoreEnabled = true; },
        "banner": n => { hostPortBanner.banner = n.getStringValue(); },
        "firstSeenDateTime": n => { hostPortBanner.firstSeenDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { hostPortBanner.lastSeenDateTime = n.getDateValue(); },
        "@odata.type": n => { hostPortBanner.odataType = n.getStringValue(); },
        "scanProtocol": n => { hostPortBanner.scanProtocol = n.getStringValue(); },
        "timesObserved": n => { hostPortBanner.timesObserved = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPortCollectionResponse(hostPortCollectionResponse: Partial<HostPortCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostPortCollectionResponse),
        "value": n => { hostPortCollectionResponse.value = n.getCollectionOfObjectValues<HostPort>(createHostPortFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPortComponent(hostPortComponent: Partial<HostPortComponent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { hostPortComponent.backingStoreEnabled = true; },
        "component": n => { hostPortComponent.component = n.getObjectValue<HostComponent>(createHostComponentFromDiscriminatorValue); },
        "firstSeenDateTime": n => { hostPortComponent.firstSeenDateTime = n.getDateValue(); },
        "isRecent": n => { hostPortComponent.isRecent = n.getBooleanValue(); },
        "lastSeenDateTime": n => { hostPortComponent.lastSeenDateTime = n.getDateValue(); },
        "@odata.type": n => { hostPortComponent.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostReputation(hostReputation: Partial<HostReputation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(hostReputation),
        "classification": n => { hostReputation.classification = n.getEnumValue<HostReputationClassification>(HostReputationClassificationObject); },
        "rules": n => { hostReputation.rules = n.getCollectionOfObjectValues<HostReputationRule>(createHostReputationRuleFromDiscriminatorValue); },
        "score": n => { hostReputation.score = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostReputationRule(hostReputationRule: Partial<HostReputationRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { hostReputationRule.backingStoreEnabled = true; },
        "description": n => { hostReputationRule.description = n.getStringValue(); },
        "name": n => { hostReputationRule.name = n.getStringValue(); },
        "@odata.type": n => { hostReputationRule.odataType = n.getStringValue(); },
        "relatedDetailsUrl": n => { hostReputationRule.relatedDetailsUrl = n.getStringValue(); },
        "severity": n => { hostReputationRule.severity = n.getEnumValue<HostReputationRuleSeverity>(HostReputationRuleSeverityObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostSslCertificate(hostSslCertificate: Partial<HostSslCertificate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(hostSslCertificate),
        "firstSeenDateTime": n => { hostSslCertificate.firstSeenDateTime = n.getDateValue(); },
        "host": n => { hostSslCertificate.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastSeenDateTime": n => { hostSslCertificate.lastSeenDateTime = n.getDateValue(); },
        "ports": n => { hostSslCertificate.ports = n.getCollectionOfObjectValues<HostSslCertificatePort>(createHostSslCertificatePortFromDiscriminatorValue); },
        "sslCertificate": n => { hostSslCertificate.sslCertificate = n.getObjectValue<SslCertificate>(createSslCertificateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostSslCertificateCollectionResponse(hostSslCertificateCollectionResponse: Partial<HostSslCertificateCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostSslCertificateCollectionResponse),
        "value": n => { hostSslCertificateCollectionResponse.value = n.getCollectionOfObjectValues<HostSslCertificate>(createHostSslCertificateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostSslCertificatePort(hostSslCertificatePort: Partial<HostSslCertificatePort> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { hostSslCertificatePort.backingStoreEnabled = true; },
        "firstSeenDateTime": n => { hostSslCertificatePort.firstSeenDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { hostSslCertificatePort.lastSeenDateTime = n.getDateValue(); },
        "@odata.type": n => { hostSslCertificatePort.odataType = n.getStringValue(); },
        "port": n => { hostSslCertificatePort.port = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostTracker(hostTracker: Partial<HostTracker> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(hostTracker),
        "firstSeenDateTime": n => { hostTracker.firstSeenDateTime = n.getDateValue(); },
        "host": n => { hostTracker.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "kind": n => { hostTracker.kind = n.getStringValue(); },
        "lastSeenDateTime": n => { hostTracker.lastSeenDateTime = n.getDateValue(); },
        "value": n => { hostTracker.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostTrackerCollectionResponse(hostTrackerCollectionResponse: Partial<HostTrackerCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostTrackerCollectionResponse),
        "value": n => { hostTrackerCollectionResponse.value = n.getCollectionOfObjectValues<HostTracker>(createHostTrackerFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHuntingQueryResults(huntingQueryResults: Partial<HuntingQueryResults> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { huntingQueryResults.backingStoreEnabled = true; },
        "@odata.type": n => { huntingQueryResults.odataType = n.getStringValue(); },
        "results": n => { huntingQueryResults.results = n.getCollectionOfObjectValues<HuntingRowResult>(createHuntingRowResultFromDiscriminatorValue); },
        "schema": n => { huntingQueryResults.schema = n.getCollectionOfObjectValues<SinglePropertySchema>(createSinglePropertySchemaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHuntingRowResult(huntingRowResult: Partial<HuntingRowResult> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { huntingRowResult.backingStoreEnabled = true; },
        "@odata.type": n => { huntingRowResult.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHyperlink(hyperlink: Partial<Hyperlink> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { hyperlink.backingStoreEnabled = true; },
        "name": n => { hyperlink.name = n.getStringValue(); },
        "@odata.type": n => { hyperlink.odataType = n.getStringValue(); },
        "url": n => { hyperlink.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIdentityContainer(identityContainer: Partial<IdentityContainer> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(identityContainer),
        "healthIssues": n => { identityContainer.healthIssues = n.getCollectionOfObjectValues<HealthIssue>(createHealthIssueFromDiscriminatorValue); },
        "sensors": n => { identityContainer.sensors = n.getCollectionOfObjectValues<Sensor>(createSensorFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoImpactedAsset(impactedAsset: Partial<ImpactedAsset> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { impactedAsset.backingStoreEnabled = true; },
        "@odata.type": n => { impactedAsset.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoImpactedDeviceAsset(impactedDeviceAsset: Partial<ImpactedDeviceAsset> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoImpactedAsset(impactedDeviceAsset),
        "identifier": n => { impactedDeviceAsset.identifier = n.getEnumValue<DeviceAssetIdentifier>(DeviceAssetIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoImpactedMailboxAsset(impactedMailboxAsset: Partial<ImpactedMailboxAsset> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoImpactedAsset(impactedMailboxAsset),
        "identifier": n => { impactedMailboxAsset.identifier = n.getEnumValue<MailboxAssetIdentifier>(MailboxAssetIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoImpactedUserAsset(impactedUserAsset: Partial<ImpactedUserAsset> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoImpactedAsset(impactedUserAsset),
        "identifier": n => { impactedUserAsset.identifier = n.getEnumValue<UserAssetIdentifier>(UserAssetIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIncident(incident: Partial<Incident> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(incident),
        "alerts": n => { incident.alerts = n.getCollectionOfObjectValues<Alert>(createAlertFromDiscriminatorValue); },
        "assignedTo": n => { incident.assignedTo = n.getStringValue(); },
        "classification": n => { incident.classification = n.getEnumValue<AlertClassification>(AlertClassificationObject); },
        "comments": n => { incident.comments = n.getCollectionOfObjectValues<AlertComment>(createAlertCommentFromDiscriminatorValue); },
        "createdDateTime": n => { incident.createdDateTime = n.getDateValue(); },
        "customTags": n => { incident.customTags = n.getCollectionOfPrimitiveValues<string>(); },
        "description": n => { incident.description = n.getStringValue(); },
        "determination": n => { incident.determination = n.getEnumValue<AlertDetermination>(AlertDeterminationObject); },
        "displayName": n => { incident.displayName = n.getStringValue(); },
        "incidentWebUrl": n => { incident.incidentWebUrl = n.getStringValue(); },
        "lastModifiedBy": n => { incident.lastModifiedBy = n.getStringValue(); },
        "lastUpdateDateTime": n => { incident.lastUpdateDateTime = n.getDateValue(); },
        "recommendedActions": n => { incident.recommendedActions = n.getStringValue(); },
        "recommendedHuntingQueries": n => { incident.recommendedHuntingQueries = n.getCollectionOfObjectValues<RecommendedHuntingQuery>(createRecommendedHuntingQueryFromDiscriminatorValue); },
        "redirectIncidentId": n => { incident.redirectIncidentId = n.getStringValue(); },
        "resolvingComment": n => { incident.resolvingComment = n.getStringValue(); },
        "severity": n => { incident.severity = n.getEnumValue<AlertSeverity>(AlertSeverityObject); },
        "status": n => { incident.status = n.getEnumValue<IncidentStatus>(IncidentStatusObject); },
        "systemTags": n => { incident.systemTags = n.getCollectionOfPrimitiveValues<string>(); },
        "tenantId": n => { incident.tenantId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIncidentCollectionResponse(incidentCollectionResponse: Partial<IncidentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(incidentCollectionResponse),
        "value": n => { incidentCollectionResponse.value = n.getCollectionOfObjectValues<Incident>(createIncidentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIndicator(indicator: Partial<Indicator> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(indicator),
        "artifact": n => { indicator.artifact = n.getObjectValue<Artifact>(createArtifactFromDiscriminatorValue); },
        "source": n => { indicator.source = n.getEnumValue<IndicatorSource>(IndicatorSourceObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoInformationProtection(informationProtection: Partial<InformationProtection> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(informationProtection),
        "labelPolicySettings": n => { informationProtection.labelPolicySettings = n.getObjectValue<InformationProtectionPolicySetting>(createInformationProtectionPolicySettingFromDiscriminatorValue); },
        "sensitivityLabels": n => { informationProtection.sensitivityLabels = n.getCollectionOfObjectValues<SensitivityLabel>(createSensitivityLabelFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoInformationProtectionAction(informationProtectionAction: Partial<InformationProtectionAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { informationProtectionAction.backingStoreEnabled = true; },
        "@odata.type": n => { informationProtectionAction.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoInformationProtectionPolicySetting(informationProtectionPolicySetting: Partial<InformationProtectionPolicySetting> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(informationProtectionPolicySetting),
        "defaultLabelId": n => { informationProtectionPolicySetting.defaultLabelId = n.getStringValue(); },
        "isDowngradeJustificationRequired": n => { informationProtectionPolicySetting.isDowngradeJustificationRequired = n.getBooleanValue(); },
        "isMandatory": n => { informationProtectionPolicySetting.isMandatory = n.getBooleanValue(); },
        "moreInfoUrl": n => { informationProtectionPolicySetting.moreInfoUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoInitiateInvestigationResponseAction(initiateInvestigationResponseAction: Partial<InitiateInvestigationResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(initiateInvestigationResponseAction),
        "identifier": n => { initiateInvestigationResponseAction.identifier = n.getCollectionOfEnumValues<DeviceIdEntityIdentifier>(DeviceIdEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIntelligenceProfile(intelligenceProfile: Partial<IntelligenceProfile> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(intelligenceProfile),
        "aliases": n => { intelligenceProfile.aliases = n.getCollectionOfPrimitiveValues<string>(); },
        "countriesOrRegionsOfOrigin": n => { intelligenceProfile.countriesOrRegionsOfOrigin = n.getCollectionOfObjectValues<IntelligenceProfileCountryOrRegionOfOrigin>(createIntelligenceProfileCountryOrRegionOfOriginFromDiscriminatorValue); },
        "description": n => { intelligenceProfile.description = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "firstActiveDateTime": n => { intelligenceProfile.firstActiveDateTime = n.getDateValue(); },
        "indicators": n => { intelligenceProfile.indicators = n.getCollectionOfObjectValues<IntelligenceProfileIndicator>(createIntelligenceProfileIndicatorFromDiscriminatorValue); },
        "kind": n => { intelligenceProfile.kind = n.getEnumValue<IntelligenceProfileKind>(IntelligenceProfileKindObject); },
        "summary": n => { intelligenceProfile.summary = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "targets": n => { intelligenceProfile.targets = n.getCollectionOfPrimitiveValues<string>(); },
        "title": n => { intelligenceProfile.title = n.getStringValue(); },
        "tradecraft": n => { intelligenceProfile.tradecraft = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIntelligenceProfileCollectionResponse(intelligenceProfileCollectionResponse: Partial<IntelligenceProfileCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(intelligenceProfileCollectionResponse),
        "value": n => { intelligenceProfileCollectionResponse.value = n.getCollectionOfObjectValues<IntelligenceProfile>(createIntelligenceProfileFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIntelligenceProfileCountryOrRegionOfOrigin(intelligenceProfileCountryOrRegionOfOrigin: Partial<IntelligenceProfileCountryOrRegionOfOrigin> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { intelligenceProfileCountryOrRegionOfOrigin.backingStoreEnabled = true; },
        "code": n => { intelligenceProfileCountryOrRegionOfOrigin.code = n.getStringValue(); },
        "label": n => { intelligenceProfileCountryOrRegionOfOrigin.label = n.getStringValue(); },
        "@odata.type": n => { intelligenceProfileCountryOrRegionOfOrigin.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIntelligenceProfileIndicator(intelligenceProfileIndicator: Partial<IntelligenceProfileIndicator> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIndicator(intelligenceProfileIndicator),
        "firstSeenDateTime": n => { intelligenceProfileIndicator.firstSeenDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { intelligenceProfileIndicator.lastSeenDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIntelligenceProfileIndicatorCollectionResponse(intelligenceProfileIndicatorCollectionResponse: Partial<IntelligenceProfileIndicatorCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(intelligenceProfileIndicatorCollectionResponse),
        "value": n => { intelligenceProfileIndicatorCollectionResponse.value = n.getCollectionOfObjectValues<IntelligenceProfileIndicator>(createIntelligenceProfileIndicatorFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIoTDeviceEvidence(ioTDeviceEvidence: Partial<IoTDeviceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(ioTDeviceEvidence),
        "deviceId": n => { ioTDeviceEvidence.deviceId = n.getStringValue(); },
        "deviceName": n => { ioTDeviceEvidence.deviceName = n.getStringValue(); },
        "devicePageLink": n => { ioTDeviceEvidence.devicePageLink = n.getStringValue(); },
        "deviceSubType": n => { ioTDeviceEvidence.deviceSubType = n.getStringValue(); },
        "deviceType": n => { ioTDeviceEvidence.deviceType = n.getStringValue(); },
        "importance": n => { ioTDeviceEvidence.importance = n.getEnumValue<IoTDeviceImportanceType>(IoTDeviceImportanceTypeObject); },
        "ioTHub": n => { ioTDeviceEvidence.ioTHub = n.getObjectValue<AzureResourceEvidence>(createAzureResourceEvidenceFromDiscriminatorValue); },
        "ioTSecurityAgentId": n => { ioTDeviceEvidence.ioTSecurityAgentId = n.getStringValue(); },
        "ipAddress": n => { ioTDeviceEvidence.ipAddress = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "isAuthorized": n => { ioTDeviceEvidence.isAuthorized = n.getBooleanValue(); },
        "isProgramming": n => { ioTDeviceEvidence.isProgramming = n.getBooleanValue(); },
        "isScanner": n => { ioTDeviceEvidence.isScanner = n.getBooleanValue(); },
        "macAddress": n => { ioTDeviceEvidence.macAddress = n.getStringValue(); },
        "manufacturer": n => { ioTDeviceEvidence.manufacturer = n.getStringValue(); },
        "model": n => { ioTDeviceEvidence.model = n.getStringValue(); },
        "nics": n => { ioTDeviceEvidence.nics = n.getObjectValue<NicEvidence>(createNicEvidenceFromDiscriminatorValue); },
        "operatingSystem": n => { ioTDeviceEvidence.operatingSystem = n.getStringValue(); },
        "owners": n => { ioTDeviceEvidence.owners = n.getCollectionOfPrimitiveValues<string>(); },
        "protocols": n => { ioTDeviceEvidence.protocols = n.getCollectionOfPrimitiveValues<string>(); },
        "purdueLayer": n => { ioTDeviceEvidence.purdueLayer = n.getStringValue(); },
        "sensor": n => { ioTDeviceEvidence.sensor = n.getStringValue(); },
        "serialNumber": n => { ioTDeviceEvidence.serialNumber = n.getStringValue(); },
        "site": n => { ioTDeviceEvidence.site = n.getStringValue(); },
        "source": n => { ioTDeviceEvidence.source = n.getStringValue(); },
        "sourceRef": n => { ioTDeviceEvidence.sourceRef = n.getObjectValue<UrlEvidence>(createUrlEvidenceFromDiscriminatorValue); },
        "zone": n => { ioTDeviceEvidence.zone = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIpAddress(ipAddress: Partial<IpAddress> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoHost(ipAddress),
        "autonomousSystem": n => { ipAddress.autonomousSystem = n.getObjectValue<AutonomousSystem>(createAutonomousSystemFromDiscriminatorValue); },
        "countryOrRegion": n => { ipAddress.countryOrRegion = n.getStringValue(); },
        "hostingProvider": n => { ipAddress.hostingProvider = n.getStringValue(); },
        "netblock": n => { ipAddress.netblock = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIpEvidence(ipEvidence: Partial<IpEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(ipEvidence),
        "countryLetterCode": n => { ipEvidence.countryLetterCode = n.getStringValue(); },
        "ipAddress": n => { ipEvidence.ipAddress = n.getStringValue(); },
        "location": n => { ipEvidence.location = n.getObjectValue<GeoLocation>(createGeoLocationFromDiscriminatorValue); },
        "stream": n => { ipEvidence.stream = n.getObjectValue<Stream>(createStreamFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIsolateDeviceResponseAction(isolateDeviceResponseAction: Partial<IsolateDeviceResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(isolateDeviceResponseAction),
        "identifier": n => { isolateDeviceResponseAction.identifier = n.getCollectionOfEnumValues<DeviceIdEntityIdentifier>(DeviceIdEntityIdentifierObject); },
        "isolationType": n => { isolateDeviceResponseAction.isolationType = n.getEnumValue<IsolationType>(IsolationTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoJustifyAction(justifyAction: Partial<JustifyAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(justifyAction),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKeyValuePair(keyValuePair: Partial<KeyValuePair> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { keyValuePair.backingStoreEnabled = true; },
        "name": n => { keyValuePair.name = n.getStringValue(); },
        "@odata.type": n => { keyValuePair.odataType = n.getStringValue(); },
        "value": n => { keyValuePair.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesClusterEvidence(kubernetesClusterEvidence: Partial<KubernetesClusterEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesClusterEvidence),
        "cloudResource": n => { kubernetesClusterEvidence.cloudResource = n.getObjectValue<AlertEvidence>(createAlertEvidenceFromDiscriminatorValue); },
        "distribution": n => { kubernetesClusterEvidence.distribution = n.getStringValue(); },
        "name": n => { kubernetesClusterEvidence.name = n.getStringValue(); },
        "platform": n => { kubernetesClusterEvidence.platform = n.getEnumValue<KubernetesPlatform>(KubernetesPlatformObject); },
        "version": n => { kubernetesClusterEvidence.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesControllerEvidence(kubernetesControllerEvidence: Partial<KubernetesControllerEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesControllerEvidence),
        "labels": n => { kubernetesControllerEvidence.labels = n.getObjectValue<Dictionary>(createDictionaryFromDiscriminatorValue); },
        "name": n => { kubernetesControllerEvidence.name = n.getStringValue(); },
        "namespace": n => { kubernetesControllerEvidence.namespace = n.getObjectValue<KubernetesNamespaceEvidence>(createKubernetesNamespaceEvidenceFromDiscriminatorValue); },
        "type": n => { kubernetesControllerEvidence.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesNamespaceEvidence(kubernetesNamespaceEvidence: Partial<KubernetesNamespaceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesNamespaceEvidence),
        "cluster": n => { kubernetesNamespaceEvidence.cluster = n.getObjectValue<KubernetesClusterEvidence>(createKubernetesClusterEvidenceFromDiscriminatorValue); },
        "labels": n => { kubernetesNamespaceEvidence.labels = n.getObjectValue<Dictionary>(createDictionaryFromDiscriminatorValue); },
        "name": n => { kubernetesNamespaceEvidence.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesPodEvidence(kubernetesPodEvidence: Partial<KubernetesPodEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesPodEvidence),
        "containers": n => { kubernetesPodEvidence.containers = n.getCollectionOfObjectValues<ContainerEvidence>(createContainerEvidenceFromDiscriminatorValue); },
        "controller": n => { kubernetesPodEvidence.controller = n.getObjectValue<KubernetesControllerEvidence>(createKubernetesControllerEvidenceFromDiscriminatorValue); },
        "ephemeralContainers": n => { kubernetesPodEvidence.ephemeralContainers = n.getCollectionOfObjectValues<ContainerEvidence>(createContainerEvidenceFromDiscriminatorValue); },
        "initContainers": n => { kubernetesPodEvidence.initContainers = n.getCollectionOfObjectValues<ContainerEvidence>(createContainerEvidenceFromDiscriminatorValue); },
        "labels": n => { kubernetesPodEvidence.labels = n.getObjectValue<Dictionary>(createDictionaryFromDiscriminatorValue); },
        "name": n => { kubernetesPodEvidence.name = n.getStringValue(); },
        "namespace": n => { kubernetesPodEvidence.namespace = n.getObjectValue<KubernetesNamespaceEvidence>(createKubernetesNamespaceEvidenceFromDiscriminatorValue); },
        "podIp": n => { kubernetesPodEvidence.podIp = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "serviceAccount": n => { kubernetesPodEvidence.serviceAccount = n.getObjectValue<KubernetesServiceAccountEvidence>(createKubernetesServiceAccountEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesSecretEvidence(kubernetesSecretEvidence: Partial<KubernetesSecretEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesSecretEvidence),
        "name": n => { kubernetesSecretEvidence.name = n.getStringValue(); },
        "namespace": n => { kubernetesSecretEvidence.namespace = n.getObjectValue<KubernetesNamespaceEvidence>(createKubernetesNamespaceEvidenceFromDiscriminatorValue); },
        "secretType": n => { kubernetesSecretEvidence.secretType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesServiceAccountEvidence(kubernetesServiceAccountEvidence: Partial<KubernetesServiceAccountEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesServiceAccountEvidence),
        "name": n => { kubernetesServiceAccountEvidence.name = n.getStringValue(); },
        "namespace": n => { kubernetesServiceAccountEvidence.namespace = n.getObjectValue<KubernetesNamespaceEvidence>(createKubernetesNamespaceEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesServiceEvidence(kubernetesServiceEvidence: Partial<KubernetesServiceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesServiceEvidence),
        "clusterIP": n => { kubernetesServiceEvidence.clusterIP = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "externalIPs": n => { kubernetesServiceEvidence.externalIPs = n.getCollectionOfObjectValues<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "labels": n => { kubernetesServiceEvidence.labels = n.getObjectValue<Dictionary>(createDictionaryFromDiscriminatorValue); },
        "name": n => { kubernetesServiceEvidence.name = n.getStringValue(); },
        "namespace": n => { kubernetesServiceEvidence.namespace = n.getObjectValue<KubernetesNamespaceEvidence>(createKubernetesNamespaceEvidenceFromDiscriminatorValue); },
        "selector": n => { kubernetesServiceEvidence.selector = n.getObjectValue<Dictionary>(createDictionaryFromDiscriminatorValue); },
        "servicePorts": n => { kubernetesServiceEvidence.servicePorts = n.getCollectionOfObjectValues<KubernetesServicePort>(createKubernetesServicePortFromDiscriminatorValue); },
        "serviceType": n => { kubernetesServiceEvidence.serviceType = n.getEnumValue<KubernetesServiceType>(KubernetesServiceTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesServicePort(kubernetesServicePort: Partial<KubernetesServicePort> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "appProtocol": n => { kubernetesServicePort.appProtocol = n.getStringValue(); },
        "backingStoreEnabled": n => { kubernetesServicePort.backingStoreEnabled = true; },
        "name": n => { kubernetesServicePort.name = n.getStringValue(); },
        "nodePort": n => { kubernetesServicePort.nodePort = n.getNumberValue(); },
        "@odata.type": n => { kubernetesServicePort.odataType = n.getStringValue(); },
        "port": n => { kubernetesServicePort.port = n.getNumberValue(); },
        "protocol": n => { kubernetesServicePort.protocol = n.getEnumValue<ContainerPortProtocol>(ContainerPortProtocolObject); },
        "targetPort": n => { kubernetesServicePort.targetPort = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoLabelingOptions(labelingOptions: Partial<LabelingOptions> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "assignmentMethod": n => { labelingOptions.assignmentMethod = n.getEnumValue<AssignmentMethod>(AssignmentMethodObject); },
        "backingStoreEnabled": n => { labelingOptions.backingStoreEnabled = true; },
        "downgradeJustification": n => { labelingOptions.downgradeJustification = n.getObjectValue<DowngradeJustification>(createDowngradeJustificationFromDiscriminatorValue); },
        "extendedProperties": n => { labelingOptions.extendedProperties = n.getCollectionOfObjectValues<KeyValuePair>(createKeyValuePairFromDiscriminatorValue); },
        "labelId": n => { labelingOptions.labelId = n.getStringValue(); },
        "@odata.type": n => { labelingOptions.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoLabelsRoot(labelsRoot: Partial<LabelsRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(labelsRoot),
        "authorities": n => { labelsRoot.authorities = n.getCollectionOfObjectValues<AuthorityTemplate>(createAuthorityTemplateFromDiscriminatorValue); },
        "categories": n => { labelsRoot.categories = n.getCollectionOfObjectValues<CategoryTemplate>(createCategoryTemplateFromDiscriminatorValue); },
        "citations": n => { labelsRoot.citations = n.getCollectionOfObjectValues<CitationTemplate>(createCitationTemplateFromDiscriminatorValue); },
        "departments": n => { labelsRoot.departments = n.getCollectionOfObjectValues<DepartmentTemplate>(createDepartmentTemplateFromDiscriminatorValue); },
        "filePlanReferences": n => { labelsRoot.filePlanReferences = n.getCollectionOfObjectValues<FilePlanReferenceTemplate>(createFilePlanReferenceTemplateFromDiscriminatorValue); },
        "retentionLabels": n => { labelsRoot.retentionLabels = n.getCollectionOfObjectValues<RetentionLabel>(createRetentionLabelFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoLoggedOnUser(loggedOnUser: Partial<LoggedOnUser> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "accountName": n => { loggedOnUser.accountName = n.getStringValue(); },
        "backingStoreEnabled": n => { loggedOnUser.backingStoreEnabled = true; },
        "domainName": n => { loggedOnUser.domainName = n.getStringValue(); },
        "@odata.type": n => { loggedOnUser.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMailboxConfigurationEvidence(mailboxConfigurationEvidence: Partial<MailboxConfigurationEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(mailboxConfigurationEvidence),
        "configurationId": n => { mailboxConfigurationEvidence.configurationId = n.getStringValue(); },
        "configurationType": n => { mailboxConfigurationEvidence.configurationType = n.getEnumValue<MailboxConfigurationType>(MailboxConfigurationTypeObject); },
        "displayName": n => { mailboxConfigurationEvidence.displayName = n.getStringValue(); },
        "externalDirectoryObjectId": n => { mailboxConfigurationEvidence.externalDirectoryObjectId = n.getGuidValue(); },
        "mailboxPrimaryAddress": n => { mailboxConfigurationEvidence.mailboxPrimaryAddress = n.getStringValue(); },
        "upn": n => { mailboxConfigurationEvidence.upn = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMailboxEvidence(mailboxEvidence: Partial<MailboxEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(mailboxEvidence),
        "displayName": n => { mailboxEvidence.displayName = n.getStringValue(); },
        "primaryAddress": n => { mailboxEvidence.primaryAddress = n.getStringValue(); },
        "userAccount": n => { mailboxEvidence.userAccount = n.getObjectValue<UserAccount>(createUserAccountFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMailClusterEvidence(mailClusterEvidence: Partial<MailClusterEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(mailClusterEvidence),
        "clusterBy": n => { mailClusterEvidence.clusterBy = n.getStringValue(); },
        "clusterByValue": n => { mailClusterEvidence.clusterByValue = n.getStringValue(); },
        "emailCount": n => { mailClusterEvidence.emailCount = n.getNumberValue(); },
        "networkMessageIds": n => { mailClusterEvidence.networkMessageIds = n.getCollectionOfPrimitiveValues<string>(); },
        "query": n => { mailClusterEvidence.query = n.getStringValue(); },
        "urn": n => { mailClusterEvidence.urn = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMalwareEvidence(malwareEvidence: Partial<MalwareEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(malwareEvidence),
        "category": n => { malwareEvidence.category = n.getStringValue(); },
        "files": n => { malwareEvidence.files = n.getCollectionOfObjectValues<FileEvidence>(createFileEvidenceFromDiscriminatorValue); },
        "name": n => { malwareEvidence.name = n.getStringValue(); },
        "processes": n => { malwareEvidence.processes = n.getCollectionOfObjectValues<ProcessEvidence>(createProcessEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMarkUserAsCompromisedResponseAction(markUserAsCompromisedResponseAction: Partial<MarkUserAsCompromisedResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(markUserAsCompromisedResponseAction),
        "identifier": n => { markUserAsCompromisedResponseAction.identifier = n.getCollectionOfEnumValues<MarkUserAsCompromisedEntityIdentifier>(MarkUserAsCompromisedEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMetadataAction(metadataAction: Partial<MetadataAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(metadataAction),
        "metadataToAdd": n => { metadataAction.metadataToAdd = n.getCollectionOfObjectValues<KeyValuePair>(createKeyValuePairFromDiscriminatorValue); },
        "metadataToRemove": n => { metadataAction.metadataToRemove = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMoveToDeletedItemsResponseAction(moveToDeletedItemsResponseAction: Partial<MoveToDeletedItemsResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(moveToDeletedItemsResponseAction),
        "identifier": n => { moveToDeletedItemsResponseAction.identifier = n.getCollectionOfEnumValues<EmailEntityIdentifier>(EmailEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMoveToInboxResponseAction(moveToInboxResponseAction: Partial<MoveToInboxResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(moveToInboxResponseAction),
        "identifier": n => { moveToInboxResponseAction.identifier = n.getCollectionOfEnumValues<EmailEntityIdentifier>(EmailEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMoveToJunkResponseAction(moveToJunkResponseAction: Partial<MoveToJunkResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(moveToJunkResponseAction),
        "identifier": n => { moveToJunkResponseAction.identifier = n.getCollectionOfEnumValues<EmailEntityIdentifier>(EmailEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoNetworkAdapter(networkAdapter: Partial<NetworkAdapter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(networkAdapter),
        "isEnabled": n => { networkAdapter.isEnabled = n.getBooleanValue(); },
        "name": n => { networkAdapter.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoNetworkConnectionEvidence(networkConnectionEvidence: Partial<NetworkConnectionEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(networkConnectionEvidence),
        "destinationAddress": n => { networkConnectionEvidence.destinationAddress = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "destinationPort": n => { networkConnectionEvidence.destinationPort = n.getNumberValue(); },
        "protocol": n => { networkConnectionEvidence.protocol = n.getEnumValue<ProtocolType>(ProtocolTypeObject); },
        "sourceAddress": n => { networkConnectionEvidence.sourceAddress = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "sourcePort": n => { networkConnectionEvidence.sourcePort = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoNicEvidence(nicEvidence: Partial<NicEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(nicEvidence),
        "ipAddress": n => { nicEvidence.ipAddress = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "macAddress": n => { nicEvidence.macAddress = n.getStringValue(); },
        "vlans": n => { nicEvidence.vlans = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoOauthApplicationEvidence(oauthApplicationEvidence: Partial<OauthApplicationEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(oauthApplicationEvidence),
        "appId": n => { oauthApplicationEvidence.appId = n.getStringValue(); },
        "displayName": n => { oauthApplicationEvidence.displayName = n.getStringValue(); },
        "objectId": n => { oauthApplicationEvidence.objectId = n.getStringValue(); },
        "publisher": n => { oauthApplicationEvidence.publisher = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoOcrSettings(ocrSettings: Partial<OcrSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { ocrSettings.backingStoreEnabled = true; },
        "isEnabled": n => { ocrSettings.isEnabled = n.getBooleanValue(); },
        "maxImageSize": n => { ocrSettings.maxImageSize = n.getNumberValue(); },
        "@odata.type": n => { ocrSettings.odataType = n.getStringValue(); },
        "timeout": n => { ocrSettings.timeout = n.getDurationValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoOrganizationalScope(organizationalScope: Partial<OrganizationalScope> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { organizationalScope.backingStoreEnabled = true; },
        "@odata.type": n => { organizationalScope.odataType = n.getStringValue(); },
        "scopeNames": n => { organizationalScope.scopeNames = n.getCollectionOfPrimitiveValues<string>(); },
        "scopeType": n => { organizationalScope.scopeType = n.getEnumValue<ScopeType>(ScopeTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoPassiveDnsRecord(passiveDnsRecord: Partial<PassiveDnsRecord> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(passiveDnsRecord),
        "artifact": n => { passiveDnsRecord.artifact = n.getObjectValue<Artifact>(createArtifactFromDiscriminatorValue); },
        "collectedDateTime": n => { passiveDnsRecord.collectedDateTime = n.getDateValue(); },
        "firstSeenDateTime": n => { passiveDnsRecord.firstSeenDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { passiveDnsRecord.lastSeenDateTime = n.getDateValue(); },
        "parentHost": n => { passiveDnsRecord.parentHost = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "recordType": n => { passiveDnsRecord.recordType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoPassiveDnsRecordCollectionResponse(passiveDnsRecordCollectionResponse: Partial<PassiveDnsRecordCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(passiveDnsRecordCollectionResponse),
        "value": n => { passiveDnsRecordCollectionResponse.value = n.getCollectionOfObjectValues<PassiveDnsRecord>(createPassiveDnsRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoPolicyBase(policyBase: Partial<PolicyBase> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(policyBase),
        "createdBy": n => { policyBase.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { policyBase.createdDateTime = n.getDateValue(); },
        "description": n => { policyBase.description = n.getStringValue(); },
        "displayName": n => { policyBase.displayName = n.getStringValue(); },
        "lastModifiedBy": n => { policyBase.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { policyBase.lastModifiedDateTime = n.getDateValue(); },
        "status": n => { policyBase.status = n.getEnumValue<PolicyStatus>(PolicyStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProcessEvidence(processEvidence: Partial<ProcessEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(processEvidence),
        "detectionStatus": n => { processEvidence.detectionStatus = n.getEnumValue<DetectionStatus>(DetectionStatusObject); },
        "imageFile": n => { processEvidence.imageFile = n.getObjectValue<FileDetails>(createFileDetailsFromDiscriminatorValue); },
        "mdeDeviceId": n => { processEvidence.mdeDeviceId = n.getStringValue(); },
        "parentProcessCreationDateTime": n => { processEvidence.parentProcessCreationDateTime = n.getDateValue(); },
        "parentProcessId": n => { processEvidence.parentProcessId = n.getNumberValue(); },
        "parentProcessImageFile": n => { processEvidence.parentProcessImageFile = n.getObjectValue<FileDetails>(createFileDetailsFromDiscriminatorValue); },
        "processCommandLine": n => { processEvidence.processCommandLine = n.getStringValue(); },
        "processCreationDateTime": n => { processEvidence.processCreationDateTime = n.getDateValue(); },
        "processId": n => { processEvidence.processId = n.getNumberValue(); },
        "userAccount": n => { processEvidence.userAccount = n.getObjectValue<UserAccount>(createUserAccountFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProtectAdhocAction(protectAdhocAction: Partial<ProtectAdhocAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(protectAdhocAction),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProtectByTemplateAction(protectByTemplateAction: Partial<ProtectByTemplateAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(protectByTemplateAction),
        "templateId": n => { protectByTemplateAction.templateId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProtectDoNotForwardAction(protectDoNotForwardAction: Partial<ProtectDoNotForwardAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(protectDoNotForwardAction),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProtectionRule(protectionRule: Partial<ProtectionRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(protectionRule),
        "createdBy": n => { protectionRule.createdBy = n.getStringValue(); },
        "createdDateTime": n => { protectionRule.createdDateTime = n.getDateValue(); },
        "displayName": n => { protectionRule.displayName = n.getStringValue(); },
        "isEnabled": n => { protectionRule.isEnabled = n.getBooleanValue(); },
        "lastModifiedBy": n => { protectionRule.lastModifiedBy = n.getStringValue(); },
        "lastModifiedDateTime": n => { protectionRule.lastModifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoQueryCondition(queryCondition: Partial<QueryCondition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { queryCondition.backingStoreEnabled = true; },
        "lastModifiedDateTime": n => { queryCondition.lastModifiedDateTime = n.getDateValue(); },
        "@odata.type": n => { queryCondition.odataType = n.getStringValue(); },
        "queryText": n => { queryCondition.queryText = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRecommendedHuntingQuery(recommendedHuntingQuery: Partial<RecommendedHuntingQuery> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { recommendedHuntingQuery.backingStoreEnabled = true; },
        "kqlText": n => { recommendedHuntingQuery.kqlText = n.getStringValue(); },
        "@odata.type": n => { recommendedHuntingQuery.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRecommendLabelAction(recommendLabelAction: Partial<RecommendLabelAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(recommendLabelAction),
        "actions": n => { recommendLabelAction.actions = n.getCollectionOfObjectValues<InformationProtectionAction>(createInformationProtectionActionFromDiscriminatorValue); },
        "actionSource": n => { recommendLabelAction.actionSource = n.getEnumValue<ActionSource>(ActionSourceObject); },
        "responsibleSensitiveTypeIds": n => { recommendLabelAction.responsibleSensitiveTypeIds = n.getCollectionOfPrimitiveValues<string>(); },
        "sensitivityLabelId": n => { recommendLabelAction.sensitivityLabelId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRedundancyDetectionSettings(redundancyDetectionSettings: Partial<RedundancyDetectionSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { redundancyDetectionSettings.backingStoreEnabled = true; },
        "isEnabled": n => { redundancyDetectionSettings.isEnabled = n.getBooleanValue(); },
        "maxWords": n => { redundancyDetectionSettings.maxWords = n.getNumberValue(); },
        "minWords": n => { redundancyDetectionSettings.minWords = n.getNumberValue(); },
        "@odata.type": n => { redundancyDetectionSettings.odataType = n.getStringValue(); },
        "similarityThreshold": n => { redundancyDetectionSettings.similarityThreshold = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRegistryKeyEvidence(registryKeyEvidence: Partial<RegistryKeyEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(registryKeyEvidence),
        "registryHive": n => { registryKeyEvidence.registryHive = n.getStringValue(); },
        "registryKey": n => { registryKeyEvidence.registryKey = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRegistryValueEvidence(registryValueEvidence: Partial<RegistryValueEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(registryValueEvidence),
        "mdeDeviceId": n => { registryValueEvidence.mdeDeviceId = n.getStringValue(); },
        "registryHive": n => { registryValueEvidence.registryHive = n.getStringValue(); },
        "registryKey": n => { registryValueEvidence.registryKey = n.getStringValue(); },
        "registryValue": n => { registryValueEvidence.registryValue = n.getStringValue(); },
        "registryValueName": n => { registryValueEvidence.registryValueName = n.getStringValue(); },
        "registryValueType": n => { registryValueEvidence.registryValueType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRemoveContentFooterAction(removeContentFooterAction: Partial<RemoveContentFooterAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(removeContentFooterAction),
        "uiElementNames": n => { removeContentFooterAction.uiElementNames = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRemoveContentHeaderAction(removeContentHeaderAction: Partial<RemoveContentHeaderAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(removeContentHeaderAction),
        "uiElementNames": n => { removeContentHeaderAction.uiElementNames = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRemoveProtectionAction(removeProtectionAction: Partial<RemoveProtectionAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(removeProtectionAction),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRemoveWatermarkAction(removeWatermarkAction: Partial<RemoveWatermarkAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoInformationProtectionAction(removeWatermarkAction),
        "uiElementNames": n => { removeWatermarkAction.uiElementNames = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoResponseAction(responseAction: Partial<ResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { responseAction.backingStoreEnabled = true; },
        "@odata.type": n => { responseAction.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRestrictAppExecutionResponseAction(restrictAppExecutionResponseAction: Partial<RestrictAppExecutionResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(restrictAppExecutionResponseAction),
        "identifier": n => { restrictAppExecutionResponseAction.identifier = n.getCollectionOfEnumValues<DeviceIdEntityIdentifier>(DeviceIdEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionDuration(retentionDuration: Partial<RetentionDuration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { retentionDuration.backingStoreEnabled = true; },
        "@odata.type": n => { retentionDuration.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionDurationForever(retentionDurationForever: Partial<RetentionDurationForever> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRetentionDuration(retentionDurationForever),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionDurationInDays(retentionDurationInDays: Partial<RetentionDurationInDays> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRetentionDuration(retentionDurationInDays),
        "days": n => { retentionDurationInDays.days = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionEvent(retentionEvent: Partial<RetentionEvent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(retentionEvent),
        "createdBy": n => { retentionEvent.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { retentionEvent.createdDateTime = n.getDateValue(); },
        "description": n => { retentionEvent.description = n.getStringValue(); },
        "displayName": n => { retentionEvent.displayName = n.getStringValue(); },
        "eventPropagationResults": n => { retentionEvent.eventPropagationResults = n.getCollectionOfObjectValues<EventPropagationResult>(createEventPropagationResultFromDiscriminatorValue); },
        "eventQueries": n => { retentionEvent.eventQueries = n.getCollectionOfObjectValues<EventQuery>(createEventQueryFromDiscriminatorValue); },
        "eventStatus": n => { retentionEvent.eventStatus = n.getObjectValue<RetentionEventStatus>(createRetentionEventStatusFromDiscriminatorValue); },
        "eventTriggerDateTime": n => { retentionEvent.eventTriggerDateTime = n.getDateValue(); },
        "lastModifiedBy": n => { retentionEvent.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { retentionEvent.lastModifiedDateTime = n.getDateValue(); },
        "lastStatusUpdateDateTime": n => { retentionEvent.lastStatusUpdateDateTime = n.getDateValue(); },
        "retentionEventType": n => { retentionEvent.retentionEventType = n.getObjectValue<RetentionEventType>(createRetentionEventTypeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionEventCollectionResponse(retentionEventCollectionResponse: Partial<RetentionEventCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(retentionEventCollectionResponse),
        "value": n => { retentionEventCollectionResponse.value = n.getCollectionOfObjectValues<RetentionEvent>(createRetentionEventFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionEventStatus(retentionEventStatus: Partial<RetentionEventStatus> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { retentionEventStatus.backingStoreEnabled = true; },
        "error": n => { retentionEventStatus.errorEscaped = n.getObjectValue<PublicError>(createPublicErrorFromDiscriminatorValue); },
        "@odata.type": n => { retentionEventStatus.odataType = n.getStringValue(); },
        "status": n => { retentionEventStatus.status = n.getEnumValue<EventStatusType>(EventStatusTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionEventType(retentionEventType: Partial<RetentionEventType> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(retentionEventType),
        "createdBy": n => { retentionEventType.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { retentionEventType.createdDateTime = n.getDateValue(); },
        "description": n => { retentionEventType.description = n.getStringValue(); },
        "displayName": n => { retentionEventType.displayName = n.getStringValue(); },
        "lastModifiedBy": n => { retentionEventType.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { retentionEventType.lastModifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionEventTypeCollectionResponse(retentionEventTypeCollectionResponse: Partial<RetentionEventTypeCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(retentionEventTypeCollectionResponse),
        "value": n => { retentionEventTypeCollectionResponse.value = n.getCollectionOfObjectValues<RetentionEventType>(createRetentionEventTypeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionLabel(retentionLabel: Partial<RetentionLabel> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(retentionLabel),
        "actionAfterRetentionPeriod": n => { retentionLabel.actionAfterRetentionPeriod = n.getEnumValue<ActionAfterRetentionPeriod>(ActionAfterRetentionPeriodObject); },
        "behaviorDuringRetentionPeriod": n => { retentionLabel.behaviorDuringRetentionPeriod = n.getEnumValue<BehaviorDuringRetentionPeriod>(BehaviorDuringRetentionPeriodObject); },
        "createdBy": n => { retentionLabel.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { retentionLabel.createdDateTime = n.getDateValue(); },
        "defaultRecordBehavior": n => { retentionLabel.defaultRecordBehavior = n.getEnumValue<DefaultRecordBehavior>(DefaultRecordBehaviorObject); },
        "descriptionForAdmins": n => { retentionLabel.descriptionForAdmins = n.getStringValue(); },
        "descriptionForUsers": n => { retentionLabel.descriptionForUsers = n.getStringValue(); },
        "descriptors": n => { retentionLabel.descriptors = n.getObjectValue<FilePlanDescriptor>(createFilePlanDescriptorFromDiscriminatorValue); },
        "displayName": n => { retentionLabel.displayName = n.getStringValue(); },
        "dispositionReviewStages": n => { retentionLabel.dispositionReviewStages = n.getCollectionOfObjectValues<DispositionReviewStage>(createDispositionReviewStageFromDiscriminatorValue); },
        "isInUse": n => { retentionLabel.isInUse = n.getBooleanValue(); },
        "labelToBeApplied": n => { retentionLabel.labelToBeApplied = n.getStringValue(); },
        "lastModifiedBy": n => { retentionLabel.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { retentionLabel.lastModifiedDateTime = n.getDateValue(); },
        "retentionDuration": n => { retentionLabel.retentionDuration = n.getObjectValue<RetentionDuration>(createRetentionDurationFromDiscriminatorValue); },
        "retentionEventType": n => { retentionLabel.retentionEventType = n.getObjectValue<RetentionEventType>(createRetentionEventTypeFromDiscriminatorValue); },
        "retentionTrigger": n => { retentionLabel.retentionTrigger = n.getEnumValue<RetentionTrigger>(RetentionTriggerObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionLabelCollectionResponse(retentionLabelCollectionResponse: Partial<RetentionLabelCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(retentionLabelCollectionResponse),
        "value": n => { retentionLabelCollectionResponse.value = n.getCollectionOfObjectValues<RetentionLabel>(createRetentionLabelFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRuleSchedule(ruleSchedule: Partial<RuleSchedule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { ruleSchedule.backingStoreEnabled = true; },
        "nextRunDateTime": n => { ruleSchedule.nextRunDateTime = n.getDateValue(); },
        "@odata.type": n => { ruleSchedule.odataType = n.getStringValue(); },
        "period": n => { ruleSchedule.period = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRulesRoot(rulesRoot: Partial<RulesRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(rulesRoot),
        "detectionRules": n => { rulesRoot.detectionRules = n.getCollectionOfObjectValues<DetectionRule>(createDetectionRuleFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRunAntivirusScanResponseAction(runAntivirusScanResponseAction: Partial<RunAntivirusScanResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(runAntivirusScanResponseAction),
        "identifier": n => { runAntivirusScanResponseAction.identifier = n.getCollectionOfEnumValues<DeviceIdEntityIdentifier>(DeviceIdEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRunDetails(runDetails: Partial<RunDetails> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { runDetails.backingStoreEnabled = true; },
        "errorCode": n => { runDetails.errorCode = n.getEnumValue<HuntingRuleErrorCode>(HuntingRuleErrorCodeObject); },
        "failureReason": n => { runDetails.failureReason = n.getStringValue(); },
        "lastRunDateTime": n => { runDetails.lastRunDateTime = n.getDateValue(); },
        "@odata.type": n => { runDetails.odataType = n.getStringValue(); },
        "status": n => { runDetails.status = n.getEnumValue<HuntingRuleRunStatus>(HuntingRuleRunStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSasTokenEvidence(sasTokenEvidence: Partial<SasTokenEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(sasTokenEvidence),
        "allowedIpAddresses": n => { sasTokenEvidence.allowedIpAddresses = n.getStringValue(); },
        "allowedResourceTypes": n => { sasTokenEvidence.allowedResourceTypes = n.getCollectionOfPrimitiveValues<string>(); },
        "allowedServices": n => { sasTokenEvidence.allowedServices = n.getCollectionOfPrimitiveValues<string>(); },
        "expiryDateTime": n => { sasTokenEvidence.expiryDateTime = n.getDateValue(); },
        "permissions": n => { sasTokenEvidence.permissions = n.getCollectionOfPrimitiveValues<string>(); },
        "protocol": n => { sasTokenEvidence.protocol = n.getStringValue(); },
        "signatureHash": n => { sasTokenEvidence.signatureHash = n.getStringValue(); },
        "signedWith": n => { sasTokenEvidence.signedWith = n.getStringValue(); },
        "startDateTime": n => { sasTokenEvidence.startDateTime = n.getDateValue(); },
        "storageResource": n => { sasTokenEvidence.storageResource = n.getObjectValue<AzureResourceEvidence>(createAzureResourceEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSearch(search: Partial<Search> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(search),
        "contentQuery": n => { search.contentQuery = n.getStringValue(); },
        "createdBy": n => { search.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { search.createdDateTime = n.getDateValue(); },
        "description": n => { search.description = n.getStringValue(); },
        "displayName": n => { search.displayName = n.getStringValue(); },
        "lastModifiedBy": n => { search.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { search.lastModifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSecurity(security: Partial<Security> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(security),
        "informationProtection": n => { security.informationProtection = n.getObjectValue<InformationProtection>(createInformationProtectionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSecurityGroupEvidence(securityGroupEvidence: Partial<SecurityGroupEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(securityGroupEvidence),
        "displayName": n => { securityGroupEvidence.displayName = n.getStringValue(); },
        "securityGroupId": n => { securityGroupEvidence.securityGroupId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSensitivityLabel(sensitivityLabel: Partial<SensitivityLabel> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(sensitivityLabel),
        "color": n => { sensitivityLabel.color = n.getStringValue(); },
        "contentFormats": n => { sensitivityLabel.contentFormats = n.getCollectionOfPrimitiveValues<string>(); },
        "description": n => { sensitivityLabel.description = n.getStringValue(); },
        "hasProtection": n => { sensitivityLabel.hasProtection = n.getBooleanValue(); },
        "isActive": n => { sensitivityLabel.isActive = n.getBooleanValue(); },
        "isAppliable": n => { sensitivityLabel.isAppliable = n.getBooleanValue(); },
        "name": n => { sensitivityLabel.name = n.getStringValue(); },
        "parent": n => { sensitivityLabel.parent = n.getObjectValue<SensitivityLabel>(createSensitivityLabelFromDiscriminatorValue); },
        "sensitivity": n => { sensitivityLabel.sensitivity = n.getNumberValue(); },
        "tooltip": n => { sensitivityLabel.tooltip = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSensitivityLabelCollectionResponse(sensitivityLabelCollectionResponse: Partial<SensitivityLabelCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(sensitivityLabelCollectionResponse),
        "value": n => { sensitivityLabelCollectionResponse.value = n.getCollectionOfObjectValues<SensitivityLabel>(createSensitivityLabelFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSensor(sensor: Partial<Sensor> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(sensor),
        "createdDateTime": n => { sensor.createdDateTime = n.getDateValue(); },
        "deploymentStatus": n => { sensor.deploymentStatus = n.getEnumValue<DeploymentStatus>(DeploymentStatusObject); },
        "displayName": n => { sensor.displayName = n.getStringValue(); },
        "domainName": n => { sensor.domainName = n.getStringValue(); },
        "healthIssues": n => { sensor.healthIssues = n.getCollectionOfObjectValues<HealthIssue>(createHealthIssueFromDiscriminatorValue); },
        "healthStatus": n => { sensor.healthStatus = n.getEnumValue<SensorHealthStatus>(SensorHealthStatusObject); },
        "openHealthIssuesCount": n => { sensor.openHealthIssuesCount = n.getNumberValue(); },
        "sensorType": n => { sensor.sensorType = n.getEnumValue<SensorType>(SensorTypeObject); },
        "settings": n => { sensor.settings = n.getObjectValue<SensorSettings>(createSensorSettingsFromDiscriminatorValue); },
        "version": n => { sensor.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSensorCollectionResponse(sensorCollectionResponse: Partial<SensorCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(sensorCollectionResponse),
        "value": n => { sensorCollectionResponse.value = n.getCollectionOfObjectValues<Sensor>(createSensorFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSensorDeploymentPackage(sensorDeploymentPackage: Partial<SensorDeploymentPackage> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { sensorDeploymentPackage.backingStoreEnabled = true; },
        "downloadUrl": n => { sensorDeploymentPackage.downloadUrl = n.getStringValue(); },
        "@odata.type": n => { sensorDeploymentPackage.odataType = n.getStringValue(); },
        "version": n => { sensorDeploymentPackage.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSensorSettings(sensorSettings: Partial<SensorSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { sensorSettings.backingStoreEnabled = true; },
        "description": n => { sensorSettings.description = n.getStringValue(); },
        "domainControllerDnsNames": n => { sensorSettings.domainControllerDnsNames = n.getCollectionOfPrimitiveValues<string>(); },
        "isDelayedDeploymentEnabled": n => { sensorSettings.isDelayedDeploymentEnabled = n.getBooleanValue(); },
        "networkAdapters": n => { sensorSettings.networkAdapters = n.getCollectionOfObjectValues<NetworkAdapter>(createNetworkAdapterFromDiscriminatorValue); },
        "@odata.type": n => { sensorSettings.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoServicePrincipalEvidence(servicePrincipalEvidence: Partial<ServicePrincipalEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(servicePrincipalEvidence),
        "appId": n => { servicePrincipalEvidence.appId = n.getStringValue(); },
        "appOwnerTenantId": n => { servicePrincipalEvidence.appOwnerTenantId = n.getStringValue(); },
        "servicePrincipalName": n => { servicePrincipalEvidence.servicePrincipalName = n.getStringValue(); },
        "servicePrincipalObjectId": n => { servicePrincipalEvidence.servicePrincipalObjectId = n.getStringValue(); },
        "servicePrincipalType": n => { servicePrincipalEvidence.servicePrincipalType = n.getEnumValue<ServicePrincipalType>(ServicePrincipalTypeObject); },
        "tenantId": n => { servicePrincipalEvidence.tenantId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSinglePropertySchema(singlePropertySchema: Partial<SinglePropertySchema> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { singlePropertySchema.backingStoreEnabled = true; },
        "name": n => { singlePropertySchema.name = n.getStringValue(); },
        "@odata.type": n => { singlePropertySchema.odataType = n.getStringValue(); },
        "type": n => { singlePropertySchema.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSiteSource(siteSource: Partial<SiteSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(siteSource),
        "site": n => { siteSource.site = n.getObjectValue<Site>(createSiteFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSiteSourceCollectionResponse(siteSourceCollectionResponse: Partial<SiteSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(siteSourceCollectionResponse),
        "value": n => { siteSourceCollectionResponse.value = n.getCollectionOfObjectValues<SiteSource>(createSiteSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSoftDeleteResponseAction(softDeleteResponseAction: Partial<SoftDeleteResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(softDeleteResponseAction),
        "identifier": n => { softDeleteResponseAction.identifier = n.getCollectionOfEnumValues<EmailEntityIdentifier>(EmailEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSslCertificate(sslCertificate: Partial<SslCertificate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(sslCertificate),
        "expirationDateTime": n => { sslCertificate.expirationDateTime = n.getDateValue(); },
        "fingerprint": n => { sslCertificate.fingerprint = n.getStringValue(); },
        "firstSeenDateTime": n => { sslCertificate.firstSeenDateTime = n.getDateValue(); },
        "issueDateTime": n => { sslCertificate.issueDateTime = n.getDateValue(); },
        "issuer": n => { sslCertificate.issuer = n.getObjectValue<SslCertificateEntity>(createSslCertificateEntityFromDiscriminatorValue); },
        "lastSeenDateTime": n => { sslCertificate.lastSeenDateTime = n.getDateValue(); },
        "relatedHosts": n => { sslCertificate.relatedHosts = n.getCollectionOfObjectValues<Host>(createHostFromDiscriminatorValue); },
        "serialNumber": n => { sslCertificate.serialNumber = n.getStringValue(); },
        "sha1": n => { sslCertificate.sha1 = n.getStringValue(); },
        "subject": n => { sslCertificate.subject = n.getObjectValue<SslCertificateEntity>(createSslCertificateEntityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSslCertificateCollectionResponse(sslCertificateCollectionResponse: Partial<SslCertificateCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(sslCertificateCollectionResponse),
        "value": n => { sslCertificateCollectionResponse.value = n.getCollectionOfObjectValues<SslCertificate>(createSslCertificateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSslCertificateEntity(sslCertificateEntity: Partial<SslCertificateEntity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "address": n => { sslCertificateEntity.address = n.getObjectValue<PhysicalAddress>(createPhysicalAddressFromDiscriminatorValue); },
        "alternateNames": n => { sslCertificateEntity.alternateNames = n.getCollectionOfPrimitiveValues<string>(); },
        "backingStoreEnabled": n => { sslCertificateEntity.backingStoreEnabled = true; },
        "commonName": n => { sslCertificateEntity.commonName = n.getStringValue(); },
        "email": n => { sslCertificateEntity.email = n.getStringValue(); },
        "givenName": n => { sslCertificateEntity.givenName = n.getStringValue(); },
        "@odata.type": n => { sslCertificateEntity.odataType = n.getStringValue(); },
        "organizationName": n => { sslCertificateEntity.organizationName = n.getStringValue(); },
        "organizationUnitName": n => { sslCertificateEntity.organizationUnitName = n.getStringValue(); },
        "serialNumber": n => { sslCertificateEntity.serialNumber = n.getStringValue(); },
        "surname": n => { sslCertificateEntity.surname = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoStopAndQuarantineFileResponseAction(stopAndQuarantineFileResponseAction: Partial<StopAndQuarantineFileResponseAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResponseAction(stopAndQuarantineFileResponseAction),
        "identifier": n => { stopAndQuarantineFileResponseAction.identifier = n.getCollectionOfEnumValues<StopAndQuarantineFileEntityIdentifier>(StopAndQuarantineFileEntityIdentifierObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoStream(stream: Partial<Stream> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { stream.backingStoreEnabled = true; },
        "name": n => { stream.name = n.getStringValue(); },
        "@odata.type": n => { stream.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoStringValueDictionary(stringValueDictionary: Partial<StringValueDictionary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { stringValueDictionary.backingStoreEnabled = true; },
        "@odata.type": n => { stringValueDictionary.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubcategoryTemplate(subcategoryTemplate: Partial<SubcategoryTemplate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilePlanDescriptorTemplate(subcategoryTemplate),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubcategoryTemplateCollectionResponse(subcategoryTemplateCollectionResponse: Partial<SubcategoryTemplateCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(subcategoryTemplateCollectionResponse),
        "value": n => { subcategoryTemplateCollectionResponse.value = n.getCollectionOfObjectValues<SubcategoryTemplate>(createSubcategoryTemplateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubdomain(subdomain: Partial<Subdomain> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(subdomain),
        "firstSeenDateTime": n => { subdomain.firstSeenDateTime = n.getDateValue(); },
        "host": n => { subdomain.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubdomainCollectionResponse(subdomainCollectionResponse: Partial<SubdomainCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(subdomainCollectionResponse),
        "value": n => { subdomainCollectionResponse.value = n.getCollectionOfObjectValues<Subdomain>(createSubdomainFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubmissionAdminReview(submissionAdminReview: Partial<SubmissionAdminReview> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { submissionAdminReview.backingStoreEnabled = true; },
        "@odata.type": n => { submissionAdminReview.odataType = n.getStringValue(); },
        "reviewBy": n => { submissionAdminReview.reviewBy = n.getStringValue(); },
        "reviewDateTime": n => { submissionAdminReview.reviewDateTime = n.getDateValue(); },
        "reviewResult": n => { submissionAdminReview.reviewResult = n.getEnumValue<SubmissionResultCategory>(SubmissionResultCategoryObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubmissionDetectedFile(submissionDetectedFile: Partial<SubmissionDetectedFile> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { submissionDetectedFile.backingStoreEnabled = true; },
        "fileHash": n => { submissionDetectedFile.fileHash = n.getStringValue(); },
        "fileName": n => { submissionDetectedFile.fileName = n.getStringValue(); },
        "@odata.type": n => { submissionDetectedFile.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubmissionMailEvidence(submissionMailEvidence: Partial<SubmissionMailEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(submissionMailEvidence),
        "networkMessageId": n => { submissionMailEvidence.networkMessageId = n.getStringValue(); },
        "recipient": n => { submissionMailEvidence.recipient = n.getStringValue(); },
        "reportType": n => { submissionMailEvidence.reportType = n.getStringValue(); },
        "sender": n => { submissionMailEvidence.sender = n.getStringValue(); },
        "senderIp": n => { submissionMailEvidence.senderIp = n.getStringValue(); },
        "subject": n => { submissionMailEvidence.subject = n.getStringValue(); },
        "submissionDateTime": n => { submissionMailEvidence.submissionDateTime = n.getDateValue(); },
        "submissionId": n => { submissionMailEvidence.submissionId = n.getStringValue(); },
        "submitter": n => { submissionMailEvidence.submitter = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubmissionResult(submissionResult: Partial<SubmissionResult> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { submissionResult.backingStoreEnabled = true; },
        "category": n => { submissionResult.category = n.getEnumValue<SubmissionResultCategory>(SubmissionResultCategoryObject); },
        "detail": n => { submissionResult.detail = n.getEnumValue<SubmissionResultDetail>(SubmissionResultDetailObject); },
        "detectedFiles": n => { submissionResult.detectedFiles = n.getCollectionOfObjectValues<SubmissionDetectedFile>(createSubmissionDetectedFileFromDiscriminatorValue); },
        "detectedUrls": n => { submissionResult.detectedUrls = n.getCollectionOfPrimitiveValues<string>(); },
        "@odata.type": n => { submissionResult.odataType = n.getStringValue(); },
        "userMailboxSetting": n => { submissionResult.userMailboxSetting = n.getCollectionOfEnumValues<UserMailboxSetting>(UserMailboxSettingObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubmissionUserIdentity(submissionUserIdentity: Partial<SubmissionUserIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(submissionUserIdentity),
        "email": n => { submissionUserIdentity.email = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTag(tag: Partial<Tag> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(tag),
        "createdBy": n => { tag.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "description": n => { tag.description = n.getStringValue(); },
        "displayName": n => { tag.displayName = n.getStringValue(); },
        "lastModifiedDateTime": n => { tag.lastModifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTenantAllowBlockListEntryResult(tenantAllowBlockListEntryResult: Partial<TenantAllowBlockListEntryResult> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { tenantAllowBlockListEntryResult.backingStoreEnabled = true; },
        "entryType": n => { tenantAllowBlockListEntryResult.entryType = n.getEnumValue<TenantAllowBlockListEntryType>(TenantAllowBlockListEntryTypeObject); },
        "expirationDateTime": n => { tenantAllowBlockListEntryResult.expirationDateTime = n.getDateValue(); },
        "identity": n => { tenantAllowBlockListEntryResult.identity = n.getStringValue(); },
        "@odata.type": n => { tenantAllowBlockListEntryResult.odataType = n.getStringValue(); },
        "status": n => { tenantAllowBlockListEntryResult.status = n.getEnumValue<LongRunningOperationStatus>(LongRunningOperationStatusObject); },
        "value": n => { tenantAllowBlockListEntryResult.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTenantAllowOrBlockListAction(tenantAllowOrBlockListAction: Partial<TenantAllowOrBlockListAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "action": n => { tenantAllowOrBlockListAction.action = n.getEnumValue<TenantAllowBlockListAction>(TenantAllowBlockListActionObject); },
        "backingStoreEnabled": n => { tenantAllowOrBlockListAction.backingStoreEnabled = true; },
        "expirationDateTime": n => { tenantAllowOrBlockListAction.expirationDateTime = n.getDateValue(); },
        "note": n => { tenantAllowOrBlockListAction.note = n.getStringValue(); },
        "@odata.type": n => { tenantAllowOrBlockListAction.odataType = n.getStringValue(); },
        "results": n => { tenantAllowOrBlockListAction.results = n.getCollectionOfObjectValues<TenantAllowBlockListEntryResult>(createTenantAllowBlockListEntryResultFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoThreatIntelligence(threatIntelligence: Partial<ThreatIntelligence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(threatIntelligence),
        "articleIndicators": n => { threatIntelligence.articleIndicators = n.getCollectionOfObjectValues<ArticleIndicator>(createArticleIndicatorFromDiscriminatorValue); },
        "articles": n => { threatIntelligence.articles = n.getCollectionOfObjectValues<Article>(createArticleFromDiscriminatorValue); },
        "hostComponents": n => { threatIntelligence.hostComponents = n.getCollectionOfObjectValues<HostComponent>(createHostComponentFromDiscriminatorValue); },
        "hostCookies": n => { threatIntelligence.hostCookies = n.getCollectionOfObjectValues<HostCookie>(createHostCookieFromDiscriminatorValue); },
        "hostPairs": n => { threatIntelligence.hostPairs = n.getCollectionOfObjectValues<HostPair>(createHostPairFromDiscriminatorValue); },
        "hostPorts": n => { threatIntelligence.hostPorts = n.getCollectionOfObjectValues<HostPort>(createHostPortFromDiscriminatorValue); },
        "hosts": n => { threatIntelligence.hosts = n.getCollectionOfObjectValues<Host>(createHostFromDiscriminatorValue); },
        "hostSslCertificates": n => { threatIntelligence.hostSslCertificates = n.getCollectionOfObjectValues<HostSslCertificate>(createHostSslCertificateFromDiscriminatorValue); },
        "hostTrackers": n => { threatIntelligence.hostTrackers = n.getCollectionOfObjectValues<HostTracker>(createHostTrackerFromDiscriminatorValue); },
        "intelligenceProfileIndicators": n => { threatIntelligence.intelligenceProfileIndicators = n.getCollectionOfObjectValues<IntelligenceProfileIndicator>(createIntelligenceProfileIndicatorFromDiscriminatorValue); },
        "intelProfiles": n => { threatIntelligence.intelProfiles = n.getCollectionOfObjectValues<IntelligenceProfile>(createIntelligenceProfileFromDiscriminatorValue); },
        "passiveDnsRecords": n => { threatIntelligence.passiveDnsRecords = n.getCollectionOfObjectValues<PassiveDnsRecord>(createPassiveDnsRecordFromDiscriminatorValue); },
        "sslCertificates": n => { threatIntelligence.sslCertificates = n.getCollectionOfObjectValues<SslCertificate>(createSslCertificateFromDiscriminatorValue); },
        "subdomains": n => { threatIntelligence.subdomains = n.getCollectionOfObjectValues<Subdomain>(createSubdomainFromDiscriminatorValue); },
        "vulnerabilities": n => { threatIntelligence.vulnerabilities = n.getCollectionOfObjectValues<Vulnerability>(createVulnerabilityFromDiscriminatorValue); },
        "whoisHistoryRecords": n => { threatIntelligence.whoisHistoryRecords = n.getCollectionOfObjectValues<WhoisHistoryRecord>(createWhoisHistoryRecordFromDiscriminatorValue); },
        "whoisRecords": n => { threatIntelligence.whoisRecords = n.getCollectionOfObjectValues<WhoisRecord>(createWhoisRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoThreatSubmission(threatSubmission: Partial<ThreatSubmission> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(threatSubmission),
        "adminReview": n => { threatSubmission.adminReview = n.getObjectValue<SubmissionAdminReview>(createSubmissionAdminReviewFromDiscriminatorValue); },
        "category": n => { threatSubmission.category = n.getEnumValue<SubmissionCategory>(SubmissionCategoryObject); },
        "clientSource": n => { threatSubmission.clientSource = n.getEnumValue<SubmissionClientSource>(SubmissionClientSourceObject); },
        "contentType": n => { threatSubmission.contentType = n.getEnumValue<SubmissionContentType>(SubmissionContentTypeObject); },
        "createdBy": n => { threatSubmission.createdBy = n.getObjectValue<SubmissionUserIdentity>(createSubmissionUserIdentityFromDiscriminatorValue); },
        "createdDateTime": n => { threatSubmission.createdDateTime = n.getDateValue(); },
        "result": n => { threatSubmission.result = n.getObjectValue<SubmissionResult>(createSubmissionResultFromDiscriminatorValue); },
        "source": n => { threatSubmission.source = n.getEnumValue<SubmissionSource>(SubmissionSourceObject); },
        "status": n => { threatSubmission.status = n.getEnumValue<LongRunningOperationStatus>(LongRunningOperationStatusObject); },
        "tenantId": n => { threatSubmission.tenantId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoThreatSubmissionRoot(threatSubmissionRoot: Partial<ThreatSubmissionRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(threatSubmissionRoot),
        "emailThreats": n => { threatSubmissionRoot.emailThreats = n.getCollectionOfObjectValues<EmailThreatSubmission>(createEmailThreatSubmissionFromDiscriminatorValue); },
        "emailThreatSubmissionPolicies": n => { threatSubmissionRoot.emailThreatSubmissionPolicies = n.getCollectionOfObjectValues<EmailThreatSubmissionPolicy>(createEmailThreatSubmissionPolicyFromDiscriminatorValue); },
        "fileThreats": n => { threatSubmissionRoot.fileThreats = n.getCollectionOfObjectValues<FileThreatSubmission>(createFileThreatSubmissionFromDiscriminatorValue); },
        "urlThreats": n => { threatSubmissionRoot.urlThreats = n.getCollectionOfObjectValues<UrlThreatSubmission>(createUrlThreatSubmissionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTopicModelingSettings(topicModelingSettings: Partial<TopicModelingSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { topicModelingSettings.backingStoreEnabled = true; },
        "dynamicallyAdjustTopicCount": n => { topicModelingSettings.dynamicallyAdjustTopicCount = n.getBooleanValue(); },
        "ignoreNumbers": n => { topicModelingSettings.ignoreNumbers = n.getBooleanValue(); },
        "isEnabled": n => { topicModelingSettings.isEnabled = n.getBooleanValue(); },
        "@odata.type": n => { topicModelingSettings.odataType = n.getStringValue(); },
        "topicCount": n => { topicModelingSettings.topicCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTriggersRoot(triggersRoot: Partial<TriggersRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(triggersRoot),
        "retentionEvents": n => { triggersRoot.retentionEvents = n.getCollectionOfObjectValues<RetentionEvent>(createRetentionEventFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTriggerTypesRoot(triggerTypesRoot: Partial<TriggerTypesRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(triggerTypesRoot),
        "retentionEventTypes": n => { triggerTypesRoot.retentionEventTypes = n.getCollectionOfObjectValues<RetentionEventType>(createRetentionEventTypeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUnclassifiedArtifact(unclassifiedArtifact: Partial<UnclassifiedArtifact> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(unclassifiedArtifact),
        "kind": n => { unclassifiedArtifact.kind = n.getStringValue(); },
        "value": n => { unclassifiedArtifact.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUnifiedGroupSource(unifiedGroupSource: Partial<UnifiedGroupSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(unifiedGroupSource),
        "group": n => { unifiedGroupSource.group = n.getObjectValue<Group>(createGroupFromDiscriminatorValue); },
        "includedSources": n => { unifiedGroupSource.includedSources = n.getCollectionOfEnumValues<SourceType>(SourceTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUnifiedGroupSourceCollectionResponse(unifiedGroupSourceCollectionResponse: Partial<UnifiedGroupSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(unifiedGroupSourceCollectionResponse),
        "value": n => { unifiedGroupSourceCollectionResponse.value = n.getCollectionOfObjectValues<UnifiedGroupSource>(createUnifiedGroupSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUrlEvidence(urlEvidence: Partial<UrlEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(urlEvidence),
        "url": n => { urlEvidence.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUrlThreatSubmission(urlThreatSubmission: Partial<UrlThreatSubmission> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoThreatSubmission(urlThreatSubmission),
        "webUrl": n => { urlThreatSubmission.webUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUrlThreatSubmissionCollectionResponse(urlThreatSubmissionCollectionResponse: Partial<UrlThreatSubmissionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(urlThreatSubmissionCollectionResponse),
        "value": n => { urlThreatSubmissionCollectionResponse.value = n.getCollectionOfObjectValues<UrlThreatSubmission>(createUrlThreatSubmissionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserAccount(userAccount: Partial<UserAccount> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "accountName": n => { userAccount.accountName = n.getStringValue(); },
        "azureAdUserId": n => { userAccount.azureAdUserId = n.getStringValue(); },
        "backingStoreEnabled": n => { userAccount.backingStoreEnabled = true; },
        "displayName": n => { userAccount.displayName = n.getStringValue(); },
        "domainName": n => { userAccount.domainName = n.getStringValue(); },
        "@odata.type": n => { userAccount.odataType = n.getStringValue(); },
        "userPrincipalName": n => { userAccount.userPrincipalName = n.getStringValue(); },
        "userSid": n => { userAccount.userSid = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserEvidence(userEvidence: Partial<UserEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(userEvidence),
        "stream": n => { userEvidence.stream = n.getObjectValue<Stream>(createStreamFromDiscriminatorValue); },
        "userAccount": n => { userEvidence.userAccount = n.getObjectValue<UserAccount>(createUserAccountFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserSource(userSource: Partial<UserSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(userSource),
        "email": n => { userSource.email = n.getStringValue(); },
        "includedSources": n => { userSource.includedSources = n.getCollectionOfEnumValues<SourceType>(SourceTypeObject); },
        "siteWebUrl": n => { userSource.siteWebUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserSourceCollectionResponse(userSourceCollectionResponse: Partial<UserSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(userSourceCollectionResponse),
        "value": n => { userSourceCollectionResponse.value = n.getCollectionOfObjectValues<UserSource>(createUserSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoVmMetadata(vmMetadata: Partial<VmMetadata> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { vmMetadata.backingStoreEnabled = true; },
        "cloudProvider": n => { vmMetadata.cloudProvider = n.getEnumValue<VmCloudProvider>(VmCloudProviderObject); },
        "@odata.type": n => { vmMetadata.odataType = n.getStringValue(); },
        "resourceId": n => { vmMetadata.resourceId = n.getStringValue(); },
        "subscriptionId": n => { vmMetadata.subscriptionId = n.getStringValue(); },
        "vmId": n => { vmMetadata.vmId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoVulnerability(vulnerability: Partial<Vulnerability> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(vulnerability),
        "activeExploitsObserved": n => { vulnerability.activeExploitsObserved = n.getBooleanValue(); },
        "articles": n => { vulnerability.articles = n.getCollectionOfObjectValues<Article>(createArticleFromDiscriminatorValue); },
        "commonWeaknessEnumerationIds": n => { vulnerability.commonWeaknessEnumerationIds = n.getCollectionOfPrimitiveValues<string>(); },
        "components": n => { vulnerability.components = n.getCollectionOfObjectValues<VulnerabilityComponent>(createVulnerabilityComponentFromDiscriminatorValue); },
        "createdDateTime": n => { vulnerability.createdDateTime = n.getDateValue(); },
        "cvss2Summary": n => { vulnerability.cvss2Summary = n.getObjectValue<CvssSummary>(createCvssSummaryFromDiscriminatorValue); },
        "cvss3Summary": n => { vulnerability.cvss3Summary = n.getObjectValue<CvssSummary>(createCvssSummaryFromDiscriminatorValue); },
        "description": n => { vulnerability.description = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "exploits": n => { vulnerability.exploits = n.getCollectionOfObjectValues<Hyperlink>(createHyperlinkFromDiscriminatorValue); },
        "exploitsAvailable": n => { vulnerability.exploitsAvailable = n.getBooleanValue(); },
        "hasChatter": n => { vulnerability.hasChatter = n.getBooleanValue(); },
        "lastModifiedDateTime": n => { vulnerability.lastModifiedDateTime = n.getDateValue(); },
        "priorityScore": n => { vulnerability.priorityScore = n.getNumberValue(); },
        "publishedDateTime": n => { vulnerability.publishedDateTime = n.getDateValue(); },
        "references": n => { vulnerability.references = n.getCollectionOfObjectValues<Hyperlink>(createHyperlinkFromDiscriminatorValue); },
        "remediation": n => { vulnerability.remediation = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "severity": n => { vulnerability.severity = n.getEnumValue<VulnerabilitySeverity>(VulnerabilitySeverityObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoVulnerabilityCollectionResponse(vulnerabilityCollectionResponse: Partial<VulnerabilityCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(vulnerabilityCollectionResponse),
        "value": n => { vulnerabilityCollectionResponse.value = n.getCollectionOfObjectValues<Vulnerability>(createVulnerabilityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoVulnerabilityComponent(vulnerabilityComponent: Partial<VulnerabilityComponent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(vulnerabilityComponent),
        "name": n => { vulnerabilityComponent.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoVulnerabilityComponentCollectionResponse(vulnerabilityComponentCollectionResponse: Partial<VulnerabilityComponentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(vulnerabilityComponentCollectionResponse),
        "value": n => { vulnerabilityComponentCollectionResponse.value = n.getCollectionOfObjectValues<VulnerabilityComponent>(createVulnerabilityComponentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisBaseRecord(whoisBaseRecord: Partial<WhoisBaseRecord> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(whoisBaseRecord),
        "abuse": n => { whoisBaseRecord.abuse = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "admin": n => { whoisBaseRecord.admin = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "billing": n => { whoisBaseRecord.billing = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "domainStatus": n => { whoisBaseRecord.domainStatus = n.getStringValue(); },
        "expirationDateTime": n => { whoisBaseRecord.expirationDateTime = n.getDateValue(); },
        "firstSeenDateTime": n => { whoisBaseRecord.firstSeenDateTime = n.getDateValue(); },
        "host": n => { whoisBaseRecord.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastSeenDateTime": n => { whoisBaseRecord.lastSeenDateTime = n.getDateValue(); },
        "lastUpdateDateTime": n => { whoisBaseRecord.lastUpdateDateTime = n.getDateValue(); },
        "nameservers": n => { whoisBaseRecord.nameservers = n.getCollectionOfObjectValues<WhoisNameserver>(createWhoisNameserverFromDiscriminatorValue); },
        "noc": n => { whoisBaseRecord.noc = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "rawWhoisText": n => { whoisBaseRecord.rawWhoisText = n.getStringValue(); },
        "registrant": n => { whoisBaseRecord.registrant = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "registrar": n => { whoisBaseRecord.registrar = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "registrationDateTime": n => { whoisBaseRecord.registrationDateTime = n.getDateValue(); },
        "technical": n => { whoisBaseRecord.technical = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "whoisServer": n => { whoisBaseRecord.whoisServer = n.getStringValue(); },
        "zone": n => { whoisBaseRecord.zone = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisContact(whoisContact: Partial<WhoisContact> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "address": n => { whoisContact.address = n.getObjectValue<PhysicalAddress>(createPhysicalAddressFromDiscriminatorValue); },
        "backingStoreEnabled": n => { whoisContact.backingStoreEnabled = true; },
        "email": n => { whoisContact.email = n.getStringValue(); },
        "fax": n => { whoisContact.fax = n.getStringValue(); },
        "name": n => { whoisContact.name = n.getStringValue(); },
        "@odata.type": n => { whoisContact.odataType = n.getStringValue(); },
        "organization": n => { whoisContact.organization = n.getStringValue(); },
        "telephone": n => { whoisContact.telephone = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisHistoryRecord(whoisHistoryRecord: Partial<WhoisHistoryRecord> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWhoisBaseRecord(whoisHistoryRecord),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisHistoryRecordCollectionResponse(whoisHistoryRecordCollectionResponse: Partial<WhoisHistoryRecordCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(whoisHistoryRecordCollectionResponse),
        "value": n => { whoisHistoryRecordCollectionResponse.value = n.getCollectionOfObjectValues<WhoisHistoryRecord>(createWhoisHistoryRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisNameserver(whoisNameserver: Partial<WhoisNameserver> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { whoisNameserver.backingStoreEnabled = true; },
        "firstSeenDateTime": n => { whoisNameserver.firstSeenDateTime = n.getDateValue(); },
        "host": n => { whoisNameserver.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastSeenDateTime": n => { whoisNameserver.lastSeenDateTime = n.getDateValue(); },
        "@odata.type": n => { whoisNameserver.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisRecord(whoisRecord: Partial<WhoisRecord> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWhoisBaseRecord(whoisRecord),
        "history": n => { whoisRecord.history = n.getCollectionOfObjectValues<WhoisHistoryRecord>(createWhoisHistoryRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisRecordCollectionResponse(whoisRecordCollectionResponse: Partial<WhoisRecordCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(whoisRecordCollectionResponse),
        "value": n => { whoisRecordCollectionResponse.value = n.getCollectionOfObjectValues<WhoisRecord>(createWhoisRecordFromDiscriminatorValue); },
    }
}
export interface DetectionAction extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The alertTemplate property
     */
    alertTemplate?: AlertTemplate;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Groups to which the custom detection rule applies.
     */
    organizationalScope?: OrganizationalScope;
    /**
     * Actions taken on impacted assets as set in the custom detection rule.
     */
    responseActions?: ResponseAction[];
}
export interface DetectionRule extends Parsable, ProtectionRule {
    /**
     * Complex type representing the actions taken when a detection is made by this rule.
     */
    detectionAction?: DetectionAction;
    /**
     * The ID of the detector that triggered the alert. Also see the 'detectorId' field in microsoft.graph.security.alert.
     */
    detectorId?: string;
    /**
     * Complex type holding details about the last run of this rule.
     */
    lastRunDetails?: RunDetails;
    /**
     * Complex type holding data about the advanced hunting query of this rule.
     */
    queryCondition?: QueryCondition;
    /**
     * Complex type holding data about the triggering schedule of this rule.
     */
    schedule?: RuleSchedule;
}
export interface DetectionRuleCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: DetectionRule[];
}
export type DetectionSource = (typeof DetectionSourceObject)[keyof typeof DetectionSourceObject];
export type DetectionStatus = (typeof DetectionStatusObject)[keyof typeof DetectionStatusObject];
export interface DetonationChain extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * A list of all child nodes in the chain.
     */
    childNodes?: DetonationChain[];
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The value of the chain.
     */
    value?: string;
}
export interface DetonationDetails extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The time of detonation.
     */
    analysisDateTime?: Date;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The chain of detonation.
     */
    detonationChain?: DetonationChain;
    /**
     * All observables in the detonation tree.
     */
    detonationObservables?: DetonationObservables;
    /**
     * The verdict of the detonation.
     */
    detonationVerdict?: string;
    /**
     * The reason for the verdict of the detonation.
     */
    detonationVerdictReason?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface DetonationObservables extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The list of all contacted IPs in the detonation.
     */
    contactedIps?: string[];
    /**
     * The list of all URLs found in the detonation.
     */
    contactedUrls?: string[];
    /**
     * The list of all dropped files in the detonation.
     */
    droppedfiles?: string[];
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type DeviceAssetIdentifier = (typeof DeviceAssetIdentifierObject)[keyof typeof DeviceAssetIdentifierObject];
export interface DeviceEvidence extends AlertEvidence, Parsable {
    /**
     * A unique identifier assigned to a device by Microsoft Entra ID when device is Microsoft Entra joined.
     */
    azureAdDeviceId?: string;
    /**
     * State of the Defender AntiMalware engine. The possible values are: notReporting, disabled, notUpdated, updated, unknown, notSupported, unknownFutureValue.
     */
    defenderAvStatus?: DefenderAvStatus;
    /**
     * The fully qualified domain name (FQDN) for the device.
     */
    deviceDnsName?: string;
    /**
     * The date and time when the device was first seen.
     */
    firstSeenDateTime?: Date;
    /**
     * The health state of the device. The possible values are: active, inactive, impairedCommunication, noSensorData, noSensorDataImpairedCommunication, unknown, unknownFutureValue.
     */
    healthStatus?: DeviceHealthStatus;
    /**
     * Ip interfaces of the device during the time of the alert.
     */
    ipInterfaces?: string[];
    /**
     * The lastExternalIpAddress property
     */
    lastExternalIpAddress?: string;
    /**
     * The lastIpAddress property
     */
    lastIpAddress?: string;
    /**
     * Users that were logged on the machine during the time of the alert.
     */
    loggedOnUsers?: LoggedOnUser[];
    /**
     * A unique identifier assigned to a device by Microsoft Defender for Endpoint.
     */
    mdeDeviceId?: string;
    /**
     * The status of the machine onboarding to Microsoft Defender for Endpoint. The possible values are: insufficientInfo, onboarded, canBeOnboarded, unsupported, unknownFutureValue.
     */
    onboardingStatus?: OnboardingStatus;
    /**
     * The build version for the operating system the device is running.
     */
    osBuild?: number;
    /**
     * The operating system platform the device is running.
     */
    osPlatform?: string;
    /**
     * The ID of the role-based access control device group.
     */
    rbacGroupId?: number;
    /**
     * The name of the role-based access control device group.
     */
    rbacGroupName?: string;
    /**
     * Risk score as evaluated by Microsoft Defender for Endpoint. The possible values are: none, informational, low, medium, high, unknownFutureValue.
     */
    riskScore?: DeviceRiskScore;
    /**
     * The version of the operating system platform.
     */
    version?: string;
    /**
     * Metadata of the virtual machine (VM) on which Microsoft Defender for Endpoint is running.
     */
    vmMetadata?: VmMetadata;
}
export type DeviceHealthStatus = (typeof DeviceHealthStatusObject)[keyof typeof DeviceHealthStatusObject];
export type DeviceIdEntityIdentifier = (typeof DeviceIdEntityIdentifierObject)[keyof typeof DeviceIdEntityIdentifierObject];
export type DeviceRiskScore = (typeof DeviceRiskScoreObject)[keyof typeof DeviceRiskScoreObject];
export interface Dictionary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type DisableUserEntityIdentifier = (typeof DisableUserEntityIdentifierObject)[keyof typeof DisableUserEntityIdentifierObject];
export interface DisableUserResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: DisableUserEntityIdentifier[];
}
export interface DispositionReviewStage extends Entity, Parsable {
    /**
     * Name representing each stage within a collection.
     */
    name?: string;
    /**
     * A collection of reviewers at each stage.
     */
    reviewersEmailAddresses?: string[];
    /**
     * The unique sequence number for each stage of the disposition review.
     */
    stageNumber?: string;
}
export interface DispositionReviewStageCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: DispositionReviewStage[];
}
export interface DnsEvidence extends AlertEvidence, Parsable {
    /**
     * The dnsServerIp property
     */
    dnsServerIp?: IpEvidence;
    /**
     * The domainName property
     */
    domainName?: string;
    /**
     * The hostIpAddress property
     */
    hostIpAddress?: IpEvidence;
    /**
     * The ipAddresses property
     */
    ipAddresses?: IpEvidence[];
}
export interface DowngradeJustification extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Indicates whether the downgrade is or isn't justified.
     */
    isDowngradeJustified?: boolean;
    /**
     * Message that indicates why a downgrade is justified. The message appears in administrative logs.
     */
    justificationMessage?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface EdiscoveryAddToReviewSetOperation extends CaseOperation, Parsable {
    /**
     * eDiscovery review set to which items matching source collection query gets added.
     */
    reviewSet?: EdiscoveryReviewSet;
    /**
     * eDiscovery search that gets added to review set.
     */
    search?: EdiscoverySearch;
}
export interface EdiscoveryCase extends CaseEscaped, Parsable {
    /**
     * The user who closed the case.
     */
    closedBy?: IdentitySet;
    /**
     * The date and time when the case was closed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    closedDateTime?: Date;
    /**
     * Returns a list of case ediscoveryCustodian objects for this case.
     */
    custodians?: EdiscoveryCustodian[];
    /**
     * The external case number for customer reference.
     */
    externalId?: string;
    /**
     * Returns a list of case eDiscoveryHoldPolicy objects for this case.
     */
    legalHolds?: EdiscoveryHoldPolicy[];
    /**
     * Returns a list of case ediscoveryNoncustodialDataSource objects for this case.
     */
    noncustodialDataSources?: EdiscoveryNoncustodialDataSource[];
    /**
     * Returns a list of case caseOperation objects for this case.
     */
    operations?: CaseOperation[];
    /**
     * Returns a list of eDiscoveryReviewSet objects in the case.
     */
    reviewSets?: EdiscoveryReviewSet[];
    /**
     * Returns a list of eDiscoverySearch objects associated with this case.
     */
    searches?: EdiscoverySearch[];
    /**
     * Returns a list of eDIscoverySettings objects in the case.
     */
    settings?: EdiscoveryCaseSettings;
    /**
     * Returns a list of ediscoveryReviewTag objects associated to this case.
     */
    tags?: EdiscoveryReviewTag[];
}
export interface EdiscoveryCaseCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryCase[];
}
export interface EdiscoveryCaseSettings extends Entity, Parsable {
    /**
     * The OCR (Optical Character Recognition) settings for the case.
     */
    ocr?: OcrSettings;
    /**
     * The redundancy (near duplicate and email threading) detection settings for the case.
     */
    redundancyDetection?: RedundancyDetectionSettings;
    /**
     * The Topic Modeling (Themes) settings for the case.
     */
    topicModeling?: TopicModelingSettings;
}
export interface EdiscoveryCustodian extends DataSourceContainer, Parsable {
    /**
     * Date and time the custodian acknowledged a hold notification.
     */
    acknowledgedDateTime?: Date;
    /**
     * Email address of the custodian.
     */
    email?: string;
    /**
     * Operation entity that represents the latest indexing for the custodian.
     */
    lastIndexOperation?: EdiscoveryIndexOperation;
    /**
     * Data source entity for SharePoint sites associated with the custodian.
     */
    siteSources?: SiteSource[];
    /**
     * Data source entity for groups associated with the custodian.
     */
    unifiedGroupSources?: UnifiedGroupSource[];
    /**
     * Data source entity for a custodian. This is the container for a custodian's mailbox and OneDrive for Business site.
     */
    userSources?: UserSource[];
}
export interface EdiscoveryCustodianCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryCustodian[];
}
export interface EdiscoveryEstimateOperation extends CaseOperation, Parsable {
    /**
     * The estimated count of items for the search that matched the content query.
     */
    indexedItemCount?: number;
    /**
     * The estimated size of items for the search that matched the content query.
     */
    indexedItemsSize?: number;
    /**
     * The number of mailboxes that had search hits.
     */
    mailboxCount?: number;
    /**
     * eDiscovery search.
     */
    search?: EdiscoverySearch;
    /**
     * The number of mailboxes that had search hits.
     */
    siteCount?: number;
    /**
     * The estimated count of unindexed items for the collection.
     */
    unindexedItemCount?: number;
    /**
     * The estimated size of unindexed items for the collection.
     */
    unindexedItemsSize?: number;
}
export interface EdiscoveryExportOperation extends CaseOperation, Parsable {
    /**
     * The name of the Azure storage location where the export is stored. This only applies to exports stored in your own Azure storage location. The azureBlobContainer property is deprecated and will stop returning data on April 30th, 2023.
     */
    azureBlobContainer?: string;
    /**
     * The SAS token for the Azure storage location.  This only applies to exports stored in your own Azure storage location. The azureBlobToken property is deprecated and will stop returning data on April 30, 2023.
     */
    azureBlobToken?: string;
    /**
     * The description provided for the export.
     */
    description?: string;
    /**
     * Contains the properties for an export file metadata, including downloadUrl, fileName, and size. If you export to an Azure storage location, this property returns empty.
     */
    exportFileMetadata?: ExportFileMetadata[];
    /**
     * The options provided for the export. For more information, see reviewSet: export. Possible values are: originalFiles, text, pdfReplacement, fileInfo, tags. The fileInfo member is deprecated and will stop returning data on April 30, 2023. Going forward, the summary and load file are always included.
     */
    exportOptions?: ExportOptions[];
    /**
     * The options provided that specify the structure of the export. For more information, see reviewSet: export. Possible values are: none, directory, pst.
     */
    exportStructure?: ExportFileStructure;
    /**
     * The output folder ID. The outputFolderId property is deprecated and will stop returning data on April 30, 2023.
     */
    outputFolderId?: string;
    /**
     * The name provided for the export.
     */
    outputName?: string;
    /**
     * Review set from where documents are exported.
     */
    reviewSet?: EdiscoveryReviewSet;
    /**
     * The review set query that is used to filter the documents for export.
     */
    reviewSetQuery?: EdiscoveryReviewSetQuery;
}
export interface EdiscoveryFile extends File, Parsable {
    /**
     * Custodians associated with the file.
     */
    custodian?: EdiscoveryCustodian;
    /**
     * Tags associated with the file.
     */
    tags?: EdiscoveryReviewTag[];
}
export interface EdiscoveryFileCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryFile[];
}
export interface EdiscoveryHoldOperation extends CaseOperation, Parsable {
}
export interface EdiscoveryHoldPolicy extends Parsable, PolicyBase {
    /**
     * KQL query that specifies content to be held in the specified locations. To learn more, see Keyword queries and search conditions for Content Search and eDiscovery.  To hold all content in the specified locations, leave contentQuery blank.
     */
    contentQuery?: string;
    /**
     * Lists any errors that happened while placing the hold.
     */
    errors?: string[];
    /**
     * Indicates whether the hold is enabled and actively holding content.
     */
    isEnabled?: boolean;
    /**
     * Data sources that represent SharePoint sites.
     */
    siteSources?: SiteSource[];
    /**
     * Data sources that represent Exchange mailboxes.
     */
    userSources?: UserSource[];
}
export interface EdiscoveryHoldPolicyCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryHoldPolicy[];
}
export interface EdiscoveryIndexOperation extends CaseOperation, Parsable {
}
export interface EdiscoveryNoncustodialDataSource extends DataSourceContainer, Parsable {
    /**
     * User source or SharePoint site data source as non-custodial data source.
     */
    dataSource?: DataSource;
    /**
     * Operation entity that represents the latest indexing for the non-custodial data source.
     */
    lastIndexOperation?: EdiscoveryIndexOperation;
}
export interface EdiscoveryNoncustodialDataSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryNoncustodialDataSource[];
}
export interface EdiscoveryPurgeDataOperation extends CaseOperation, Parsable {
}
export interface EdiscoveryReviewSet extends DataSet, Parsable {
    /**
     * Represents files within the review set.
     */
    files?: EdiscoveryFile[];
    /**
     * Represents queries within the review set.
     */
    queries?: EdiscoveryReviewSetQuery[];
}
export interface EdiscoveryReviewSetCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryReviewSet[];
}
export interface EdiscoveryReviewSetQuery extends Parsable, Search {
}
export interface EdiscoveryReviewSetQueryCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryReviewSetQuery[];
}
export interface EdiscoveryReviewTag extends Parsable, Tag {
    /**
     * Indicates whether a single or multiple child tags can be associated with a document. Possible values are: One, Many.  This value controls whether the UX presents the tags as checkboxes or a radio button group.
     */
    childSelectability?: ChildSelectability;
    /**
     * Returns the tags that are a child of a tag.
     */
    childTags?: EdiscoveryReviewTag[];
    /**
     * Returns the parent tag of the specified tag.
     */
    parent?: EdiscoveryReviewTag;
}
export interface EdiscoveryReviewTagCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryReviewTag[];
}
export interface EdiscoverySearch extends Parsable, Search {
    /**
     * Adds an additional source to the eDiscovery search.
     */
    additionalSources?: DataSource[];
    /**
     * Adds the results of the eDiscovery search to the specified reviewSet.
     */
    addToReviewSetOperation?: EdiscoveryAddToReviewSetOperation;
    /**
     * Custodian sources that are included in the eDiscovery search.
     */
    custodianSources?: DataSource[];
    /**
     * When specified, the collection spans across a service for an entire workload. Possible values are: none, allTenantMailboxes, allTenantSites, allCaseCustodians, allCaseNoncustodialDataSources.
     */
    dataSourceScopes?: DataSourceScopes[];
    /**
     * The last estimate operation associated with the eDiscovery search.
     */
    lastEstimateStatisticsOperation?: EdiscoveryEstimateOperation;
    /**
     * noncustodialDataSource sources that are included in the eDiscovery search
     */
    noncustodialSources?: EdiscoveryNoncustodialDataSource[];
}
export interface EdiscoverySearchCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoverySearch[];
}
export interface EdiscoverySearchExportOperation extends CaseOperation, Parsable {
    /**
     * The additional items to include in the export. The possible values are: none, teamsAndYammerConversations, cloudAttachments, allDocumentVersions, subfolderContents, listAttachments, unknownFutureValue.
     */
    additionalOptions?: AdditionalOptions[];
    /**
     * The name of export provided by the user.
     */
    description?: string;
    /**
     * The description of the export by the user.
     */
    displayName?: string;
    /**
     * Items to be included in the export. The possible values are: searchHits, partiallyIndexed, unknownFutureValue.
     */
    exportCriteria?: ExportCriteria[];
    /**
     * Contains the properties for an export file metadata, including downloadUrl, fileName, and size.
     */
    exportFileMetadata?: ExportFileMetadata[];
    /**
     * Format of the emails of the export. The possible values are: pst, msg, eml, unknownFutureValue.
     */
    exportFormat?: ExportFormat;
    /**
     * Location scope for partially indexed items. You can choose to include partially indexed items only in responsive locations with search hits or in all targeted locations. The possible values are: responsiveLocations, nonresponsiveLocations, unknownFutureValue.
     */
    exportLocation?: ExportLocation[];
    /**
     * Indicates whether to export single items.
     */
    exportSingleItems?: boolean;
    /**
     * The eDiscovery searches under each case.
     */
    search?: EdiscoverySearch;
}
export interface EdiscoveryTagOperation extends CaseOperation, Parsable {
}
export interface EmailContentThreatSubmission extends EmailThreatSubmission, Parsable {
    /**
     * Base64 encoded file content.
     */
    fileContent?: string;
}
export type EmailEntityIdentifier = (typeof EmailEntityIdentifierObject)[keyof typeof EmailEntityIdentifierObject];
export interface EmailSender extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of the sender.
     */
    displayName?: string;
    /**
     * Sender domain.
     */
    domainName?: string;
    /**
     * Sender email address.
     */
    emailAddress?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface EmailThreatSubmission extends Parsable, ThreatSubmission {
    /**
     * If the email is phishing simulation, this field won't be null.
     */
    attackSimulationInfo?: AttackSimulationInfo;
    /**
     * Specifies the internet message ID of the email being submitted. This information is present in the email header.
     */
    internetMessageId?: string;
    /**
     * The original category of the submission. The possible values are: notJunk, spam, phishing, malware and unkownFutureValue.
     */
    originalCategory?: SubmissionCategory;
    /**
     * Specifies the date and time stamp when the email was received.
     */
    receivedDateTime?: Date;
    /**
     * Specifies the email address (in smtp format) of the recipient who received the email.
     */
    recipientEmailAddress?: string;
    /**
     * Specifies the email address of the sender.
     */
    sender?: string;
    /**
     * Specifies the IP address of the sender.
     */
    senderIP?: string;
    /**
     * Specifies the subject of the email.
     */
    subject?: string;
    /**
     * It's used to automatically add allows for the components such as URL, file, sender; which are deemed bad by Microsoft so that similar messages in the future can be allowed.
     */
    tenantAllowOrBlockListAction?: TenantAllowOrBlockListAction;
}
export interface EmailThreatSubmissionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EmailThreatSubmission[];
}
export interface EmailThreatSubmissionPolicy extends Entity, Parsable {
    /**
     * Specifies the email address of the sender from which email notifications will be sent to end users to inform them whether an email is spam, phish or clean. The default value is null. Optional for creation.
     */
    customizedNotificationSenderEmailAddress?: string;
    /**
     * Specifies the destination where the reported messages from end users land whenever they report something as phish, junk or not junk. The default value is null. Optional for creation.
     */
    customizedReportRecipientEmailAddress?: string;
    /**
     * Indicates whether end users can report a message as spam, phish or junk directly without a confirmation(popup). The default value is true.  Optional for creation.
     */
    isAlwaysReportEnabledForUsers?: boolean;
    /**
     * Indicates whether end users can confirm using a popup before reporting messages as spam, phish or not junk. The default value is true.  Optional for creation.
     */
    isAskMeEnabledForUsers?: boolean;
    /**
     * Indicates whether the email notifications sent to end users to inform them if an email is a phish mail, spam or junk is customized or not. The default value is false. Optional for creation.
     */
    isCustomizedMessageEnabled?: boolean;
    /**
     * If enabled, customized message only shows when email is reported as phishing. The default value is false. Optional for creation.
     */
    isCustomizedMessageEnabledForPhishing?: boolean;
    /**
     * Indicates whether to use the sender email address set using customizedNotificationSenderEmailAddress for sending email notifications to end users. The default value is false. Optional for creation.
     */
    isCustomizedNotificationSenderEnabled?: boolean;
    /**
     * Indicates whether end users can move the message from one folder to another based on the action of spam, phish or not junk without actually reporting it. The default value is true. Optional for creation.
     */
    isNeverReportEnabledForUsers?: boolean;
    /**
     * Indicates whether the branding logo should be used in the email notifications sent to end users. The default value is false. Optional for creation.
     */
    isOrganizationBrandingEnabled?: boolean;
    /**
     * Indicates whether end users can submit from the quarantine page. The default value is true. Optional for creation.
     */
    isReportFromQuarantineEnabled?: boolean;
    /**
     * Indicates whether emails reported by end users should be sent to the custom mailbox configured using customizedReportRecipientEmailAddress.  The default value is false. Optional for creation.
     */
    isReportToCustomizedEmailAddressEnabled?: boolean;
    /**
     * If enabled, the email is sent to Microsoft for analysis. The default value is false. Required for creation.
     */
    isReportToMicrosoftEnabled?: boolean;
    /**
     * Indicates whether an email notification is sent to the end user who reported the email when it has been reviewed by the admin. The default value is false. Optional for creation.
     */
    isReviewEmailNotificationEnabled?: boolean;
}
export interface EmailThreatSubmissionPolicyCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EmailThreatSubmissionPolicy[];
}
export interface EmailUrlThreatSubmission extends EmailThreatSubmission, Parsable {
    /**
     * Specifies the url of the message to be submitted.
     */
    messageUrl?: string;
}
export interface EventPropagationResult extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of the specific location in the workload associated with the event.
     */
    location?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The name of the workload associated with the event.
     */
    serviceName?: string;
    /**
     * Indicates the status of the event creation request. The possible values are: none, inProcessing, failed, success.
     */
    status?: EventPropagationStatus;
    /**
     * Additional information about the status of the event creation request.
     */
    statusInformation?: string;
}
export type EventPropagationStatus = (typeof EventPropagationStatusObject)[keyof typeof EventPropagationStatusObject];
export interface EventQuery extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Represents unique identification for the  query. 'Asset ID' for SharePoint Online and OneDrive for Business, 'keywords' for Exchange Online.
     */
    query?: string;
    /**
     * Represents the type of query associated with an event. 'files' for SPO and ODB and 'messages' for EXO.The possible values are: files, messages, unknownFutureValue.
     */
    queryType?: QueryType;
}
export type EventStatusType = (typeof EventStatusTypeObject)[keyof typeof EventStatusTypeObject];
export type EvidenceRemediationStatus = (typeof EvidenceRemediationStatusObject)[keyof typeof EvidenceRemediationStatusObject];
export type EvidenceRole = (typeof EvidenceRoleObject)[keyof typeof EvidenceRoleObject];
export type EvidenceVerdict = (typeof EvidenceVerdictObject)[keyof typeof EvidenceVerdictObject];
export type ExportCriteria = (typeof ExportCriteriaObject)[keyof typeof ExportCriteriaObject];
export interface ExportFileMetadata extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The downloadUrl property
     */
    downloadUrl?: string;
    /**
     * The fileName property
     */
    fileName?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The size property
     */
    size?: number;
}
export type ExportFileStructure = (typeof ExportFileStructureObject)[keyof typeof ExportFileStructureObject];
export type ExportFormat = (typeof ExportFormatObject)[keyof typeof ExportFormatObject];
export type ExportLocation = (typeof ExportLocationObject)[keyof typeof ExportLocationObject];
export type ExportOptions = (typeof ExportOptionsObject)[keyof typeof ExportOptionsObject];
export interface File extends Entity, Parsable {
    /**
     * The content property
     */
    content?: string;
    /**
     * The dateTime property
     */
    dateTime?: Date;
    /**
     * The extension property
     */
    extension?: string;
    /**
     * The extractedTextContent property
     */
    extractedTextContent?: string;
    /**
     * The mediaType property
     */
    mediaType?: string;
    /**
     * The name property
     */
    name?: string;
    /**
     * The otherProperties property
     */
    otherProperties?: StringValueDictionary;
    /**
     * The processingStatus property
     */
    processingStatus?: FileProcessingStatus;
    /**
     * The senderOrAuthors property
     */
    senderOrAuthors?: string[];
    /**
     * The size property
     */
    size?: number;
    /**
     * The sourceType property
     */
    sourceType?: SourceType[];
    /**
     * The subjectTitle property
     */
    subjectTitle?: string;
}
export interface FileContentThreatSubmission extends FileThreatSubmission, Parsable {
    /**
     * It specifies the file content in base 64 format.
     */
    fileContent?: string;
}
export interface FileDetails extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of the file.
     */
    fileName?: string;
    /**
     * The file path (location) of the file instance.
     */
    filePath?: string;
    /**
     * The publisher of the file.
     */
    filePublisher?: string;
    /**
     * The size of the file in bytes.
     */
    fileSize?: number;
    /**
     * The certificate authority (CA) that issued the certificate.
     */
    issuer?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The Sha1 cryptographic hash of the file content.
     */
    sha1?: string;
    /**
     * The Sha256 cryptographic hash of the file content.
     */
    sha256?: string;
    /**
     * The signer of the signed file.
     */
    signer?: string;
}
export type FileEntityIdentifier = (typeof FileEntityIdentifierObject)[keyof typeof FileEntityIdentifierObject];
export interface FileEvidence extends AlertEvidence, Parsable {
    /**
     * The status of the detection.The possible values are: detected, blocked, prevented, unknownFutureValue.
     */
    detectionStatus?: DetectionStatus;
    /**
     * The file details.
     */
    fileDetails?: FileDetails;
    /**
     * A unique identifier assigned to a device by Microsoft Defender for Endpoint.
     */
    mdeDeviceId?: string;
}
export interface FileHash extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The algorithm property
     */
    algorithm?: FileHashAlgorithm;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The hash value.
     */
    value?: string;
}
export type FileHashAlgorithm = (typeof FileHashAlgorithmObject)[keyof typeof FileHashAlgorithmObject];
export interface FileHashEvidence extends AlertEvidence, Parsable {
    /**
     * The algorithm property
     */
    algorithm?: FileHashAlgorithm;
    /**
     * The value property
     */
    value?: string;
}
export interface FilePlanAppliedCategory extends FilePlanDescriptorBase, Parsable {
    /**
     * Represents the file plan descriptor for a subcategory under a specific category, which has been assigned to a particular retention label.
     */
    subcategory?: FilePlanSubcategory;
}
export interface FilePlanAuthority extends FilePlanDescriptorBase, Parsable {
}
export interface FilePlanCitation extends FilePlanDescriptorBase, Parsable {
    /**
     * Represents the jurisdiction or agency that published the filePlanCitation.
     */
    citationJurisdiction?: string;
    /**
     * Represents the URL to the published filePlanCitation.
     */
    citationUrl?: string;
}
export interface FilePlanDepartment extends FilePlanDescriptorBase, Parsable {
}
export interface FilePlanDescriptor extends Entity, Parsable {
    /**
     * The authority property
     */
    authority?: FilePlanAuthority;
    /**
     * Specifies the underlying authority that describes the type of content to be retained and its retention schedule.
     */
    authorityTemplate?: AuthorityTemplate;
    /**
     * The category property
     */
    category?: FilePlanAppliedCategory;
    /**
     * Specifies a group of similar types of content in a particular department.
     */
    categoryTemplate?: CategoryTemplate;
    /**
     * The citation property
     */
    citation?: FilePlanCitation;
    /**
     * The specific rule or regulation created by a jurisdiction used to determine whether certain labels and content should be retained or deleted.
     */
    citationTemplate?: CitationTemplate;
    /**
     * The department property
     */
    department?: FilePlanDepartment;
    /**
     * Specifies the  department or business unit of an organization to which a label belongs.
     */
    departmentTemplate?: DepartmentTemplate;
    /**
     * The filePlanReference property
     */
    filePlanReference?: FilePlanReference;
    /**
     * Specifies a unique alpha-numeric identifier for an organization’s retention schedule.
     */
    filePlanReferenceTemplate?: FilePlanReferenceTemplate;
}
export interface FilePlanDescriptorBase extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Unique string that defines the name for the file plan descriptor associated with a particular retention label.
     */
    displayName?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface FilePlanDescriptorTemplate extends Entity, Parsable {
    /**
     * Represents the user who created the filePlanDescriptorTemplate column. Read-only.
     */
    createdBy?: IdentitySet;
    /**
     * Represents the date and time in which the filePlanDescriptorTemplate is created. Read-only.
     */
    createdDateTime?: Date;
    /**
     * Unique string that defines a filePlanDescriptorTemplate name.
     */
    displayName?: string;
}
export interface FilePlanReference extends FilePlanDescriptorBase, Parsable {
}
export interface FilePlanReferenceTemplate extends FilePlanDescriptorTemplate, Parsable {
}
export interface FilePlanReferenceTemplateCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: FilePlanReferenceTemplate[];
}
export interface FilePlanSubcategory extends FilePlanDescriptorBase, Parsable {
}
export type FileProcessingStatus = (typeof FileProcessingStatusObject)[keyof typeof FileProcessingStatusObject];
export interface FileThreatSubmission extends Parsable, ThreatSubmission {
    /**
     * It specifies the file name to be submitted.
     */
    fileName?: string;
}
export interface FileThreatSubmissionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: FileThreatSubmission[];
}
export interface FileUrlThreatSubmission extends FileThreatSubmission, Parsable {
    /**
     * It specifies the URL of the file that needs to be submitted.
     */
    fileUrl?: string;
}
export type ForceUserPasswordResetEntityIdentifier = (typeof ForceUserPasswordResetEntityIdentifierObject)[keyof typeof ForceUserPasswordResetEntityIdentifierObject];
export interface ForceUserPasswordResetResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: ForceUserPasswordResetEntityIdentifier[];
}
export interface FormattedContent extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The content of this formattedContent.
     */
    content?: string;
    /**
     * The format of the content. The possible values are: text, html, markdown, unknownFutureValue.
     */
    format?: ContentFormat;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface GeoLocation extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The city property
     */
    city?: string;
    /**
     * The countryName property
     */
    countryName?: string;
    /**
     * The latitude property
     */
    latitude?: number;
    /**
     * The longitude property
     */
    longitude?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The state property
     */
    state?: string;
}
export interface GitHubOrganizationEvidence extends AlertEvidence, Parsable {
    /**
     * The company property
     */
    company?: string;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The email property
     */
    email?: string;
    /**
     * The login property
     */
    login?: string;
    /**
     * The orgId property
     */
    orgId?: string;
    /**
     * The webUrl property
     */
    webUrl?: string;
}
export interface GitHubRepoEvidence extends AlertEvidence, Parsable {
    /**
     * The baseUrl property
     */
    baseUrl?: string;
    /**
     * The login property
     */
    login?: string;
    /**
     * The owner property
     */
    owner?: string;
    /**
     * The ownerType property
     */
    ownerType?: string;
    /**
     * The repoId property
     */
    repoId?: string;
}
export interface GitHubUserEvidence extends AlertEvidence, Parsable {
    /**
     * The email property
     */
    email?: string;
    /**
     * The login property
     */
    login?: string;
    /**
     * The name property
     */
    name?: string;
    /**
     * The userId property
     */
    userId?: string;
    /**
     * The webUrl property
     */
    webUrl?: string;
}
export type GoogleCloudLocationType = (typeof GoogleCloudLocationTypeObject)[keyof typeof GoogleCloudLocationTypeObject];
export interface GoogleCloudResourceEvidence extends AlertEvidence, Parsable {
    /**
     * The fullResourceName property
     */
    fullResourceName?: string;
    /**
     * The zone or region where the resource is located.
     */
    location?: string;
    /**
     * The type of location. Possible values are: unknown, regional, zonal, global, unknownFutureValue.
     */
    locationType?: GoogleCloudLocationType;
    /**
     * The Google project ID as defined by the user.
     */
    projectId?: string;
    /**
     * The project number assigned by Google.
     */
    projectNumber?: number;
    /**
     * The name of the resource.
     */
    resourceName?: string;
    /**
     * The type of the resource.
     */
    resourceType?: string;
}
export interface HardDeleteResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: EmailEntityIdentifier[];
}
export interface HealthIssue extends Entity, Parsable {
    /**
     * Contains additional information about the issue, such as a list of items to fix.
     */
    additionalInformation?: string[];
    /**
     * The date and time of when the health issue was generated.
     */
    createdDateTime?: Date;
    /**
     * Contains more detailed information about the health issue.
     */
    description?: string;
    /**
     * The display name of the health issue.
     */
    displayName?: string;
    /**
     * A list of the fully qualified domain names of the domains or the sensors the health issue is related to.
     */
    domainNames?: string[];
    /**
     * The type of the health issue. The possible values are: sensor, global, unknownFutureValue. For a list of all health issues and their identifiers, see Microsoft Defender for Identity health issues.
     */
    healthIssueType?: HealthIssueType;
    /**
     * The type identifier of the health issue. For a list of all health issues and their identifiers, see Microsoft Defender for Identity health issues.
     */
    issueTypeId?: string;
    /**
     * The date and time of when the health issue was last updated.
     */
    lastModifiedDateTime?: Date;
    /**
     * This field contains a list of recommended actions that can be taken to resolve the issue effectively and efficiently. These actions might include how to investigate the issue further. Not limited to prewritten responses.
     */
    recommendations?: string[];
    /**
     * Contains a list of commands from the product's PowerShell module that can be used to resolve the issue, if available. If there aren't any commands that can be used to solve the issue, this field is empty. The commands, if present, provide a quick and efficient way to address the issue. The commands run in order for the single recommended fix.
     */
    recommendedActionCommands?: string[];
    /**
     * A list of the dns names of the sensors the health issue is related to.
     */
    sensorDNSNames?: string[];
    /**
     * The severity of the health issue. The possible values are: low, medium, high, unknownFutureValue.
     */
    severity?: HealthIssueSeverity;
    /**
     * The status of the health issue. The possible values are: open, closed, suppressed, unknownFutureValue.
     */
    status?: HealthIssueStatus;
}
export interface HealthIssueCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HealthIssue[];
}
export type HealthIssueSeverity = (typeof HealthIssueSeverityObject)[keyof typeof HealthIssueSeverityObject];
export type HealthIssueStatus = (typeof HealthIssueStatusObject)[keyof typeof HealthIssueStatusObject];
export type HealthIssueType = (typeof HealthIssueTypeObject)[keyof typeof HealthIssueTypeObject];
export interface Host extends Artifact, Parsable {
    /**
     * The hostPairs that are resources associated with a host, where that host is the parentHost and has an outgoing pairing to a cihldHost.
     */
    childHostPairs?: HostPair[];
    /**
     * The hostComponents that are associated with this host.
     */
    components?: HostComponent[];
    /**
     * The hostCookies that are associated with this host.
     */
    cookies?: HostCookie[];
    /**
     * The first date and time when this host was observed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The hostPairs that are associated with this host, where this host is either the parentHost or childHost.
     */
    hostPairs?: HostPair[];
    /**
     * The most recent date and time when this host was observed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The hostPairs that are associated with a host, where that host is the childHost and has an incoming pairing with a parentHost.
     */
    parentHostPairs?: HostPair[];
    /**
     * Passive DNS retrieval about this host.
     */
    passiveDns?: PassiveDnsRecord[];
    /**
     * Reverse passive DNS retrieval about this host.
     */
    passiveDnsReverse?: PassiveDnsRecord[];
    /**
     * The hostPorts associated with a host.
     */
    ports?: HostPort[];
    /**
     * Represents a calculated reputation of this host.
     */
    reputation?: HostReputation;
    /**
     * The hostSslCertificates that are associated with this host.
     */
    sslCertificates?: HostSslCertificate[];
    /**
     * The subdomains that are associated with this host.
     */
    subdomains?: Subdomain[];
    /**
     * The hostTrackers that are associated with this host.
     */
    trackers?: HostTracker[];
    /**
     * The most recent whoisRecord for this host.
     */
    whois?: WhoisRecord;
}
export interface HostCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Host[];
}
export interface HostComponent extends Artifact, Parsable {
    /**
     * The type of component that was detected (for example, Operating System, Framework, Remote Access, or Server).
     */
    category?: string;
    /**
     * The first date and time when this web component was observed by Microsoft Defender Threat Intelligence. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The most recent date and time when this web component was observed by Microsoft Defender Threat Intelligence. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * A name running on the artifact, for example, Microsoft IIS.
     */
    name?: string;
    /**
     * The component version running on the artifact, for example, v8.5. This shouldn't be assumed to be strictly numerical.
     */
    version?: string;
}
export interface HostComponentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostComponent[];
}
export interface HostCookie extends Artifact, Parsable {
    /**
     * The URI for which the cookie is valid.
     */
    domain?: string;
    /**
     * The first date and time when this hostCookie was observed by Microsoft Defender Threat Intelligence. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The most recent date and time when this hostCookie was observed by Microsoft Defender Threat Intelligence. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The name of the cookie, for example, JSESSIONID or SEARCH_NAMESITE.
     */
    name?: string;
}
export interface HostCookieCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostCookie[];
}
export interface HostLogonSessionEvidence extends AlertEvidence, Parsable {
    /**
     * The account property
     */
    account?: UserEvidence;
    /**
     * The endUtcDateTime property
     */
    endUtcDateTime?: Date;
    /**
     * The host property
     */
    host?: DeviceEvidence;
    /**
     * The sessionId property
     */
    sessionId?: string;
    /**
     * The startUtcDateTime property
     */
    startUtcDateTime?: Date;
}
export interface Hostname extends Host, Parsable {
    /**
     * The company or individual who registered this hostname, from WHOIS data.
     */
    registrant?: string;
    /**
     * The registrar for this hostname, from WHOIS data.
     */
    registrar?: string;
}
export interface HostPair extends Entity, Parsable {
    /**
     * The childHost property
     */
    childHost?: Host;
    /**
     * The first date and time when Microsoft Defender Threat Intelligence observed the hostPair. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The last date and time when Microsoft Defender Threat Intelligence observed the hostPair. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The reason that two hosts are identified as hostPair.
     */
    linkKind?: string;
    /**
     * The parentHost property
     */
    parentHost?: Host;
}
export interface HostPairCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostPair[];
}
export interface HostPort extends Entity, Parsable {
    /**
     * The hostPortBanners retrieved from scanning the port.
     */
    banners?: HostPortBanner[];
    /**
     * The first date and time when Microsoft Defender Threat Intelligence observed the hostPort. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The last date and time when Microsoft Defender Threat Intelligence scanned the hostPort. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastScanDateTime?: Date;
    /**
     * The last date and time when Microsoft Defender Threat Intelligence observed the hostPort. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The most recent sslCertificate used to communicate on the port.
     */
    mostRecentSslCertificate?: SslCertificate;
    /**
     * The numerical identifier of the port which is standardized across the internet.
     */
    port?: number;
    /**
     * The general protocol used to scan the port. The possible values are: tcp, udp, unknownFutureValue.
     */
    protocol?: HostPortProtocol;
    /**
     * The hostPortComponents retrieved from scanning the port.
     */
    services?: HostPortComponent[];
    /**
     * The status of the port. The possible values are: open, filtered, closed, unknownFutureValue.
     */
    status?: HostPortStatus;
    /**
     * The total amount of times that Microsoft Defender Threat Intelligence has observed the hostPort in all its scans.
     */
    timesObserved?: number;
}
export interface HostPortBanner extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The text response received from a web component when scanning a hostPort.
     */
    banner?: string;
    /**
     * The first date and time when Microsoft Defender Threat Intelligence observed the hostPortBanner. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The last date and time when Microsoft Defender Threat Intelligence observed the hostPortBanner. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The specific protocol used to scan the hostPort.
     */
    scanProtocol?: string;
    /**
     * The total amount of times that Microsoft Defender Threat Intelligence has observed the hostPortBanner in all its scans.
     */
    timesObserved?: number;
}
export interface HostPortCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostPort[];
}
export interface HostPortComponent extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The component property
     */
    component?: HostComponent;
    /**
     * The first date and time when Microsoft Defender Threat Intelligence observed the hostPortComponent. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * Indicates whether this hostPortComponent is recent, which is determined by whether the hostPortComponent was observed either at the same time or after the latest hostPortBanner in the scan history, or within two days of the latest scan of the hostPort when there are no hostPortBanners in the scan history.
     */
    isRecent?: boolean;
    /**
     * The last date and time when Microsoft Defender Threat Intelligence observed the hostPortComponent. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type HostPortProtocol = (typeof HostPortProtocolObject)[keyof typeof HostPortProtocolObject];
export type HostPortStatus = (typeof HostPortStatusObject)[keyof typeof HostPortStatusObject];
export interface HostReputation extends Entity, Parsable {
    /**
     * The classification property
     */
    classification?: HostReputationClassification;
    /**
     * A collection of rules that have been used to calculate the classification and score.
     */
    rules?: HostReputationRule[];
    /**
     * The calculated score (0-100) of the requested host. A higher value indicates that this host is more likely to be suspicious or malicious.
     */
    score?: number;
}
export type HostReputationClassification = (typeof HostReputationClassificationObject)[keyof typeof HostReputationClassificationObject];
export interface HostReputationRule extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The description of the rule that gives more context.
     */
    description?: string;
    /**
     * The name of the rule.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Link to a web page with details related to this rule.
     */
    relatedDetailsUrl?: string;
    /**
     * The severity property
     */
    severity?: HostReputationRuleSeverity;
}
export type HostReputationRuleSeverity = (typeof HostReputationRuleSeverityObject)[keyof typeof HostReputationRuleSeverityObject];
export interface HostSslCertificate extends Artifact, Parsable {
    /**
     * The first date and time that this hostSslCertificate was observed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host for this hostSslCertificate.
     */
    host?: Host;
    /**
     * The most recent date and time that this hostSslCertificate was observed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The ports related with this hostSslCertificate.
     */
    ports?: HostSslCertificatePort[];
    /**
     * The sslCertificate for this hostSslCertificate.
     */
    sslCertificate?: SslCertificate;
}
export interface HostSslCertificateCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostSslCertificate[];
}
export interface HostSslCertificatePort extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The first date and time that this port was observed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The most recent date and time that this port was observed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The port number.
     */
    port?: number;
}
export interface HostTracker extends Artifact, Parsable {
    /**
     * The first date and time when this hostTracker was observed by Microsoft Defender Threat Intelligence. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The kind of hostTracker that was detected. For example, GoogleAnalyticsID or JarmHash.
     */
    kind?: string;
    /**
     * The most recent date and time when this hostTracker was observed by Microsoft Defender Threat Intelligence. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The identification value for the hostTracker.
     */
    value?: string;
}
export interface HostTrackerCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostTracker[];
}
export interface HuntingQueryResults extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The results of the hunting query.
     */
    results?: HuntingRowResult[];
    /**
     * The schema for the response.
     */
    schema?: SinglePropertySchema[];
}
export interface HuntingRowResult extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type HuntingRuleErrorCode = (typeof HuntingRuleErrorCodeObject)[keyof typeof HuntingRuleErrorCodeObject];
export type HuntingRuleRunStatus = (typeof HuntingRuleRunStatusObject)[keyof typeof HuntingRuleRunStatusObject];
export interface Hyperlink extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name for this hyperlink.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The URL for this hyperlink.
     */
    url?: string;
}
export interface IdentityContainer extends Entity, Parsable {
    /**
     * Represents potential issues within a customer's Microsoft Defender for Identity configuration that Microsoft Defender for Identity identified.
     */
    healthIssues?: HealthIssue[];
    /**
     * The sensors property
     */
    sensors?: Sensor[];
}
export interface ImpactedAsset extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface ImpactedDeviceAsset extends ImpactedAsset, Parsable {
    /**
     * The identifier property
     */
    identifier?: DeviceAssetIdentifier;
}
export interface ImpactedMailboxAsset extends ImpactedAsset, Parsable {
    /**
     * The identifier property
     */
    identifier?: MailboxAssetIdentifier;
}
export interface ImpactedUserAsset extends ImpactedAsset, Parsable {
    /**
     * The identifier property
     */
    identifier?: UserAssetIdentifier;
}
export interface Incident extends Entity, Parsable {
    /**
     * The list of related alerts. Supports $expand.
     */
    alerts?: Alert[];
    /**
     * Owner of the incident, or null if no owner is assigned. Free editable text.
     */
    assignedTo?: string;
    /**
     * The specification for the incident. Possible values are: unknown, falsePositive, truePositive, informationalExpectedActivity, unknownFutureValue.
     */
    classification?: AlertClassification;
    /**
     * Array of comments created by the Security Operations (SecOps) team when the incident is managed.
     */
    comments?: AlertComment[];
    /**
     * Time when the incident was first created.
     */
    createdDateTime?: Date;
    /**
     * The collection of custom tags that are associated with an incident.
     */
    customTags?: string[];
    /**
     * Description of the incident.
     */
    description?: string;
    /**
     * Specifies the determination of the incident. Possible values are: unknown, apt, malware, securityPersonnel, securityTesting, unwantedSoftware, other, multiStagedAttack, compromisedUser, phishing, maliciousUserActivity, clean, insufficientData, confirmedUserActivity, lineOfBusinessApplication, unknownFutureValue.
     */
    determination?: AlertDetermination;
    /**
     * The incident name.
     */
    displayName?: string;
    /**
     * The URL for the incident page in the Microsoft 365 Defender portal.
     */
    incidentWebUrl?: string;
    /**
     * The identity that last modified the incident.
     */
    lastModifiedBy?: string;
    /**
     * Time when the incident was last updated.
     */
    lastUpdateDateTime?: Date;
    /**
     * A rich text string that represents the actions that are reccomnded to take in order to resolve the incident
     */
    recommendedActions?: string;
    /**
     * List of hunting Kusto Query Language (KQL) queries related to the incident
     */
    recommendedHuntingQueries?: RecommendedHuntingQuery[];
    /**
     * Only populated in case an incident is grouped together with another incident, as part of the logic that processes incidents. In such a case, the status property is redirected.
     */
    redirectIncidentId?: string;
    /**
     * User input that explains the resolution of the incident and the classification choice. This property contains free editable text.
     */
    resolvingComment?: string;
    /**
     * The severity property
     */
    severity?: AlertSeverity;
    /**
     * The status property
     */
    status?: IncidentStatus;
    /**
     * The collection of system tags that are associated with the incident.
     */
    systemTags?: string[];
    /**
     * The Microsoft Entra tenant in which the alert was created.
     */
    tenantId?: string;
}
export interface IncidentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Incident[];
}
export type IncidentStatus = (typeof IncidentStatusObject)[keyof typeof IncidentStatusObject];
export interface Indicator extends Entity, Parsable {
    /**
     * The artifact property
     */
    artifact?: Artifact;
    /**
     * The source property
     */
    source?: IndicatorSource;
}
export type IndicatorSource = (typeof IndicatorSourceObject)[keyof typeof IndicatorSourceObject];
export interface InformationProtection extends Entity, Parsable {
    /**
     * Read the Microsoft Purview Information Protection policy settings for the user or organization.
     */
    labelPolicySettings?: InformationProtectionPolicySetting;
    /**
     * Read the Microsoft Purview Information Protection labels for the user or organization.
     */
    sensitivityLabels?: SensitivityLabel[];
}
export interface InformationProtectionAction extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface InformationProtectionPolicySetting extends Entity, Parsable {
    /**
     * The defaultLabelId property
     */
    defaultLabelId?: string;
    /**
     * Exposes whether justification input is required on label downgrade.
     */
    isDowngradeJustificationRequired?: boolean;
    /**
     * Exposes whether mandatory labeling is enabled.
     */
    isMandatory?: boolean;
    /**
     * Exposes the more information URL that can be configured by the administrator.
     */
    moreInfoUrl?: string;
}
export interface InitiateInvestigationResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: DeviceIdEntityIdentifier[];
}
export interface IntelligenceProfile extends Entity, Parsable {
    /**
     * A list of commonly-known aliases for the threat intelligence included in the intelligenceProfile.
     */
    aliases?: string[];
    /**
     * The country/region of origin for the given actor or threat associated with this intelligenceProfile.
     */
    countriesOrRegionsOfOrigin?: IntelligenceProfileCountryOrRegionOfOrigin[];
    /**
     * The description property
     */
    description?: FormattedContent;
    /**
     * The date and time when this intelligenceProfile was first active.  The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstActiveDateTime?: Date;
    /**
     * Includes an assemblage of high-fidelity network indicators of compromise.
     */
    indicators?: IntelligenceProfileIndicator[];
    /**
     * The kind property
     */
    kind?: IntelligenceProfileKind;
    /**
     * The summary property
     */
    summary?: FormattedContent;
    /**
     * Known targets related to this intelligenceProfile.
     */
    targets?: string[];
    /**
     * The title of this intelligenceProfile.
     */
    title?: string;
    /**
     * Formatted information featuring a description of the distinctive tactics, techniques, and procedures (TTP) of the group, followed by a list of all known custom, commodity, and publicly available implants used by the group.
     */
    tradecraft?: FormattedContent;
}
export interface IntelligenceProfileCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: IntelligenceProfile[];
}
export interface IntelligenceProfileCountryOrRegionOfOrigin extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * A codified representation for this country/region of origin.
     */
    code?: string;
    /**
     * A display label for this ountry/region of origin.
     */
    label?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface IntelligenceProfileIndicator extends Indicator, Parsable {
    /**
     * Designate when an artifact was first used actively in an attack, when a particular sample was compiled, or if neither of those could be ascertained when the file was first seen in public repositories (for example, VirusTotal, ANY.RUN, Hybrid Analysis) or reported publicly.
     */
    firstSeenDateTime?: Date;
    /**
     * Designate when an artifact was most recently used actively in an attack, when a particular sample was compiled, or if neither of those could be ascertained when the file was first seen in public repositories (for example, VirusTotal, ANY.RUN, Hybrid Analysis) or reported publicly.
     */
    lastSeenDateTime?: Date;
}
export interface IntelligenceProfileIndicatorCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: IntelligenceProfileIndicator[];
}
export type IntelligenceProfileKind = (typeof IntelligenceProfileKindObject)[keyof typeof IntelligenceProfileKindObject];
export interface IoTDeviceEvidence extends AlertEvidence, Parsable {
    /**
     * The deviceId property
     */
    deviceId?: string;
    /**
     * The deviceName property
     */
    deviceName?: string;
    /**
     * The devicePageLink property
     */
    devicePageLink?: string;
    /**
     * The deviceSubType property
     */
    deviceSubType?: string;
    /**
     * The deviceType property
     */
    deviceType?: string;
    /**
     * The importance property
     */
    importance?: IoTDeviceImportanceType;
    /**
     * The ioTHub property
     */
    ioTHub?: AzureResourceEvidence;
    /**
     * The ioTSecurityAgentId property
     */
    ioTSecurityAgentId?: string;
    /**
     * The ipAddress property
     */
    ipAddress?: IpEvidence;
    /**
     * The isAuthorized property
     */
    isAuthorized?: boolean;
    /**
     * The isProgramming property
     */
    isProgramming?: boolean;
    /**
     * The isScanner property
     */
    isScanner?: boolean;
    /**
     * The macAddress property
     */
    macAddress?: string;
    /**
     * The manufacturer property
     */
    manufacturer?: string;
    /**
     * The model property
     */
    model?: string;
    /**
     * The nics property
     */
    nics?: NicEvidence;
    /**
     * The operatingSystem property
     */
    operatingSystem?: string;
    /**
     * The owners property
     */
    owners?: string[];
    /**
     * The protocols property
     */
    protocols?: string[];
    /**
     * The purdueLayer property
     */
    purdueLayer?: string;
    /**
     * The sensor property
     */
    sensor?: string;
    /**
     * The serialNumber property
     */
    serialNumber?: string;
    /**
     * The site property
     */
    site?: string;
    /**
     * The source property
     */
    source?: string;
    /**
     * The sourceRef property
     */
    sourceRef?: UrlEvidence;
    /**
     * The zone property
     */
    zone?: string;
}
export type IoTDeviceImportanceType = (typeof IoTDeviceImportanceTypeObject)[keyof typeof IoTDeviceImportanceTypeObject];
export interface IpAddress extends Host, Parsable {
    /**
     * The details about the autonomous system to which this IP address belongs.
     */
    autonomousSystem?: AutonomousSystem;
    /**
     * The country/region for this IP address.
     */
    countryOrRegion?: string;
    /**
     * The hosting company listed for this host.
     */
    hostingProvider?: string;
    /**
     * The block of IP addresses this IP address belongs to.
     */
    netblock?: string;
}
export interface IpEvidence extends AlertEvidence, Parsable {
    /**
     * The two-letter country code according to ISO 3166 format, for example: US, UK, or CA.).
     */
    countryLetterCode?: string;
    /**
     * The value of the IP Address can be either in V4 address or V6 address format.
     */
    ipAddress?: string;
    /**
     * The location property
     */
    location?: GeoLocation;
    /**
     * The stream property
     */
    stream?: Stream;
}
export interface IsolateDeviceResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: DeviceIdEntityIdentifier[];
    /**
     * The isolationType property
     */
    isolationType?: IsolationType;
}
export type IsolationType = (typeof IsolationTypeObject)[keyof typeof IsolationTypeObject];
export interface JustifyAction extends InformationProtectionAction, Parsable {
}
export interface KeyValuePair extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Name for this key-value pair.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Value for this key-value pair.
     */
    value?: string;
}
export interface KubernetesClusterEvidence extends AlertEvidence, Parsable {
    /**
     * The cloud identifier of the cluster. Can be either an amazonResourceEvidence, azureResourceEvidence, or googleCloudResourceEvidence object.
     */
    cloudResource?: AlertEvidence;
    /**
     * The distribution type of the cluster.
     */
    distribution?: string;
    /**
     * The cluster name.
     */
    name?: string;
    /**
     * The platform the cluster runs on. Possible values are: unknown, aks, eks, gke, arc, unknownFutureValue.
     */
    platform?: KubernetesPlatform;
    /**
     * The kubernetes version of the cluster.
     */
    version?: string;
}
export interface KubernetesControllerEvidence extends AlertEvidence, Parsable {
    /**
     * The labels for the Kubernetes pod.
     */
    labels?: Dictionary;
    /**
     * The controller name.
     */
    name?: string;
    /**
     * The service account namespace.
     */
    namespace?: KubernetesNamespaceEvidence;
    /**
     * The controller type.
     */
    type?: string;
}
export interface KubernetesNamespaceEvidence extends AlertEvidence, Parsable {
    /**
     * The namespace cluster.
     */
    cluster?: KubernetesClusterEvidence;
    /**
     * The labels for the Kubernetes pod.
     */
    labels?: Dictionary;
    /**
     * The namespace name.
     */
    name?: string;
}
export type KubernetesPlatform = (typeof KubernetesPlatformObject)[keyof typeof KubernetesPlatformObject];
export interface KubernetesPodEvidence extends AlertEvidence, Parsable {
    /**
     * The list of pod containers which are not init or ephemeral containers.
     */
    containers?: ContainerEvidence[];
    /**
     * The pod controller.
     */
    controller?: KubernetesControllerEvidence;
    /**
     * The list of pod ephemeral containers.
     */
    ephemeralContainers?: ContainerEvidence[];
    /**
     * The list of pod init containers.
     */
    initContainers?: ContainerEvidence[];
    /**
     * The pod labels.
     */
    labels?: Dictionary;
    /**
     * The pod name.
     */
    name?: string;
    /**
     * The pod namespace.
     */
    namespace?: KubernetesNamespaceEvidence;
    /**
     * The pod IP.
     */
    podIp?: IpEvidence;
    /**
     * The pod service account.
     */
    serviceAccount?: KubernetesServiceAccountEvidence;
}
export interface KubernetesSecretEvidence extends AlertEvidence, Parsable {
    /**
     * The secret name.
     */
    name?: string;
    /**
     * The secret namespace.
     */
    namespace?: KubernetesNamespaceEvidence;
    /**
     * The secret type can include both built-in types and custom ones. Examples of built-in types are: Opaque, kubernetes.io/service-account-token, kubernetes.io/dockercfg, kubernetes.io/dockerconfigjson, kubernetes.io/basic-auth, kubernetes.io/ssh-auth, kubernetes.io/tls, bootstrap.kubernetes.io/token.
     */
    secretType?: string;
}
export interface KubernetesServiceAccountEvidence extends AlertEvidence, Parsable {
    /**
     * The service account name.
     */
    name?: string;
    /**
     * The service account namespace.
     */
    namespace?: KubernetesNamespaceEvidence;
}
export interface KubernetesServiceEvidence extends AlertEvidence, Parsable {
    /**
     * The service cluster IP.
     */
    clusterIP?: IpEvidence;
    /**
     * The service external IPs.
     */
    externalIPs?: IpEvidence[];
    /**
     * The service labels.
     */
    labels?: Dictionary;
    /**
     * The service name.
     */
    name?: string;
    /**
     * The service namespace.
     */
    namespace?: KubernetesNamespaceEvidence;
    /**
     * The service selector.
     */
    selector?: Dictionary;
    /**
     * The list of service ports.
     */
    servicePorts?: KubernetesServicePort[];
    /**
     * The serviceType property
     */
    serviceType?: KubernetesServiceType;
}
export interface KubernetesServicePort extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The application protocol for this port.
     */
    appProtocol?: string;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of this port within the service.
     */
    name?: string;
    /**
     * The port on each node on which this service is exposed when the type is either NodePort or LoadBalancer.
     */
    nodePort?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The port that this service exposes.
     */
    port?: number;
    /**
     * The protocol name. Possible values are: udp, tcp, sctp, unknownFutureValue.
     */
    protocol?: ContainerPortProtocol;
    /**
     * The name or number of the port to access on the pods targeted by the service. The port number must be in the range 1 to 65535. The name must be an IANASVCNAME.
     */
    targetPort?: string;
}
export type KubernetesServiceType = (typeof KubernetesServiceTypeObject)[keyof typeof KubernetesServiceTypeObject];
export interface LabelingOptions extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The assignmentMethod property
     */
    assignmentMethod?: AssignmentMethod;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The downgrade justification object that indicates if downgrade was justified and, if so, the reason.
     */
    downgradeJustification?: DowngradeJustification;
    /**
     * Extended properties will be parsed and returned in the standard Microsoft Purview Information Protection labeled metadata format as part of the label information.
     */
    extendedProperties?: KeyValuePair[];
    /**
     * The GUID of the label that should be applied to the information.
     */
    labelId?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface LabelsRoot extends Entity, Parsable {
    /**
     * Specifies the underlying authority that describes the type of content to be retained and its retention schedule.
     */
    authorities?: AuthorityTemplate[];
    /**
     * Specifies a group of similar types of content in a particular department.
     */
    categories?: CategoryTemplate[];
    /**
     * The specific rule or regulation created by a jurisdiction used to determine whether certain labels and content should be retained or deleted.
     */
    citations?: CitationTemplate[];
    /**
     * Specifies the department or business unit of an organization to which a label belongs.
     */
    departments?: DepartmentTemplate[];
    /**
     * Specifies a unique alpha-numeric identifier for an organization’s retention schedule.
     */
    filePlanReferences?: FilePlanReferenceTemplate[];
    /**
     * Represents how customers can manage their data, whether and for how long to retain or delete it.
     */
    retentionLabels?: RetentionLabel[];
}
export interface LoggedOnUser extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * User account name of the logged-on user.
     */
    accountName?: string;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * User account domain of the logged-on user.
     */
    domainName?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type LongRunningOperationStatus = (typeof LongRunningOperationStatusObject)[keyof typeof LongRunningOperationStatusObject];
export type MailboxAssetIdentifier = (typeof MailboxAssetIdentifierObject)[keyof typeof MailboxAssetIdentifierObject];
export interface MailboxConfigurationEvidence extends AlertEvidence, Parsable {
    /**
     * The configurationId property
     */
    configurationId?: string;
    /**
     * The configurationType property
     */
    configurationType?: MailboxConfigurationType;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The externalDirectoryObjectId property
     */
    externalDirectoryObjectId?: Guid;
    /**
     * The mailboxPrimaryAddress property
     */
    mailboxPrimaryAddress?: string;
    /**
     * The upn property
     */
    upn?: string;
}
export type MailboxConfigurationType = (typeof MailboxConfigurationTypeObject)[keyof typeof MailboxConfigurationTypeObject];
export interface MailboxEvidence extends AlertEvidence, Parsable {
    /**
     * The name associated with the mailbox.
     */
    displayName?: string;
    /**
     * The primary email address of the mailbox.
     */
    primaryAddress?: string;
    /**
     * The user account of the mailbox.
     */
    userAccount?: UserAccount;
}
export interface MailClusterEvidence extends AlertEvidence, Parsable {
    /**
     * The clustering logic of the emails inside the cluster.
     */
    clusterBy?: string;
    /**
     * The value utilized to cluster the similar emails.
     */
    clusterByValue?: string;
    /**
     * Count of emails in the email cluster.
     */
    emailCount?: number;
    /**
     * Unique identifiers for the emails in the cluster, generated by Microsoft 365.
     */
    networkMessageIds?: string[];
    /**
     * The query used to identify the email cluster.
     */
    query?: string;
    /**
     * Uniform resource name (URN) of the automated investigation where the cluster was identified.
     */
    urn?: string;
}
export interface MalwareEvidence extends AlertEvidence, Parsable {
    /**
     * The category property
     */
    category?: string;
    /**
     * The files property
     */
    files?: FileEvidence[];
    /**
     * The name property
     */
    name?: string;
    /**
     * The processes property
     */
    processes?: ProcessEvidence[];
}
export type MarkUserAsCompromisedEntityIdentifier = (typeof MarkUserAsCompromisedEntityIdentifierObject)[keyof typeof MarkUserAsCompromisedEntityIdentifierObject];
export interface MarkUserAsCompromisedResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: MarkUserAsCompromisedEntityIdentifier[];
}
export interface MetadataAction extends InformationProtectionAction, Parsable {
    /**
     * A collection of key-value pairs that should be added to the file.
     */
    metadataToAdd?: KeyValuePair[];
    /**
     * A collection of strings that indicate which keys to remove from the file metadata.
     */
    metadataToRemove?: string[];
}
export interface MoveToDeletedItemsResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: EmailEntityIdentifier[];
}
export interface MoveToInboxResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: EmailEntityIdentifier[];
}
export interface MoveToJunkResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: EmailEntityIdentifier[];
}
export interface NetworkAdapter extends Entity, Parsable {
    /**
     * The isEnabled property
     */
    isEnabled?: boolean;
    /**
     * The name property
     */
    name?: string;
}
export interface NetworkConnectionEvidence extends AlertEvidence, Parsable {
    /**
     * The destinationAddress property
     */
    destinationAddress?: IpEvidence;
    /**
     * The destinationPort property
     */
    destinationPort?: number;
    /**
     * The protocol property
     */
    protocol?: ProtocolType;
    /**
     * The sourceAddress property
     */
    sourceAddress?: IpEvidence;
    /**
     * The sourcePort property
     */
    sourcePort?: number;
}
export interface NicEvidence extends AlertEvidence, Parsable {
    /**
     * The ipAddress property
     */
    ipAddress?: IpEvidence;
    /**
     * The macAddress property
     */
    macAddress?: string;
    /**
     * The vlans property
     */
    vlans?: string[];
}
export interface OauthApplicationEvidence extends AlertEvidence, Parsable {
    /**
     * Unique identifier of the application.
     */
    appId?: string;
    /**
     * Name of the application.
     */
    displayName?: string;
    /**
     * The unique identifier of the application object in Azure AD.
     */
    objectId?: string;
    /**
     * The name of the application publisher.
     */
    publisher?: string;
}
export interface OcrSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Indicates whether or not OCR is enabled for the case.
     */
    isEnabled?: boolean;
    /**
     * Maximum image size that will be processed in KB).
     */
    maxImageSize?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The timeout duration for the OCR engine. A longer timeout might increase success of OCR, but might add to the total processing time.
     */
    timeout?: Duration;
}
export type OnboardingStatus = (typeof OnboardingStatusObject)[keyof typeof OnboardingStatusObject];
export interface OrganizationalScope extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * List of groups to which the custom detection rule applies.
     */
    scopeNames?: string[];
    /**
     * The scopeType property
     */
    scopeType?: ScopeType;
}
export interface PassiveDnsRecord extends Artifact, Parsable {
    /**
     * The artifact property
     */
    artifact?: Artifact;
    /**
     * The date and time that this passiveDnsRecord entry was collected by Microsoft. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    collectedDateTime?: Date;
    /**
     * The date and time when this passiveDnsRecord entry was first seen. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The date and time when this passiveDnsRecord entry was most recently seen. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The parentHost property
     */
    parentHost?: Host;
    /**
     * The DNS record type for this passiveDnsRecord entry.
     */
    recordType?: string;
}
export interface PassiveDnsRecordCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: PassiveDnsRecord[];
}
export interface PolicyBase extends Entity, Parsable {
    /**
     * The createdBy property
     */
    createdBy?: IdentitySet;
    /**
     * The createdDateTime property
     */
    createdDateTime?: Date;
    /**
     * The description property
     */
    description?: string;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The lastModifiedBy property
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The lastModifiedDateTime property
     */
    lastModifiedDateTime?: Date;
    /**
     * The status property
     */
    status?: PolicyStatus;
}
export type PolicyStatus = (typeof PolicyStatusObject)[keyof typeof PolicyStatusObject];
export interface ProcessEvidence extends AlertEvidence, Parsable {
    /**
     * The status of the detection. The possible values are: detected, blocked, prevented, unknownFutureValue.
     */
    detectionStatus?: DetectionStatus;
    /**
     * Image file details.
     */
    imageFile?: FileDetails;
    /**
     * A unique identifier assigned to a device by Microsoft Defender for Endpoint.
     */
    mdeDeviceId?: string;
    /**
     * Date and time when the parent of the process was created. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    parentProcessCreationDateTime?: Date;
    /**
     * Process ID (PID) of the parent process that spawned the process.
     */
    parentProcessId?: number;
    /**
     * Parent process image file details.
     */
    parentProcessImageFile?: FileDetails;
    /**
     * Command line used to create the new process.
     */
    processCommandLine?: string;
    /**
     * Date and time when the process was created. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    processCreationDateTime?: Date;
    /**
     * Process ID (PID) of the newly created process.
     */
    processId?: number;
    /**
     * User details of the user that ran the process.
     */
    userAccount?: UserAccount;
}
export interface ProtectAdhocAction extends InformationProtectionAction, Parsable {
}
export interface ProtectByTemplateAction extends InformationProtectionAction, Parsable {
    /**
     * The unique identifier for a protection template in Microsoft Purview Information Protection to apply to the content.
     */
    templateId?: string;
}
export interface ProtectDoNotForwardAction extends InformationProtectionAction, Parsable {
}
export interface ProtectionRule extends Entity, Parsable {
    /**
     * Name of the user or application that created the rule.
     */
    createdBy?: string;
    /**
     * Timestamp of rule creation.
     */
    createdDateTime?: Date;
    /**
     * Name of the rule.
     */
    displayName?: string;
    /**
     * Whether rule is turned on for the tenant.
     */
    isEnabled?: boolean;
    /**
     * Name of the user or application who last updated the rule.
     */
    lastModifiedBy?: string;
    /**
     * Timestamp of when the rule was last updated.
     */
    lastModifiedDateTime?: Date;
}
export type ProtocolType = (typeof ProtocolTypeObject)[keyof typeof ProtocolTypeObject];
export type PurgeAreas = (typeof PurgeAreasObject)[keyof typeof PurgeAreasObject];
export type PurgeType = (typeof PurgeTypeObject)[keyof typeof PurgeTypeObject];
export interface QueryCondition extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Timestamp of when the query in the custom detection rule was last updated.
     */
    lastModifiedDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Contents of the query.
     */
    queryText?: string;
}
export type QueryType = (typeof QueryTypeObject)[keyof typeof QueryTypeObject];
export interface RecommendedHuntingQuery extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The query string.
     */
    kqlText?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface RecommendLabelAction extends InformationProtectionAction, Parsable {
    /**
     * Actions to take if the label is accepted by the user.
     */
    actions?: InformationProtectionAction[];
    /**
     * The actionSource property
     */
    actionSource?: ActionSource;
    /**
     * The sensitive information type GUIDs that caused the recommendation to be given.
     */
    responsibleSensitiveTypeIds?: string[];
    /**
     * The sensitivityLabelId property
     */
    sensitivityLabelId?: string;
}
export interface RedundancyDetectionSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Indicates whether email threading and near duplicate detection are enabled.
     */
    isEnabled?: boolean;
    /**
     * Specifies the maximum number of words used for email threading and near duplicate detection. To learn more, see Minimum/maximum number of words.
     */
    maxWords?: number;
    /**
     * Specifies the minimum number of words used for email threading and near duplicate detection. To learn more, see Minimum/maximum number of words.
     */
    minWords?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Specifies the similarity level for documents to be put in the same near duplicate set. To learn more, see Document and email similarity threshold.
     */
    similarityThreshold?: number;
}
export interface RegistryKeyEvidence extends AlertEvidence, Parsable {
    /**
     * Registry hive of the key that the recorded action was applied to.
     */
    registryHive?: string;
    /**
     * Registry key that the recorded action was applied to.
     */
    registryKey?: string;
}
export interface RegistryValueEvidence extends AlertEvidence, Parsable {
    /**
     * A unique identifier assigned to a device by Microsoft Defender for Endpoint.
     */
    mdeDeviceId?: string;
    /**
     * Registry hive of the key that the recorded action was applied to.
     */
    registryHive?: string;
    /**
     * Registry key that the recorded action was applied to.
     */
    registryKey?: string;
    /**
     * Data of the registry value that the recorded action was applied to.
     */
    registryValue?: string;
    /**
     * Name of the registry value that the recorded action was applied to.
     */
    registryValueName?: string;
    /**
     * Data type, such as binary or string, of the registry value that the recorded action was applied to.
     */
    registryValueType?: string;
}
export type RemediationAction = (typeof RemediationActionObject)[keyof typeof RemediationActionObject];
export type RemediationSeverity = (typeof RemediationSeverityObject)[keyof typeof RemediationSeverityObject];
export interface RemoveContentFooterAction extends InformationProtectionAction, Parsable {
    /**
     * The name of the UI element of the footer to be removed.
     */
    uiElementNames?: string[];
}
export interface RemoveContentHeaderAction extends InformationProtectionAction, Parsable {
    /**
     * The name of the UI element of the header to be removed.
     */
    uiElementNames?: string[];
}
export interface RemoveProtectionAction extends InformationProtectionAction, Parsable {
}
export interface RemoveWatermarkAction extends InformationProtectionAction, Parsable {
    /**
     * The name of the UI element of watermark to be removed.
     */
    uiElementNames?: string[];
}
export interface ResponseAction extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface RestrictAppExecutionResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: DeviceIdEntityIdentifier[];
}
export interface RetentionDuration extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface RetentionDurationForever extends Parsable, RetentionDuration {
}
export interface RetentionDurationInDays extends Parsable, RetentionDuration {
    /**
     * Specifies the time period in days for which an item with the applied retention label will be retained for.
     */
    days?: number;
}
export interface RetentionEvent extends Entity, Parsable {
    /**
     * The user who created the retentionEvent.
     */
    createdBy?: IdentitySet;
    /**
     * The date time when the retentionEvent was created.
     */
    createdDateTime?: Date;
    /**
     * Optional information about the event.
     */
    description?: string;
    /**
     * Name of the event.
     */
    displayName?: string;
    /**
     * Represents the success status of a created event and additional information.
     */
    eventPropagationResults?: EventPropagationResult[];
    /**
     * Represents the workload (SharePoint Online, OneDrive for Business, Exchange Online) and identification information associated with a retention event.
     */
    eventQueries?: EventQuery[];
    /**
     * Status of event propogation to the scoped locations after the event has been created.
     */
    eventStatus?: RetentionEventStatus;
    /**
     * Optional time when the event should be triggered.
     */
    eventTriggerDateTime?: Date;
    /**
     * The user who last modified the retentionEvent.
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The latest date time when the retentionEvent was modified.
     */
    lastModifiedDateTime?: Date;
    /**
     * Last time the status of the event was updated.
     */
    lastStatusUpdateDateTime?: Date;
    /**
     * Specifies the event that will start the retention period for labels that use this event type when an event is created.
     */
    retentionEventType?: RetentionEventType;
}
export interface RetentionEventCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: RetentionEvent[];
}
export interface RetentionEventStatus extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The error if the status isn't successful.
     */
    errorEscaped?: PublicError;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The status of the distribution. The possible values are: pending, error, success, notAvaliable.
     */
    status?: EventStatusType;
}
export interface RetentionEventType extends Entity, Parsable {
    /**
     * The user who created the retentionEventType.
     */
    createdBy?: IdentitySet;
    /**
     * The date time when the retentionEventType was created.
     */
    createdDateTime?: Date;
    /**
     * Optional information about the event type.
     */
    description?: string;
    /**
     * Name of the event type.
     */
    displayName?: string;
    /**
     * The user who last modified the retentionEventType.
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The latest date time when the retentionEventType was modified.
     */
    lastModifiedDateTime?: Date;
}
export interface RetentionEventTypeCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: RetentionEventType[];
}
export interface RetentionLabel extends Entity, Parsable {
    /**
     * Specifies the action to take on the labeled document after the period specified by the retentionDuration property expires. The possible values are: none, delete, startDispositionReview, unknownFutureValue.
     */
    actionAfterRetentionPeriod?: ActionAfterRetentionPeriod;
    /**
     * Specifies how the behavior of a document with this label should be during the retention period. The possible values are: doNotRetain, retain, retainAsRecord, retainAsRegulatoryRecord, unknownFutureValue.
     */
    behaviorDuringRetentionPeriod?: BehaviorDuringRetentionPeriod;
    /**
     * Represents the user who created the retentionLabel.
     */
    createdBy?: IdentitySet;
    /**
     * Represents the date and time in which the retentionLabel is created.
     */
    createdDateTime?: Date;
    /**
     * Specifies the locked or unlocked state of a record label when it is created.The possible values are: startLocked, startUnlocked, unknownFutureValue.
     */
    defaultRecordBehavior?: DefaultRecordBehavior;
    /**
     * Provides label information for the admin. Optional.
     */
    descriptionForAdmins?: string;
    /**
     * Provides the label information for the user. Optional.
     */
    descriptionForUsers?: string;
    /**
     * Represents out-of-the-box values that provide more options to improve the manageability and organization of the content you need to label.
     */
    descriptors?: FilePlanDescriptor;
    /**
     * Unique string that defines a label name.
     */
    displayName?: string;
    /**
     * When action at the end of retention is chosen as 'dispositionReview', dispositionReviewStages specifies a sequential set of stages with at least one reviewer in each stage.
     */
    dispositionReviewStages?: DispositionReviewStage[];
    /**
     * Specifies whether the label is currently being used.
     */
    isInUse?: boolean;
    /**
     * Specifies the replacement label to be applied automatically after the retention period of the current label ends.
     */
    labelToBeApplied?: string;
    /**
     * The user who last modified the retentionLabel.
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The latest date time when the retentionLabel was modified.
     */
    lastModifiedDateTime?: Date;
    /**
     * Specifies the number of days to retain the content.
     */
    retentionDuration?: RetentionDuration;
    /**
     * Represents the type associated with a retention event.
     */
    retentionEventType?: RetentionEventType;
    /**
     * Specifies whether the retention duration is calculated from the content creation date, labeled date, or last modification date. The possible values are: dateLabeled, dateCreated, dateModified, dateOfEvent, unknownFutureValue.
     */
    retentionTrigger?: RetentionTrigger;
}
export interface RetentionLabelCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: RetentionLabel[];
}
export type RetentionTrigger = (typeof RetentionTriggerObject)[keyof typeof RetentionTriggerObject];
export interface RuleSchedule extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Timestamp of the custom detection rule's next scheduled run.
     */
    nextRunDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * How often the detection rule is set to run. The allowed values are: 0, 1H, 3H, 12H, or 24H. '0' signifies the rule is run continuously.
     */
    period?: string;
}
export interface RulesRoot extends Entity, Parsable {
    /**
     * The detectionRules property
     */
    detectionRules?: DetectionRule[];
}
export interface RunAntivirusScanResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: DeviceIdEntityIdentifier[];
}
export interface RunDetails extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Error code of the most recent run that encountered an error. The possible values are: queryExecutionFailed, queryExecutionThrottling, queryExceededResultSize, queryLimitsExceeded, queryTimeout, alertCreationFailed, alertReportNotFound, partialRowsFailed, unknownFutureValue.
     */
    errorCode?: HuntingRuleErrorCode;
    /**
     * Reason for failure when the custom detection last ran and failed. See the table below.
     */
    failureReason?: string;
    /**
     * Timestamp when the custom detection was last run.
     */
    lastRunDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Status of custom detection when it was last run. The possible values are: running, completed, failed, partiallyFailed, unknownFutureValue.
     */
    status?: HuntingRuleRunStatus;
}
export interface SasTokenEvidence extends AlertEvidence, Parsable {
    /**
     * The allowedIpAddresses property
     */
    allowedIpAddresses?: string;
    /**
     * The allowedResourceTypes property
     */
    allowedResourceTypes?: string[];
    /**
     * The allowedServices property
     */
    allowedServices?: string[];
    /**
     * The expiryDateTime property
     */
    expiryDateTime?: Date;
    /**
     * The permissions property
     */
    permissions?: string[];
    /**
     * The protocol property
     */
    protocol?: string;
    /**
     * The signatureHash property
     */
    signatureHash?: string;
    /**
     * The signedWith property
     */
    signedWith?: string;
    /**
     * The startDateTime property
     */
    startDateTime?: Date;
    /**
     * The storageResource property
     */
    storageResource?: AzureResourceEvidence;
}
export type ScopeType = (typeof ScopeTypeObject)[keyof typeof ScopeTypeObject];
export interface Search extends Entity, Parsable {
    /**
     * The contentQuery property
     */
    contentQuery?: string;
    /**
     * The createdBy property
     */
    createdBy?: IdentitySet;
    /**
     * The createdDateTime property
     */
    createdDateTime?: Date;
    /**
     * The description property
     */
    description?: string;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The lastModifiedBy property
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The lastModifiedDateTime property
     */
    lastModifiedDateTime?: Date;
}
export interface Security extends Entity, Parsable {
    /**
     * The informationProtection property
     */
    informationProtection?: InformationProtection;
}
export interface SecurityGroupEvidence extends AlertEvidence, Parsable {
    /**
     * The name of the security group.
     */
    displayName?: string;
    /**
     * Unique identifier of the security group.
     */
    securityGroupId?: string;
}
export interface SensitivityLabel extends Entity, Parsable {
    /**
     * The color that the UI should display for the label, if configured.
     */
    color?: string;
    /**
     * Returns the supported content formats for the label.
     */
    contentFormats?: string[];
    /**
     * The admin-defined description for the label.
     */
    description?: string;
    /**
     * Indicates whether the label has protection actions configured.
     */
    hasProtection?: boolean;
    /**
     * Indicates whether the label is active or not. Active labels should be hidden or disabled in the UI.
     */
    isActive?: boolean;
    /**
     * Indicates whether the label can be applied to content. False if the label is a parent with child labels.
     */
    isAppliable?: boolean;
    /**
     * The plaintext name of the label.
     */
    name?: string;
    /**
     * The parent label associated with a child label. Null if the label has no parent.
     */
    parent?: SensitivityLabel;
    /**
     * The sensitivity value of the label, where lower is less sensitive.
     */
    sensitivity?: number;
    /**
     * The tooltip that should be displayed for the label in a UI.
     */
    tooltip?: string;
}
export interface SensitivityLabelCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: SensitivityLabel[];
}
export interface Sensor extends Entity, Parsable {
    /**
     * The createdDateTime property
     */
    createdDateTime?: Date;
    /**
     * The deploymentStatus property
     */
    deploymentStatus?: DeploymentStatus;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The domainName property
     */
    domainName?: string;
    /**
     * The healthIssues property
     */
    healthIssues?: HealthIssue[];
    /**
     * The healthStatus property
     */
    healthStatus?: SensorHealthStatus;
    /**
     * The openHealthIssuesCount property
     */
    openHealthIssuesCount?: number;
    /**
     * The sensorType property
     */
    sensorType?: SensorType;
    /**
     * The settings property
     */
    settings?: SensorSettings;
    /**
     * The version property
     */
    version?: string;
}
export interface SensorCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Sensor[];
}
export interface SensorDeploymentPackage extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The downloadUrl property
     */
    downloadUrl?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The version property
     */
    version?: string;
}
export type SensorHealthStatus = (typeof SensorHealthStatusObject)[keyof typeof SensorHealthStatusObject];
export interface SensorSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The description property
     */
    description?: string;
    /**
     * The domainControllerDnsNames property
     */
    domainControllerDnsNames?: string[];
    /**
     * The isDelayedDeploymentEnabled property
     */
    isDelayedDeploymentEnabled?: boolean;
    /**
     * The networkAdapters property
     */
    networkAdapters?: NetworkAdapter[];
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type SensorType = (typeof SensorTypeObject)[keyof typeof SensorTypeObject];
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAddContentFooterAction(writer: SerializationWriter, addContentFooterAction: Partial<AddContentFooterAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, addContentFooterAction)
    writer.writeEnumValue<ContentAlignment>("alignment", addContentFooterAction.alignment);
    writer.writeStringValue("fontColor", addContentFooterAction.fontColor);
    writer.writeStringValue("fontName", addContentFooterAction.fontName);
    writer.writeNumberValue("fontSize", addContentFooterAction.fontSize);
    writer.writeNumberValue("margin", addContentFooterAction.margin);
    writer.writeStringValue("text", addContentFooterAction.text);
    writer.writeStringValue("uiElementName", addContentFooterAction.uiElementName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAddContentHeaderAction(writer: SerializationWriter, addContentHeaderAction: Partial<AddContentHeaderAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, addContentHeaderAction)
    writer.writeEnumValue<ContentAlignment>("alignment", addContentHeaderAction.alignment);
    writer.writeStringValue("fontColor", addContentHeaderAction.fontColor);
    writer.writeStringValue("fontName", addContentHeaderAction.fontName);
    writer.writeNumberValue("fontSize", addContentHeaderAction.fontSize);
    writer.writeNumberValue("margin", addContentHeaderAction.margin);
    writer.writeStringValue("text", addContentHeaderAction.text);
    writer.writeStringValue("uiElementName", addContentHeaderAction.uiElementName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAddWatermarkAction(writer: SerializationWriter, addWatermarkAction: Partial<AddWatermarkAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, addWatermarkAction)
    writer.writeStringValue("fontColor", addWatermarkAction.fontColor);
    writer.writeStringValue("fontName", addWatermarkAction.fontName);
    writer.writeNumberValue("fontSize", addWatermarkAction.fontSize);
    writer.writeEnumValue<WatermarkLayout>("layout", addWatermarkAction.layout);
    writer.writeStringValue("text", addWatermarkAction.text);
    writer.writeStringValue("uiElementName", addWatermarkAction.uiElementName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAlert(writer: SerializationWriter, alert: Partial<Alert> | undefined = {}) : void {
    serializeEntity(writer, alert)
    writer.writeStringValue("actorDisplayName", alert.actorDisplayName);
    writer.writeObjectValue<Dictionary>("additionalData", alert.additionalDataProperty, serializeDictionary);
    writer.writeStringValue("alertPolicyId", alert.alertPolicyId);
    writer.writeStringValue("alertWebUrl", alert.alertWebUrl);
    writer.writeStringValue("assignedTo", alert.assignedTo);
    writer.writeStringValue("category", alert.category);
    writer.writeEnumValue<AlertClassification>("classification", alert.classification);
    writer.writeCollectionOfObjectValues<AlertComment>("comments", alert.comments, serializeAlertComment);
    writer.writeDateValue("createdDateTime", alert.createdDateTime);
    writer.writeStringValue("description", alert.description);
    writer.writeEnumValue<DetectionSource>("detectionSource", alert.detectionSource);
    writer.writeStringValue("detectorId", alert.detectorId);
    writer.writeEnumValue<AlertDetermination>("determination", alert.determination);
    writer.writeCollectionOfObjectValues<AlertEvidence>("evidence", alert.evidence, serializeAlertEvidence);
    writer.writeDateValue("firstActivityDateTime", alert.firstActivityDateTime);
    writer.writeStringValue("incidentId", alert.incidentId);
    writer.writeStringValue("incidentWebUrl", alert.incidentWebUrl);
    writer.writeDateValue("lastActivityDateTime", alert.lastActivityDateTime);
    writer.writeDateValue("lastUpdateDateTime", alert.lastUpdateDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("mitreTechniques", alert.mitreTechniques);
    writer.writeStringValue("productName", alert.productName);
    writer.writeStringValue("providerAlertId", alert.providerAlertId);
    writer.writeStringValue("recommendedActions", alert.recommendedActions);
    writer.writeDateValue("resolvedDateTime", alert.resolvedDateTime);
    writer.writeEnumValue<ServiceSource>("serviceSource", alert.serviceSource);
    writer.writeEnumValue<AlertSeverity>("severity", alert.severity);
    writer.writeEnumValue<AlertStatus>("status", alert.status);
    writer.writeCollectionOfPrimitiveValues<string>("systemTags", alert.systemTags);
    writer.writeStringValue("tenantId", alert.tenantId);
    writer.writeStringValue("threatDisplayName", alert.threatDisplayName);
    writer.writeStringValue("threatFamilyName", alert.threatFamilyName);
    writer.writeStringValue("title", alert.title);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAlertCollectionResponse(writer: SerializationWriter, alertCollectionResponse: Partial<AlertCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, alertCollectionResponse)
    writer.writeCollectionOfObjectValues<Alert>("value", alertCollectionResponse.value, serializeAlert);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAlertComment(writer: SerializationWriter, alertComment: Partial<AlertComment> | undefined = {}) : void {
    writer.writeStringValue("comment", alertComment.comment);
    writer.writeStringValue("createdByDisplayName", alertComment.createdByDisplayName);
    writer.writeDateValue("createdDateTime", alertComment.createdDateTime);
    writer.writeStringValue("@odata.type", alertComment.odataType);
    writer.writeAdditionalData(alertComment.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAlertEvidence(writer: SerializationWriter, alertEvidence: Partial<AlertEvidence> | undefined = {}) : void {
    writer.writeDateValue("createdDateTime", alertEvidence.createdDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("detailedRoles", alertEvidence.detailedRoles);
    writer.writeStringValue("@odata.type", alertEvidence.odataType);
    writer.writeEnumValue<EvidenceRemediationStatus>("remediationStatus", alertEvidence.remediationStatus);
    writer.writeStringValue("remediationStatusDetails", alertEvidence.remediationStatusDetails);
    if(alertEvidence.roles)
    writer.writeEnumValue<EvidenceRole>("roles", ...alertEvidence.roles);
    writer.writeCollectionOfPrimitiveValues<string>("tags", alertEvidence.tags);
    writer.writeEnumValue<EvidenceVerdict>("verdict", alertEvidence.verdict);
    writer.writeAdditionalData(alertEvidence.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAlertTemplate(writer: SerializationWriter, alertTemplate: Partial<AlertTemplate> | undefined = {}) : void {
    writer.writeStringValue("category", alertTemplate.category);
    writer.writeStringValue("description", alertTemplate.description);
    writer.writeCollectionOfObjectValues<ImpactedAsset>("impactedAssets", alertTemplate.impactedAssets, serializeImpactedAsset);
    writer.writeCollectionOfPrimitiveValues<string>("mitreTechniques", alertTemplate.mitreTechniques);
    writer.writeStringValue("@odata.type", alertTemplate.odataType);
    writer.writeStringValue("recommendedActions", alertTemplate.recommendedActions);
    writer.writeEnumValue<AlertSeverity>("severity", alertTemplate.severity);
    writer.writeStringValue("title", alertTemplate.title);
    writer.writeAdditionalData(alertTemplate.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAllowFileResponseAction(writer: SerializationWriter, allowFileResponseAction: Partial<AllowFileResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, allowFileResponseAction)
    writer.writeCollectionOfPrimitiveValues<string>("deviceGroupNames", allowFileResponseAction.deviceGroupNames);
    writer.writeEnumValue<FileEntityIdentifier[]>("identifier", allowFileResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAmazonResourceEvidence(writer: SerializationWriter, amazonResourceEvidence: Partial<AmazonResourceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, amazonResourceEvidence)
    writer.writeStringValue("amazonAccountId", amazonResourceEvidence.amazonAccountId);
    writer.writeStringValue("amazonResourceId", amazonResourceEvidence.amazonResourceId);
    writer.writeStringValue("resourceName", amazonResourceEvidence.resourceName);
    writer.writeStringValue("resourceType", amazonResourceEvidence.resourceType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnalyzedEmail(writer: SerializationWriter, analyzedEmail: Partial<AnalyzedEmail> | undefined = {}) : void {
    serializeEntity(writer, analyzedEmail)
    writer.writeCollectionOfPrimitiveValues<string>("alertIds", analyzedEmail.alertIds);
    writer.writeCollectionOfObjectValues<AnalyzedEmailAttachment>("attachments", analyzedEmail.attachments, serializeAnalyzedEmailAttachment);
    writer.writeNumberValue("attachmentsCount", analyzedEmail.attachmentsCount);
    writer.writeObjectValue<AnalyzedEmailAuthenticationDetail>("authenticationDetails", analyzedEmail.authenticationDetails, serializeAnalyzedEmailAuthenticationDetail);
    writer.writeStringValue("bulkComplaintLevel", analyzedEmail.bulkComplaintLevel);
    writer.writeCollectionOfPrimitiveValues<string>("contexts", analyzedEmail.contexts);
    writer.writeCollectionOfPrimitiveValues<string>("detectionMethods", analyzedEmail.detectionMethods);
    writer.writeEnumValue<AntispamDirectionality>("directionality", analyzedEmail.directionality);
    writer.writeStringValue("distributionList", analyzedEmail.distributionList);
    writer.writeStringValue("emailClusterId", analyzedEmail.emailClusterId);
    writer.writeCollectionOfObjectValues<AnalyzedEmailExchangeTransportRuleInfo>("exchangeTransportRules", analyzedEmail.exchangeTransportRules, serializeAnalyzedEmailExchangeTransportRuleInfo);
    writer.writeStringValue("internetMessageId", analyzedEmail.internetMessageId);
    writer.writeStringValue("language", analyzedEmail.language);
    writer.writeObjectValue<AnalyzedEmailDeliveryDetail>("latestDelivery", analyzedEmail.latestDelivery, serializeAnalyzedEmailDeliveryDetail);
    writer.writeDateValue("loggedDateTime", analyzedEmail.loggedDateTime);
    writer.writeStringValue("networkMessageId", analyzedEmail.networkMessageId);
    writer.writeObjectValue<AnalyzedEmailDeliveryDetail>("originalDelivery", analyzedEmail.originalDelivery, serializeAnalyzedEmailDeliveryDetail);
    writer.writeCollectionOfPrimitiveValues<string>("overrideSources", analyzedEmail.overrideSources);
    writer.writeStringValue("phishConfidenceLevel", analyzedEmail.phishConfidenceLevel);
    writer.writeStringValue("policy", analyzedEmail.policy);
    writer.writeStringValue("policyAction", analyzedEmail.policyAction);
    writer.writeStringValue("recipientEmailAddress", analyzedEmail.recipientEmailAddress);
    writer.writeStringValue("returnPath", analyzedEmail.returnPath);
    writer.writeObjectValue<AnalyzedEmailSenderDetail>("senderDetail", analyzedEmail.senderDetail, serializeAnalyzedEmailSenderDetail);
    writer.writeNumberValue("sizeInBytes", analyzedEmail.sizeInBytes);
    writer.writeStringValue("spamConfidenceLevel", analyzedEmail.spamConfidenceLevel);
    writer.writeStringValue("subject", analyzedEmail.subject);
    if(analyzedEmail.threatTypes)
    writer.writeEnumValue<ThreatType>("threatTypes", ...analyzedEmail.threatTypes);
    writer.writeCollectionOfObjectValues<AnalyzedEmailUrl>("urls", analyzedEmail.urls, serializeAnalyzedEmailUrl);
    writer.writeNumberValue("urlsCount", analyzedEmail.urlsCount);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnalyzedEmailAttachment(writer: SerializationWriter, analyzedEmailAttachment: Partial<AnalyzedEmailAttachment> | undefined = {}) : void {
    writer.writeObjectValue<DetonationDetails>("detonationDetails", analyzedEmailAttachment.detonationDetails, serializeDetonationDetails);
    writer.writeStringValue("fileName", analyzedEmailAttachment.fileName);
    writer.writeStringValue("fileType", analyzedEmailAttachment.fileType);
    writer.writeStringValue("@odata.type", analyzedEmailAttachment.odataType);
    writer.writeStringValue("sha256", analyzedEmailAttachment.sha256);
    writer.writeStringValue("threatName", analyzedEmailAttachment.threatName);
    writer.writeEnumValue<ThreatType>("threatType", analyzedEmailAttachment.threatType);
    writer.writeAdditionalData(analyzedEmailAttachment.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnalyzedEmailAuthenticationDetail(writer: SerializationWriter, analyzedEmailAuthenticationDetail: Partial<AnalyzedEmailAuthenticationDetail> | undefined = {}) : void {
    writer.writeStringValue("compositeAuthentication", analyzedEmailAuthenticationDetail.compositeAuthentication);
    writer.writeStringValue("dkim", analyzedEmailAuthenticationDetail.dkim);
    writer.writeStringValue("dmarc", analyzedEmailAuthenticationDetail.dmarc);
    writer.writeStringValue("@odata.type", analyzedEmailAuthenticationDetail.odataType);
    writer.writeStringValue("senderPolicyFramework", analyzedEmailAuthenticationDetail.senderPolicyFramework);
    writer.writeAdditionalData(analyzedEmailAuthenticationDetail.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnalyzedEmailCollectionResponse(writer: SerializationWriter, analyzedEmailCollectionResponse: Partial<AnalyzedEmailCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, analyzedEmailCollectionResponse)
    writer.writeCollectionOfObjectValues<AnalyzedEmail>("value", analyzedEmailCollectionResponse.value, serializeAnalyzedEmail);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnalyzedEmailDeliveryDetail(writer: SerializationWriter, analyzedEmailDeliveryDetail: Partial<AnalyzedEmailDeliveryDetail> | undefined = {}) : void {
    writer.writeEnumValue<DeliveryAction>("action", analyzedEmailDeliveryDetail.action);
    writer.writeEnumValue<DeliveryLocation>("location", analyzedEmailDeliveryDetail.location);
    writer.writeStringValue("@odata.type", analyzedEmailDeliveryDetail.odataType);
    writer.writeAdditionalData(analyzedEmailDeliveryDetail.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnalyzedEmailExchangeTransportRuleInfo(writer: SerializationWriter, analyzedEmailExchangeTransportRuleInfo: Partial<AnalyzedEmailExchangeTransportRuleInfo> | undefined = {}) : void {
    writer.writeStringValue("name", analyzedEmailExchangeTransportRuleInfo.name);
    writer.writeStringValue("@odata.type", analyzedEmailExchangeTransportRuleInfo.odataType);
    writer.writeStringValue("ruleId", analyzedEmailExchangeTransportRuleInfo.ruleId);
    writer.writeAdditionalData(analyzedEmailExchangeTransportRuleInfo.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnalyzedEmailSenderDetail(writer: SerializationWriter, analyzedEmailSenderDetail: Partial<AnalyzedEmailSenderDetail> | undefined = {}) : void {
    writer.writeStringValue("fromAddress", analyzedEmailSenderDetail.fromAddress);
    writer.writeStringValue("ipv4", analyzedEmailSenderDetail.ipv4);
    writer.writeStringValue("mailFromAddress", analyzedEmailSenderDetail.mailFromAddress);
    writer.writeStringValue("@odata.type", analyzedEmailSenderDetail.odataType);
    writer.writeAdditionalData(analyzedEmailSenderDetail.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnalyzedEmailUrl(writer: SerializationWriter, analyzedEmailUrl: Partial<AnalyzedEmailUrl> | undefined = {}) : void {
    writer.writeStringValue("detectionMethod", analyzedEmailUrl.detectionMethod);
    writer.writeObjectValue<DetonationDetails>("detonationDetails", analyzedEmailUrl.detonationDetails, serializeDetonationDetails);
    writer.writeStringValue("@odata.type", analyzedEmailUrl.odataType);
    writer.writeEnumValue<ThreatType>("threatType", analyzedEmailUrl.threatType);
    writer.writeStringValue("url", analyzedEmailUrl.url);
    writer.writeAdditionalData(analyzedEmailUrl.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnalyzedMessageEvidence(writer: SerializationWriter, analyzedMessageEvidence: Partial<AnalyzedMessageEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, analyzedMessageEvidence)
    writer.writeStringValue("antiSpamDirection", analyzedMessageEvidence.antiSpamDirection);
    writer.writeNumberValue("attachmentsCount", analyzedMessageEvidence.attachmentsCount);
    writer.writeStringValue("deliveryAction", analyzedMessageEvidence.deliveryAction);
    writer.writeStringValue("deliveryLocation", analyzedMessageEvidence.deliveryLocation);
    writer.writeStringValue("internetMessageId", analyzedMessageEvidence.internetMessageId);
    writer.writeStringValue("language", analyzedMessageEvidence.language);
    writer.writeStringValue("networkMessageId", analyzedMessageEvidence.networkMessageId);
    writer.writeObjectValue<EmailSender>("p1Sender", analyzedMessageEvidence.p1Sender, serializeEmailSender);
    writer.writeObjectValue<EmailSender>("p2Sender", analyzedMessageEvidence.p2Sender, serializeEmailSender);
    writer.writeDateValue("receivedDateTime", analyzedMessageEvidence.receivedDateTime);
    writer.writeStringValue("recipientEmailAddress", analyzedMessageEvidence.recipientEmailAddress);
    writer.writeStringValue("senderIp", analyzedMessageEvidence.senderIp);
    writer.writeStringValue("subject", analyzedMessageEvidence.subject);
    writer.writeCollectionOfPrimitiveValues<string>("threatDetectionMethods", analyzedMessageEvidence.threatDetectionMethods);
    writer.writeCollectionOfPrimitiveValues<string>("threats", analyzedMessageEvidence.threats);
    writer.writeNumberValue("urlCount", analyzedMessageEvidence.urlCount);
    writer.writeCollectionOfPrimitiveValues<string>("urls", analyzedMessageEvidence.urls);
    writer.writeStringValue("urn", analyzedMessageEvidence.urn);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeApplyLabelAction(writer: SerializationWriter, applyLabelAction: Partial<ApplyLabelAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, applyLabelAction)
    writer.writeCollectionOfObjectValues<InformationProtectionAction>("actions", applyLabelAction.actions, serializeInformationProtectionAction);
    writer.writeEnumValue<ActionSource>("actionSource", applyLabelAction.actionSource);
    writer.writeCollectionOfPrimitiveValues<string>("responsibleSensitiveTypeIds", applyLabelAction.responsibleSensitiveTypeIds);
    writer.writeStringValue("sensitivityLabelId", applyLabelAction.sensitivityLabelId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeArticle(writer: SerializationWriter, article: Partial<Article> | undefined = {}) : void {
    serializeEntity(writer, article)
    writer.writeObjectValue<FormattedContent>("body", article.body, serializeFormattedContent);
    writer.writeDateValue("createdDateTime", article.createdDateTime);
    writer.writeStringValue("imageUrl", article.imageUrl);
    writer.writeCollectionOfObjectValues<ArticleIndicator>("indicators", article.indicators, serializeArticleIndicator);
    writer.writeBooleanValue("isFeatured", article.isFeatured);
    writer.writeDateValue("lastUpdatedDateTime", article.lastUpdatedDateTime);
    writer.writeObjectValue<FormattedContent>("summary", article.summary, serializeFormattedContent);
    writer.writeCollectionOfPrimitiveValues<string>("tags", article.tags);
    writer.writeStringValue("title", article.title);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeArticleCollectionResponse(writer: SerializationWriter, articleCollectionResponse: Partial<ArticleCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, articleCollectionResponse)
    writer.writeCollectionOfObjectValues<Article>("value", articleCollectionResponse.value, serializeArticle);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeArticleIndicator(writer: SerializationWriter, articleIndicator: Partial<ArticleIndicator> | undefined = {}) : void {
    serializeIndicator(writer, articleIndicator)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeArticleIndicatorCollectionResponse(writer: SerializationWriter, articleIndicatorCollectionResponse: Partial<ArticleIndicatorCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, articleIndicatorCollectionResponse)
    writer.writeCollectionOfObjectValues<ArticleIndicator>("value", articleIndicatorCollectionResponse.value, serializeArticleIndicator);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeArtifact(writer: SerializationWriter, artifact: Partial<Artifact> | undefined = {}) : void {
    serializeEntity(writer, artifact)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAttackSimulationInfo(writer: SerializationWriter, attackSimulationInfo: Partial<AttackSimulationInfo> | undefined = {}) : void {
    writer.writeDateValue("attackSimDateTime", attackSimulationInfo.attackSimDateTime);
    writer.writeDurationValue("attackSimDurationTime", attackSimulationInfo.attackSimDurationTime);
    writer.writeGuidValue("attackSimId", attackSimulationInfo.attackSimId);
    writer.writeStringValue("attackSimUserId", attackSimulationInfo.attackSimUserId);
    writer.writeStringValue("@odata.type", attackSimulationInfo.odataType);
    writer.writeAdditionalData(attackSimulationInfo.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAuditCoreRoot(writer: SerializationWriter, auditCoreRoot: Partial<AuditCoreRoot> | undefined = {}) : void {
    serializeEntity(writer, auditCoreRoot)
    writer.writeCollectionOfObjectValues<AuditLogQuery>("queries", auditCoreRoot.queries, serializeAuditLogQuery);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAuditData(writer: SerializationWriter, auditData: Partial<AuditData> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", auditData.odataType);
    writer.writeAdditionalData(auditData.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAuditLogQuery(writer: SerializationWriter, auditLogQuery: Partial<AuditLogQuery> | undefined = {}) : void {
    serializeEntity(writer, auditLogQuery)
    writer.writeCollectionOfPrimitiveValues<string>("administrativeUnitIdFilters", auditLogQuery.administrativeUnitIdFilters);
    writer.writeStringValue("displayName", auditLogQuery.displayName);
    writer.writeDateValue("filterEndDateTime", auditLogQuery.filterEndDateTime);
    writer.writeDateValue("filterStartDateTime", auditLogQuery.filterStartDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("ipAddressFilters", auditLogQuery.ipAddressFilters);
    writer.writeStringValue("keywordFilter", auditLogQuery.keywordFilter);
    writer.writeCollectionOfPrimitiveValues<string>("objectIdFilters", auditLogQuery.objectIdFilters);
    writer.writeCollectionOfPrimitiveValues<string>("operationFilters", auditLogQuery.operationFilters);
    writer.writeCollectionOfObjectValues<AuditLogRecord>("records", auditLogQuery.records, serializeAuditLogRecord);
    if(auditLogQuery.recordTypeFilters)
    writer.writeEnumValue<AuditLogRecordType>("recordTypeFilters", ...auditLogQuery.recordTypeFilters);
    writer.writeCollectionOfPrimitiveValues<string>("serviceFilters", auditLogQuery.serviceFilters);
    writer.writeEnumValue<AuditLogQueryStatus>("status", auditLogQuery.status);
    writer.writeCollectionOfPrimitiveValues<string>("userPrincipalNameFilters", auditLogQuery.userPrincipalNameFilters);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAuditLogQueryCollectionResponse(writer: SerializationWriter, auditLogQueryCollectionResponse: Partial<AuditLogQueryCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, auditLogQueryCollectionResponse)
    writer.writeCollectionOfObjectValues<AuditLogQuery>("value", auditLogQueryCollectionResponse.value, serializeAuditLogQuery);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAuditLogRecord(writer: SerializationWriter, auditLogRecord: Partial<AuditLogRecord> | undefined = {}) : void {
    serializeEntity(writer, auditLogRecord)
    writer.writeCollectionOfPrimitiveValues<string>("administrativeUnits", auditLogRecord.administrativeUnits);
    writer.writeObjectValue<AuditData>("auditData", auditLogRecord.auditData, serializeAuditData);
    writer.writeEnumValue<AuditLogRecordType>("auditLogRecordType", auditLogRecord.auditLogRecordType);
    writer.writeStringValue("clientIp", auditLogRecord.clientIp);
    writer.writeDateValue("createdDateTime", auditLogRecord.createdDateTime);
    writer.writeStringValue("objectId", auditLogRecord.objectId);
    writer.writeStringValue("operation", auditLogRecord.operation);
    writer.writeStringValue("organizationId", auditLogRecord.organizationId);
    writer.writeStringValue("service", auditLogRecord.service);
    writer.writeStringValue("userId", auditLogRecord.userId);
    writer.writeStringValue("userPrincipalName", auditLogRecord.userPrincipalName);
    writer.writeEnumValue<AuditLogUserType>("userType", auditLogRecord.userType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAuditLogRecordCollectionResponse(writer: SerializationWriter, auditLogRecordCollectionResponse: Partial<AuditLogRecordCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, auditLogRecordCollectionResponse)
    writer.writeCollectionOfObjectValues<AuditLogRecord>("value", auditLogRecordCollectionResponse.value, serializeAuditLogRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAuthorityTemplate(writer: SerializationWriter, authorityTemplate: Partial<AuthorityTemplate> | undefined = {}) : void {
    serializeFilePlanDescriptorTemplate(writer, authorityTemplate)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAuthorityTemplateCollectionResponse(writer: SerializationWriter, authorityTemplateCollectionResponse: Partial<AuthorityTemplateCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, authorityTemplateCollectionResponse)
    writer.writeCollectionOfObjectValues<AuthorityTemplate>("value", authorityTemplateCollectionResponse.value, serializeAuthorityTemplate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAutonomousSystem(writer: SerializationWriter, autonomousSystem: Partial<AutonomousSystem> | undefined = {}) : void {
    writer.writeStringValue("name", autonomousSystem.name);
    writer.writeNumberValue("number", autonomousSystem.number);
    writer.writeStringValue("@odata.type", autonomousSystem.odataType);
    writer.writeStringValue("organization", autonomousSystem.organization);
    writer.writeStringValue("value", autonomousSystem.value);
    writer.writeAdditionalData(autonomousSystem.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAzureResourceEvidence(writer: SerializationWriter, azureResourceEvidence: Partial<AzureResourceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, azureResourceEvidence)
    writer.writeStringValue("resourceId", azureResourceEvidence.resourceId);
    writer.writeStringValue("resourceName", azureResourceEvidence.resourceName);
    writer.writeStringValue("resourceType", azureResourceEvidence.resourceType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeBlobContainerEvidence(writer: SerializationWriter, blobContainerEvidence: Partial<BlobContainerEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, blobContainerEvidence)
    writer.writeStringValue("name", blobContainerEvidence.name);
    writer.writeObjectValue<AzureResourceEvidence>("storageResource", blobContainerEvidence.storageResource, serializeAzureResourceEvidence);
    writer.writeStringValue("url", blobContainerEvidence.url);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeBlobEvidence(writer: SerializationWriter, blobEvidence: Partial<BlobEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, blobEvidence)
    writer.writeObjectValue<BlobContainerEvidence>("blobContainer", blobEvidence.blobContainer, serializeBlobContainerEvidence);
    writer.writeStringValue("etag", blobEvidence.etag);
    writer.writeCollectionOfObjectValues<FileHash>("fileHashes", blobEvidence.fileHashes, serializeFileHash);
    writer.writeStringValue("name", blobEvidence.name);
    writer.writeStringValue("url", blobEvidence.url);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeBlockFileResponseAction(writer: SerializationWriter, blockFileResponseAction: Partial<BlockFileResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, blockFileResponseAction)
    writer.writeCollectionOfPrimitiveValues<string>("deviceGroupNames", blockFileResponseAction.deviceGroupNames);
    writer.writeEnumValue<FileEntityIdentifier[]>("identifier", blockFileResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseEscaped(writer: SerializationWriter, caseEscaped: Partial<CaseEscaped> | undefined = {}) : void {
    serializeEntity(writer, caseEscaped)
    writer.writeDateValue("createdDateTime", caseEscaped.createdDateTime);
    writer.writeStringValue("description", caseEscaped.description);
    writer.writeStringValue("displayName", caseEscaped.displayName);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", caseEscaped.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", caseEscaped.lastModifiedDateTime);
    writer.writeEnumValue<CaseStatus>("status", caseEscaped.status);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseOperation(writer: SerializationWriter, caseOperation: Partial<CaseOperation> | undefined = {}) : void {
    serializeEntity(writer, caseOperation)
    writer.writeEnumValue<CaseAction>("action", caseOperation.action);
    writer.writeDateValue("completedDateTime", caseOperation.completedDateTime);
    writer.writeObjectValue<IdentitySet>("createdBy", caseOperation.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", caseOperation.createdDateTime);
    writer.writeNumberValue("percentProgress", caseOperation.percentProgress);
    writer.writeObjectValue<ResultInfo>("resultInfo", caseOperation.resultInfo, serializeResultInfo);
    writer.writeEnumValue<CaseOperationStatus>("status", caseOperation.status);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseOperationCollectionResponse(writer: SerializationWriter, caseOperationCollectionResponse: Partial<CaseOperationCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, caseOperationCollectionResponse)
    writer.writeCollectionOfObjectValues<CaseOperation>("value", caseOperationCollectionResponse.value, serializeCaseOperation);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCasesRoot(writer: SerializationWriter, casesRoot: Partial<CasesRoot> | undefined = {}) : void {
    serializeEntity(writer, casesRoot)
    writer.writeCollectionOfObjectValues<EdiscoveryCase>("ediscoveryCases", casesRoot.ediscoveryCases, serializeEdiscoveryCase);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCategoryTemplate(writer: SerializationWriter, categoryTemplate: Partial<CategoryTemplate> | undefined = {}) : void {
    serializeFilePlanDescriptorTemplate(writer, categoryTemplate)
    writer.writeCollectionOfObjectValues<SubcategoryTemplate>("subcategories", categoryTemplate.subcategories, serializeSubcategoryTemplate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCategoryTemplateCollectionResponse(writer: SerializationWriter, categoryTemplateCollectionResponse: Partial<CategoryTemplateCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, categoryTemplateCollectionResponse)
    writer.writeCollectionOfObjectValues<CategoryTemplate>("value", categoryTemplateCollectionResponse.value, serializeCategoryTemplate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCitationTemplate(writer: SerializationWriter, citationTemplate: Partial<CitationTemplate> | undefined = {}) : void {
    serializeFilePlanDescriptorTemplate(writer, citationTemplate)
    writer.writeStringValue("citationJurisdiction", citationTemplate.citationJurisdiction);
    writer.writeStringValue("citationUrl", citationTemplate.citationUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCitationTemplateCollectionResponse(writer: SerializationWriter, citationTemplateCollectionResponse: Partial<CitationTemplateCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, citationTemplateCollectionResponse)
    writer.writeCollectionOfObjectValues<CitationTemplate>("value", citationTemplateCollectionResponse.value, serializeCitationTemplate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeClassificationResult(writer: SerializationWriter, classificationResult: Partial<ClassificationResult> | undefined = {}) : void {
    writer.writeNumberValue("confidenceLevel", classificationResult.confidenceLevel);
    writer.writeNumberValue("count", classificationResult.count);
    writer.writeStringValue("@odata.type", classificationResult.odataType);
    writer.writeStringValue("sensitiveTypeId", classificationResult.sensitiveTypeId);
    writer.writeAdditionalData(classificationResult.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCloudApplicationEvidence(writer: SerializationWriter, cloudApplicationEvidence: Partial<CloudApplicationEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, cloudApplicationEvidence)
    writer.writeNumberValue("appId", cloudApplicationEvidence.appId);
    writer.writeStringValue("displayName", cloudApplicationEvidence.displayName);
    writer.writeNumberValue("instanceId", cloudApplicationEvidence.instanceId);
    writer.writeStringValue("instanceName", cloudApplicationEvidence.instanceName);
    writer.writeNumberValue("saasAppId", cloudApplicationEvidence.saasAppId);
    writer.writeObjectValue<Stream>("stream", cloudApplicationEvidence.stream, serializeStream);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCollaborationRoot(writer: SerializationWriter, collaborationRoot: Partial<CollaborationRoot> | undefined = {}) : void {
    serializeEntity(writer, collaborationRoot)
    writer.writeCollectionOfObjectValues<AnalyzedEmail>("analyzedEmails", collaborationRoot.analyzedEmails, serializeAnalyzedEmail);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCollectInvestigationPackageResponseAction(writer: SerializationWriter, collectInvestigationPackageResponseAction: Partial<CollectInvestigationPackageResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, collectInvestigationPackageResponseAction)
    writer.writeEnumValue<DeviceIdEntityIdentifier[]>("identifier", collectInvestigationPackageResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContainerEvidence(writer: SerializationWriter, containerEvidence: Partial<ContainerEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, containerEvidence)
    writer.writeCollectionOfPrimitiveValues<string>("args", containerEvidence.args);
    writer.writeCollectionOfPrimitiveValues<string>("command", containerEvidence.command);
    writer.writeStringValue("containerId", containerEvidence.containerId);
    writer.writeObjectValue<ContainerImageEvidence>("image", containerEvidence.image, serializeContainerImageEvidence);
    writer.writeBooleanValue("isPrivileged", containerEvidence.isPrivileged);
    writer.writeStringValue("name", containerEvidence.name);
    writer.writeObjectValue<KubernetesPodEvidence>("pod", containerEvidence.pod, serializeKubernetesPodEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContainerImageEvidence(writer: SerializationWriter, containerImageEvidence: Partial<ContainerImageEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, containerImageEvidence)
    writer.writeObjectValue<ContainerImageEvidence>("digestImage", containerImageEvidence.digestImage, serializeContainerImageEvidence);
    writer.writeStringValue("imageId", containerImageEvidence.imageId);
    writer.writeObjectValue<ContainerRegistryEvidence>("registry", containerImageEvidence.registry, serializeContainerRegistryEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContainerRegistryEvidence(writer: SerializationWriter, containerRegistryEvidence: Partial<ContainerRegistryEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, containerRegistryEvidence)
    writer.writeStringValue("registry", containerRegistryEvidence.registry);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContentInfo(writer: SerializationWriter, contentInfo: Partial<ContentInfo> | undefined = {}) : void {
    writer.writeStringValue("contentFormat", contentInfo.contentFormat);
    writer.writeStringValue("identifier", contentInfo.identifier);
    writer.writeCollectionOfObjectValues<KeyValuePair>("metadata", contentInfo.metadata, serializeKeyValuePair);
    writer.writeStringValue("@odata.type", contentInfo.odataType);
    writer.writeEnumValue<ContentState>("state", contentInfo.state);
    writer.writeAdditionalData(contentInfo.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContentLabel(writer: SerializationWriter, contentLabel: Partial<ContentLabel> | undefined = {}) : void {
    writer.writeEnumValue<AssignmentMethod>("assignmentMethod", contentLabel.assignmentMethod);
    writer.writeDateValue("createdDateTime", contentLabel.createdDateTime);
    writer.writeStringValue("@odata.type", contentLabel.odataType);
    writer.writeStringValue("sensitivityLabelId", contentLabel.sensitivityLabelId);
    writer.writeAdditionalData(contentLabel.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCustomAction(writer: SerializationWriter, customAction: Partial<CustomAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, customAction)
    writer.writeStringValue("name", customAction.name);
    writer.writeCollectionOfObjectValues<KeyValuePair>("properties", customAction.properties, serializeKeyValuePair);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCvssSummary(writer: SerializationWriter, cvssSummary: Partial<CvssSummary> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", cvssSummary.odataType);
    writer.writeNumberValue("score", cvssSummary.score);
    writer.writeEnumValue<VulnerabilitySeverity>("severity", cvssSummary.severity);
    writer.writeStringValue("vectorString", cvssSummary.vectorString);
    writer.writeAdditionalData(cvssSummary.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDataSet(writer: SerializationWriter, dataSet: Partial<DataSet> | undefined = {}) : void {
    serializeEntity(writer, dataSet)
    writer.writeObjectValue<IdentitySet>("createdBy", dataSet.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", dataSet.createdDateTime);
    writer.writeStringValue("displayName", dataSet.displayName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDataSource(writer: SerializationWriter, dataSource: Partial<DataSource> | undefined = {}) : void {
    serializeEntity(writer, dataSource)
    writer.writeObjectValue<IdentitySet>("createdBy", dataSource.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", dataSource.createdDateTime);
    writer.writeStringValue("displayName", dataSource.displayName);
    writer.writeEnumValue<DataSourceHoldStatus>("holdStatus", dataSource.holdStatus);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDataSourceCollectionResponse(writer: SerializationWriter, dataSourceCollectionResponse: Partial<DataSourceCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, dataSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<DataSource>("value", dataSourceCollectionResponse.value, serializeDataSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDataSourceContainer(writer: SerializationWriter, dataSourceContainer: Partial<DataSourceContainer> | undefined = {}) : void {
    serializeEntity(writer, dataSourceContainer)
    writer.writeDateValue("createdDateTime", dataSourceContainer.createdDateTime);
    writer.writeStringValue("displayName", dataSourceContainer.displayName);
    writer.writeEnumValue<DataSourceHoldStatus>("holdStatus", dataSourceContainer.holdStatus);
    writer.writeDateValue("lastModifiedDateTime", dataSourceContainer.lastModifiedDateTime);
    writer.writeDateValue("releasedDateTime", dataSourceContainer.releasedDateTime);
    writer.writeEnumValue<DataSourceContainerStatus>("status", dataSourceContainer.status);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDefaultAuditData(writer: SerializationWriter, defaultAuditData: Partial<DefaultAuditData> | undefined = {}) : void {
    serializeAuditData(writer, defaultAuditData)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDepartmentTemplate(writer: SerializationWriter, departmentTemplate: Partial<DepartmentTemplate> | undefined = {}) : void {
    serializeFilePlanDescriptorTemplate(writer, departmentTemplate)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDepartmentTemplateCollectionResponse(writer: SerializationWriter, departmentTemplateCollectionResponse: Partial<DepartmentTemplateCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, departmentTemplateCollectionResponse)
    writer.writeCollectionOfObjectValues<DepartmentTemplate>("value", departmentTemplateCollectionResponse.value, serializeDepartmentTemplate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeploymentAccessKeyType(writer: SerializationWriter, deploymentAccessKeyType: Partial<DeploymentAccessKeyType> | undefined = {}) : void {
    writer.writeStringValue("deploymentAccessKey", deploymentAccessKeyType.deploymentAccessKey);
    writer.writeStringValue("@odata.type", deploymentAccessKeyType.odataType);
    writer.writeAdditionalData(deploymentAccessKeyType.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDetectionAction(writer: SerializationWriter, detectionAction: Partial<DetectionAction> | undefined = {}) : void {
    writer.writeObjectValue<AlertTemplate>("alertTemplate", detectionAction.alertTemplate, serializeAlertTemplate);
    writer.writeStringValue("@odata.type", detectionAction.odataType);
    writer.writeObjectValue<OrganizationalScope>("organizationalScope", detectionAction.organizationalScope, serializeOrganizationalScope);
    writer.writeCollectionOfObjectValues<ResponseAction>("responseActions", detectionAction.responseActions, serializeResponseAction);
    writer.writeAdditionalData(detectionAction.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDetectionRule(writer: SerializationWriter, detectionRule: Partial<DetectionRule> | undefined = {}) : void {
    serializeProtectionRule(writer, detectionRule)
    writer.writeObjectValue<DetectionAction>("detectionAction", detectionRule.detectionAction, serializeDetectionAction);
    writer.writeStringValue("detectorId", detectionRule.detectorId);
    writer.writeObjectValue<RunDetails>("lastRunDetails", detectionRule.lastRunDetails, serializeRunDetails);
    writer.writeObjectValue<QueryCondition>("queryCondition", detectionRule.queryCondition, serializeQueryCondition);
    writer.writeObjectValue<RuleSchedule>("schedule", detectionRule.schedule, serializeRuleSchedule);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDetectionRuleCollectionResponse(writer: SerializationWriter, detectionRuleCollectionResponse: Partial<DetectionRuleCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, detectionRuleCollectionResponse)
    writer.writeCollectionOfObjectValues<DetectionRule>("value", detectionRuleCollectionResponse.value, serializeDetectionRule);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDetonationChain(writer: SerializationWriter, detonationChain: Partial<DetonationChain> | undefined = {}) : void {
    writer.writeCollectionOfObjectValues<DetonationChain>("childNodes", detonationChain.childNodes, serializeDetonationChain);
    writer.writeStringValue("@odata.type", detonationChain.odataType);
    writer.writeStringValue("value", detonationChain.value);
    writer.writeAdditionalData(detonationChain.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDetonationDetails(writer: SerializationWriter, detonationDetails: Partial<DetonationDetails> | undefined = {}) : void {
    writer.writeDateValue("analysisDateTime", detonationDetails.analysisDateTime);
    writer.writeObjectValue<DetonationChain>("detonationChain", detonationDetails.detonationChain, serializeDetonationChain);
    writer.writeObjectValue<DetonationObservables>("detonationObservables", detonationDetails.detonationObservables, serializeDetonationObservables);
    writer.writeStringValue("detonationVerdict", detonationDetails.detonationVerdict);
    writer.writeStringValue("detonationVerdictReason", detonationDetails.detonationVerdictReason);
    writer.writeStringValue("@odata.type", detonationDetails.odataType);
    writer.writeAdditionalData(detonationDetails.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDetonationObservables(writer: SerializationWriter, detonationObservables: Partial<DetonationObservables> | undefined = {}) : void {
    writer.writeCollectionOfPrimitiveValues<string>("contactedIps", detonationObservables.contactedIps);
    writer.writeCollectionOfPrimitiveValues<string>("contactedUrls", detonationObservables.contactedUrls);
    writer.writeCollectionOfPrimitiveValues<string>("droppedfiles", detonationObservables.droppedfiles);
    writer.writeStringValue("@odata.type", detonationObservables.odataType);
    writer.writeAdditionalData(detonationObservables.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeviceEvidence(writer: SerializationWriter, deviceEvidence: Partial<DeviceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, deviceEvidence)
    writer.writeStringValue("azureAdDeviceId", deviceEvidence.azureAdDeviceId);
    writer.writeEnumValue<DefenderAvStatus>("defenderAvStatus", deviceEvidence.defenderAvStatus);
    writer.writeStringValue("deviceDnsName", deviceEvidence.deviceDnsName);
    writer.writeDateValue("firstSeenDateTime", deviceEvidence.firstSeenDateTime);
    writer.writeEnumValue<DeviceHealthStatus>("healthStatus", deviceEvidence.healthStatus);
    writer.writeCollectionOfPrimitiveValues<string>("ipInterfaces", deviceEvidence.ipInterfaces);
    writer.writeStringValue("lastExternalIpAddress", deviceEvidence.lastExternalIpAddress);
    writer.writeStringValue("lastIpAddress", deviceEvidence.lastIpAddress);
    writer.writeCollectionOfObjectValues<LoggedOnUser>("loggedOnUsers", deviceEvidence.loggedOnUsers, serializeLoggedOnUser);
    writer.writeStringValue("mdeDeviceId", deviceEvidence.mdeDeviceId);
    writer.writeEnumValue<OnboardingStatus>("onboardingStatus", deviceEvidence.onboardingStatus);
    writer.writeNumberValue("osBuild", deviceEvidence.osBuild);
    writer.writeStringValue("osPlatform", deviceEvidence.osPlatform);
    writer.writeNumberValue("rbacGroupId", deviceEvidence.rbacGroupId);
    writer.writeStringValue("rbacGroupName", deviceEvidence.rbacGroupName);
    writer.writeEnumValue<DeviceRiskScore>("riskScore", deviceEvidence.riskScore);
    writer.writeStringValue("version", deviceEvidence.version);
    writer.writeObjectValue<VmMetadata>("vmMetadata", deviceEvidence.vmMetadata, serializeVmMetadata);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDictionary(writer: SerializationWriter, dictionary: Partial<Dictionary> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", dictionary.odataType);
    writer.writeAdditionalData(dictionary.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDisableUserResponseAction(writer: SerializationWriter, disableUserResponseAction: Partial<DisableUserResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, disableUserResponseAction)
    writer.writeEnumValue<DisableUserEntityIdentifier[]>("identifier", disableUserResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDispositionReviewStage(writer: SerializationWriter, dispositionReviewStage: Partial<DispositionReviewStage> | undefined = {}) : void {
    serializeEntity(writer, dispositionReviewStage)
    writer.writeStringValue("name", dispositionReviewStage.name);
    writer.writeCollectionOfPrimitiveValues<string>("reviewersEmailAddresses", dispositionReviewStage.reviewersEmailAddresses);
    writer.writeStringValue("stageNumber", dispositionReviewStage.stageNumber);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDispositionReviewStageCollectionResponse(writer: SerializationWriter, dispositionReviewStageCollectionResponse: Partial<DispositionReviewStageCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, dispositionReviewStageCollectionResponse)
    writer.writeCollectionOfObjectValues<DispositionReviewStage>("value", dispositionReviewStageCollectionResponse.value, serializeDispositionReviewStage);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDnsEvidence(writer: SerializationWriter, dnsEvidence: Partial<DnsEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, dnsEvidence)
    writer.writeObjectValue<IpEvidence>("dnsServerIp", dnsEvidence.dnsServerIp, serializeIpEvidence);
    writer.writeStringValue("domainName", dnsEvidence.domainName);
    writer.writeObjectValue<IpEvidence>("hostIpAddress", dnsEvidence.hostIpAddress, serializeIpEvidence);
    writer.writeCollectionOfObjectValues<IpEvidence>("ipAddresses", dnsEvidence.ipAddresses, serializeIpEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDowngradeJustification(writer: SerializationWriter, downgradeJustification: Partial<DowngradeJustification> | undefined = {}) : void {
    writer.writeBooleanValue("isDowngradeJustified", downgradeJustification.isDowngradeJustified);
    writer.writeStringValue("justificationMessage", downgradeJustification.justificationMessage);
    writer.writeStringValue("@odata.type", downgradeJustification.odataType);
    writer.writeAdditionalData(downgradeJustification.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryAddToReviewSetOperation(writer: SerializationWriter, ediscoveryAddToReviewSetOperation: Partial<EdiscoveryAddToReviewSetOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryAddToReviewSetOperation)
    writer.writeObjectValue<EdiscoveryReviewSet>("reviewSet", ediscoveryAddToReviewSetOperation.reviewSet, serializeEdiscoveryReviewSet);
    writer.writeObjectValue<EdiscoverySearch>("search", ediscoveryAddToReviewSetOperation.search, serializeEdiscoverySearch);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryCase(writer: SerializationWriter, ediscoveryCase: Partial<EdiscoveryCase> | undefined = {}) : void {
    serializeCaseEscaped(writer, ediscoveryCase)
    writer.writeObjectValue<IdentitySet>("closedBy", ediscoveryCase.closedBy, serializeIdentitySet);
    writer.writeDateValue("closedDateTime", ediscoveryCase.closedDateTime);
    writer.writeCollectionOfObjectValues<EdiscoveryCustodian>("custodians", ediscoveryCase.custodians, serializeEdiscoveryCustodian);
    writer.writeStringValue("externalId", ediscoveryCase.externalId);
    writer.writeCollectionOfObjectValues<EdiscoveryHoldPolicy>("legalHolds", ediscoveryCase.legalHolds, serializeEdiscoveryHoldPolicy);
    writer.writeCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>("noncustodialDataSources", ediscoveryCase.noncustodialDataSources, serializeEdiscoveryNoncustodialDataSource);
    writer.writeCollectionOfObjectValues<CaseOperation>("operations", ediscoveryCase.operations, serializeCaseOperation);
    writer.writeCollectionOfObjectValues<EdiscoveryReviewSet>("reviewSets", ediscoveryCase.reviewSets, serializeEdiscoveryReviewSet);
    writer.writeCollectionOfObjectValues<EdiscoverySearch>("searches", ediscoveryCase.searches, serializeEdiscoverySearch);
    writer.writeObjectValue<EdiscoveryCaseSettings>("settings", ediscoveryCase.settings, serializeEdiscoveryCaseSettings);
    writer.writeCollectionOfObjectValues<EdiscoveryReviewTag>("tags", ediscoveryCase.tags, serializeEdiscoveryReviewTag);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryCaseCollectionResponse(writer: SerializationWriter, ediscoveryCaseCollectionResponse: Partial<EdiscoveryCaseCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryCaseCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryCase>("value", ediscoveryCaseCollectionResponse.value, serializeEdiscoveryCase);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryCaseSettings(writer: SerializationWriter, ediscoveryCaseSettings: Partial<EdiscoveryCaseSettings> | undefined = {}) : void {
    serializeEntity(writer, ediscoveryCaseSettings)
    writer.writeObjectValue<OcrSettings>("ocr", ediscoveryCaseSettings.ocr, serializeOcrSettings);
    writer.writeObjectValue<RedundancyDetectionSettings>("redundancyDetection", ediscoveryCaseSettings.redundancyDetection, serializeRedundancyDetectionSettings);
    writer.writeObjectValue<TopicModelingSettings>("topicModeling", ediscoveryCaseSettings.topicModeling, serializeTopicModelingSettings);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryCustodian(writer: SerializationWriter, ediscoveryCustodian: Partial<EdiscoveryCustodian> | undefined = {}) : void {
    serializeDataSourceContainer(writer, ediscoveryCustodian)
    writer.writeDateValue("acknowledgedDateTime", ediscoveryCustodian.acknowledgedDateTime);
    writer.writeStringValue("email", ediscoveryCustodian.email);
    writer.writeObjectValue<EdiscoveryIndexOperation>("lastIndexOperation", ediscoveryCustodian.lastIndexOperation, serializeEdiscoveryIndexOperation);
    writer.writeCollectionOfObjectValues<SiteSource>("siteSources", ediscoveryCustodian.siteSources, serializeSiteSource);
    writer.writeCollectionOfObjectValues<UnifiedGroupSource>("unifiedGroupSources", ediscoveryCustodian.unifiedGroupSources, serializeUnifiedGroupSource);
    writer.writeCollectionOfObjectValues<UserSource>("userSources", ediscoveryCustodian.userSources, serializeUserSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryCustodianCollectionResponse(writer: SerializationWriter, ediscoveryCustodianCollectionResponse: Partial<EdiscoveryCustodianCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryCustodianCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryCustodian>("value", ediscoveryCustodianCollectionResponse.value, serializeEdiscoveryCustodian);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryEstimateOperation(writer: SerializationWriter, ediscoveryEstimateOperation: Partial<EdiscoveryEstimateOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryEstimateOperation)
    writer.writeNumberValue("indexedItemCount", ediscoveryEstimateOperation.indexedItemCount);
    writer.writeNumberValue("indexedItemsSize", ediscoveryEstimateOperation.indexedItemsSize);
    writer.writeNumberValue("mailboxCount", ediscoveryEstimateOperation.mailboxCount);
    writer.writeObjectValue<EdiscoverySearch>("search", ediscoveryEstimateOperation.search, serializeEdiscoverySearch);
    writer.writeNumberValue("siteCount", ediscoveryEstimateOperation.siteCount);
    writer.writeNumberValue("unindexedItemCount", ediscoveryEstimateOperation.unindexedItemCount);
    writer.writeNumberValue("unindexedItemsSize", ediscoveryEstimateOperation.unindexedItemsSize);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryExportOperation(writer: SerializationWriter, ediscoveryExportOperation: Partial<EdiscoveryExportOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryExportOperation)
    writer.writeStringValue("azureBlobContainer", ediscoveryExportOperation.azureBlobContainer);
    writer.writeStringValue("azureBlobToken", ediscoveryExportOperation.azureBlobToken);
    writer.writeStringValue("description", ediscoveryExportOperation.description);
    writer.writeCollectionOfObjectValues<ExportFileMetadata>("exportFileMetadata", ediscoveryExportOperation.exportFileMetadata, serializeExportFileMetadata);
    writer.writeEnumValue<ExportOptions[]>("exportOptions", ediscoveryExportOperation.exportOptions);
    writer.writeEnumValue<ExportFileStructure>("exportStructure", ediscoveryExportOperation.exportStructure);
    writer.writeStringValue("outputFolderId", ediscoveryExportOperation.outputFolderId);
    writer.writeStringValue("outputName", ediscoveryExportOperation.outputName);
    writer.writeObjectValue<EdiscoveryReviewSet>("reviewSet", ediscoveryExportOperation.reviewSet, serializeEdiscoveryReviewSet);
    writer.writeObjectValue<EdiscoveryReviewSetQuery>("reviewSetQuery", ediscoveryExportOperation.reviewSetQuery, serializeEdiscoveryReviewSetQuery);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryFile(writer: SerializationWriter, ediscoveryFile: Partial<EdiscoveryFile> | undefined = {}) : void {
    serializeFile(writer, ediscoveryFile)
    writer.writeObjectValue<EdiscoveryCustodian>("custodian", ediscoveryFile.custodian, serializeEdiscoveryCustodian);
    writer.writeCollectionOfObjectValues<EdiscoveryReviewTag>("tags", ediscoveryFile.tags, serializeEdiscoveryReviewTag);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryFileCollectionResponse(writer: SerializationWriter, ediscoveryFileCollectionResponse: Partial<EdiscoveryFileCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryFileCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryFile>("value", ediscoveryFileCollectionResponse.value, serializeEdiscoveryFile);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryHoldOperation(writer: SerializationWriter, ediscoveryHoldOperation: Partial<EdiscoveryHoldOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryHoldOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryHoldPolicy(writer: SerializationWriter, ediscoveryHoldPolicy: Partial<EdiscoveryHoldPolicy> | undefined = {}) : void {
    serializePolicyBase(writer, ediscoveryHoldPolicy)
    writer.writeStringValue("contentQuery", ediscoveryHoldPolicy.contentQuery);
    writer.writeCollectionOfPrimitiveValues<string>("errors", ediscoveryHoldPolicy.errors);
    writer.writeBooleanValue("isEnabled", ediscoveryHoldPolicy.isEnabled);
    writer.writeCollectionOfObjectValues<SiteSource>("siteSources", ediscoveryHoldPolicy.siteSources, serializeSiteSource);
    writer.writeCollectionOfObjectValues<UserSource>("userSources", ediscoveryHoldPolicy.userSources, serializeUserSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryHoldPolicyCollectionResponse(writer: SerializationWriter, ediscoveryHoldPolicyCollectionResponse: Partial<EdiscoveryHoldPolicyCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryHoldPolicyCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryHoldPolicy>("value", ediscoveryHoldPolicyCollectionResponse.value, serializeEdiscoveryHoldPolicy);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryIndexOperation(writer: SerializationWriter, ediscoveryIndexOperation: Partial<EdiscoveryIndexOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryIndexOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryNoncustodialDataSource(writer: SerializationWriter, ediscoveryNoncustodialDataSource: Partial<EdiscoveryNoncustodialDataSource> | undefined = {}) : void {
    serializeDataSourceContainer(writer, ediscoveryNoncustodialDataSource)
    writer.writeObjectValue<DataSource>("dataSource", ediscoveryNoncustodialDataSource.dataSource, serializeDataSource);
    writer.writeObjectValue<EdiscoveryIndexOperation>("lastIndexOperation", ediscoveryNoncustodialDataSource.lastIndexOperation, serializeEdiscoveryIndexOperation);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryNoncustodialDataSourceCollectionResponse(writer: SerializationWriter, ediscoveryNoncustodialDataSourceCollectionResponse: Partial<EdiscoveryNoncustodialDataSourceCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryNoncustodialDataSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>("value", ediscoveryNoncustodialDataSourceCollectionResponse.value, serializeEdiscoveryNoncustodialDataSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryPurgeDataOperation(writer: SerializationWriter, ediscoveryPurgeDataOperation: Partial<EdiscoveryPurgeDataOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryPurgeDataOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewSet(writer: SerializationWriter, ediscoveryReviewSet: Partial<EdiscoveryReviewSet> | undefined = {}) : void {
    serializeDataSet(writer, ediscoveryReviewSet)
    writer.writeCollectionOfObjectValues<EdiscoveryFile>("files", ediscoveryReviewSet.files, serializeEdiscoveryFile);
    writer.writeCollectionOfObjectValues<EdiscoveryReviewSetQuery>("queries", ediscoveryReviewSet.queries, serializeEdiscoveryReviewSetQuery);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewSetCollectionResponse(writer: SerializationWriter, ediscoveryReviewSetCollectionResponse: Partial<EdiscoveryReviewSetCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryReviewSetCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryReviewSet>("value", ediscoveryReviewSetCollectionResponse.value, serializeEdiscoveryReviewSet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewSetQuery(writer: SerializationWriter, ediscoveryReviewSetQuery: Partial<EdiscoveryReviewSetQuery> | undefined = {}) : void {
    serializeSearch(writer, ediscoveryReviewSetQuery)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewSetQueryCollectionResponse(writer: SerializationWriter, ediscoveryReviewSetQueryCollectionResponse: Partial<EdiscoveryReviewSetQueryCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryReviewSetQueryCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryReviewSetQuery>("value", ediscoveryReviewSetQueryCollectionResponse.value, serializeEdiscoveryReviewSetQuery);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewTag(writer: SerializationWriter, ediscoveryReviewTag: Partial<EdiscoveryReviewTag> | undefined = {}) : void {
    serializeTag(writer, ediscoveryReviewTag)
    writer.writeEnumValue<ChildSelectability>("childSelectability", ediscoveryReviewTag.childSelectability);
    writer.writeCollectionOfObjectValues<EdiscoveryReviewTag>("childTags", ediscoveryReviewTag.childTags, serializeEdiscoveryReviewTag);
    writer.writeObjectValue<EdiscoveryReviewTag>("parent", ediscoveryReviewTag.parent, serializeEdiscoveryReviewTag);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewTagCollectionResponse(writer: SerializationWriter, ediscoveryReviewTagCollectionResponse: Partial<EdiscoveryReviewTagCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryReviewTagCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryReviewTag>("value", ediscoveryReviewTagCollectionResponse.value, serializeEdiscoveryReviewTag);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoverySearch(writer: SerializationWriter, ediscoverySearch: Partial<EdiscoverySearch> | undefined = {}) : void {
    serializeSearch(writer, ediscoverySearch)
    writer.writeCollectionOfObjectValues<DataSource>("additionalSources", ediscoverySearch.additionalSources, serializeDataSource);
    writer.writeObjectValue<EdiscoveryAddToReviewSetOperation>("addToReviewSetOperation", ediscoverySearch.addToReviewSetOperation, serializeEdiscoveryAddToReviewSetOperation);
    writer.writeCollectionOfObjectValues<DataSource>("custodianSources", ediscoverySearch.custodianSources, serializeDataSource);
    writer.writeEnumValue<DataSourceScopes[]>("dataSourceScopes", ediscoverySearch.dataSourceScopes);
    writer.writeObjectValue<EdiscoveryEstimateOperation>("lastEstimateStatisticsOperation", ediscoverySearch.lastEstimateStatisticsOperation, serializeEdiscoveryEstimateOperation);
    writer.writeCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>("noncustodialSources", ediscoverySearch.noncustodialSources, serializeEdiscoveryNoncustodialDataSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoverySearchCollectionResponse(writer: SerializationWriter, ediscoverySearchCollectionResponse: Partial<EdiscoverySearchCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoverySearchCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoverySearch>("value", ediscoverySearchCollectionResponse.value, serializeEdiscoverySearch);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoverySearchExportOperation(writer: SerializationWriter, ediscoverySearchExportOperation: Partial<EdiscoverySearchExportOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoverySearchExportOperation)
    writer.writeEnumValue<AdditionalOptions[]>("additionalOptions", ediscoverySearchExportOperation.additionalOptions);
    writer.writeStringValue("description", ediscoverySearchExportOperation.description);
    writer.writeStringValue("displayName", ediscoverySearchExportOperation.displayName);
    writer.writeEnumValue<ExportCriteria[]>("exportCriteria", ediscoverySearchExportOperation.exportCriteria);
    writer.writeCollectionOfObjectValues<ExportFileMetadata>("exportFileMetadata", ediscoverySearchExportOperation.exportFileMetadata, serializeExportFileMetadata);
    writer.writeEnumValue<ExportFormat>("exportFormat", ediscoverySearchExportOperation.exportFormat);
    writer.writeEnumValue<ExportLocation[]>("exportLocation", ediscoverySearchExportOperation.exportLocation);
    writer.writeBooleanValue("exportSingleItems", ediscoverySearchExportOperation.exportSingleItems);
    writer.writeObjectValue<EdiscoverySearch>("search", ediscoverySearchExportOperation.search, serializeEdiscoverySearch);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryTagOperation(writer: SerializationWriter, ediscoveryTagOperation: Partial<EdiscoveryTagOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryTagOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEmailContentThreatSubmission(writer: SerializationWriter, emailContentThreatSubmission: Partial<EmailContentThreatSubmission> | undefined = {}) : void {
    serializeEmailThreatSubmission(writer, emailContentThreatSubmission)
    writer.writeStringValue("fileContent", emailContentThreatSubmission.fileContent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEmailSender(writer: SerializationWriter, emailSender: Partial<EmailSender> | undefined = {}) : void {
    writer.writeStringValue("displayName", emailSender.displayName);
    writer.writeStringValue("domainName", emailSender.domainName);
    writer.writeStringValue("emailAddress", emailSender.emailAddress);
    writer.writeStringValue("@odata.type", emailSender.odataType);
    writer.writeAdditionalData(emailSender.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEmailThreatSubmission(writer: SerializationWriter, emailThreatSubmission: Partial<EmailThreatSubmission> | undefined = {}) : void {
    serializeThreatSubmission(writer, emailThreatSubmission)
    writer.writeObjectValue<AttackSimulationInfo>("attackSimulationInfo", emailThreatSubmission.attackSimulationInfo, serializeAttackSimulationInfo);
    writer.writeStringValue("internetMessageId", emailThreatSubmission.internetMessageId);
    writer.writeEnumValue<SubmissionCategory>("originalCategory", emailThreatSubmission.originalCategory);
    writer.writeDateValue("receivedDateTime", emailThreatSubmission.receivedDateTime);
    writer.writeStringValue("recipientEmailAddress", emailThreatSubmission.recipientEmailAddress);
    writer.writeStringValue("sender", emailThreatSubmission.sender);
    writer.writeStringValue("senderIP", emailThreatSubmission.senderIP);
    writer.writeStringValue("subject", emailThreatSubmission.subject);
    writer.writeObjectValue<TenantAllowOrBlockListAction>("tenantAllowOrBlockListAction", emailThreatSubmission.tenantAllowOrBlockListAction, serializeTenantAllowOrBlockListAction);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEmailThreatSubmissionCollectionResponse(writer: SerializationWriter, emailThreatSubmissionCollectionResponse: Partial<EmailThreatSubmissionCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, emailThreatSubmissionCollectionResponse)
    writer.writeCollectionOfObjectValues<EmailThreatSubmission>("value", emailThreatSubmissionCollectionResponse.value, serializeEmailThreatSubmission);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEmailThreatSubmissionPolicy(writer: SerializationWriter, emailThreatSubmissionPolicy: Partial<EmailThreatSubmissionPolicy> | undefined = {}) : void {
    serializeEntity(writer, emailThreatSubmissionPolicy)
    writer.writeStringValue("customizedNotificationSenderEmailAddress", emailThreatSubmissionPolicy.customizedNotificationSenderEmailAddress);
    writer.writeStringValue("customizedReportRecipientEmailAddress", emailThreatSubmissionPolicy.customizedReportRecipientEmailAddress);
    writer.writeBooleanValue("isAlwaysReportEnabledForUsers", emailThreatSubmissionPolicy.isAlwaysReportEnabledForUsers);
    writer.writeBooleanValue("isAskMeEnabledForUsers", emailThreatSubmissionPolicy.isAskMeEnabledForUsers);
    writer.writeBooleanValue("isCustomizedMessageEnabled", emailThreatSubmissionPolicy.isCustomizedMessageEnabled);
    writer.writeBooleanValue("isCustomizedMessageEnabledForPhishing", emailThreatSubmissionPolicy.isCustomizedMessageEnabledForPhishing);
    writer.writeBooleanValue("isCustomizedNotificationSenderEnabled", emailThreatSubmissionPolicy.isCustomizedNotificationSenderEnabled);
    writer.writeBooleanValue("isNeverReportEnabledForUsers", emailThreatSubmissionPolicy.isNeverReportEnabledForUsers);
    writer.writeBooleanValue("isOrganizationBrandingEnabled", emailThreatSubmissionPolicy.isOrganizationBrandingEnabled);
    writer.writeBooleanValue("isReportFromQuarantineEnabled", emailThreatSubmissionPolicy.isReportFromQuarantineEnabled);
    writer.writeBooleanValue("isReportToCustomizedEmailAddressEnabled", emailThreatSubmissionPolicy.isReportToCustomizedEmailAddressEnabled);
    writer.writeBooleanValue("isReportToMicrosoftEnabled", emailThreatSubmissionPolicy.isReportToMicrosoftEnabled);
    writer.writeBooleanValue("isReviewEmailNotificationEnabled", emailThreatSubmissionPolicy.isReviewEmailNotificationEnabled);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEmailThreatSubmissionPolicyCollectionResponse(writer: SerializationWriter, emailThreatSubmissionPolicyCollectionResponse: Partial<EmailThreatSubmissionPolicyCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, emailThreatSubmissionPolicyCollectionResponse)
    writer.writeCollectionOfObjectValues<EmailThreatSubmissionPolicy>("value", emailThreatSubmissionPolicyCollectionResponse.value, serializeEmailThreatSubmissionPolicy);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEmailUrlThreatSubmission(writer: SerializationWriter, emailUrlThreatSubmission: Partial<EmailUrlThreatSubmission> | undefined = {}) : void {
    serializeEmailThreatSubmission(writer, emailUrlThreatSubmission)
    writer.writeStringValue("messageUrl", emailUrlThreatSubmission.messageUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEventPropagationResult(writer: SerializationWriter, eventPropagationResult: Partial<EventPropagationResult> | undefined = {}) : void {
    writer.writeStringValue("location", eventPropagationResult.location);
    writer.writeStringValue("@odata.type", eventPropagationResult.odataType);
    writer.writeStringValue("serviceName", eventPropagationResult.serviceName);
    writer.writeEnumValue<EventPropagationStatus>("status", eventPropagationResult.status);
    writer.writeStringValue("statusInformation", eventPropagationResult.statusInformation);
    writer.writeAdditionalData(eventPropagationResult.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEventQuery(writer: SerializationWriter, eventQuery: Partial<EventQuery> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", eventQuery.odataType);
    writer.writeStringValue("query", eventQuery.query);
    writer.writeEnumValue<QueryType>("queryType", eventQuery.queryType);
    writer.writeAdditionalData(eventQuery.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExportFileMetadata(writer: SerializationWriter, exportFileMetadata: Partial<ExportFileMetadata> | undefined = {}) : void {
    writer.writeStringValue("downloadUrl", exportFileMetadata.downloadUrl);
    writer.writeStringValue("fileName", exportFileMetadata.fileName);
    writer.writeStringValue("@odata.type", exportFileMetadata.odataType);
    writer.writeNumberValue("size", exportFileMetadata.size);
    writer.writeAdditionalData(exportFileMetadata.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFile(writer: SerializationWriter, file: Partial<File> | undefined = {}) : void {
    serializeEntity(writer, file)
    writer.writeStringValue("content", file.content);
    writer.writeDateValue("dateTime", file.dateTime);
    writer.writeStringValue("extension", file.extension);
    writer.writeStringValue("extractedTextContent", file.extractedTextContent);
    writer.writeStringValue("mediaType", file.mediaType);
    writer.writeStringValue("name", file.name);
    writer.writeObjectValue<StringValueDictionary>("otherProperties", file.otherProperties, serializeStringValueDictionary);
    writer.writeEnumValue<FileProcessingStatus>("processingStatus", file.processingStatus);
    writer.writeCollectionOfPrimitiveValues<string>("senderOrAuthors", file.senderOrAuthors);
    writer.writeNumberValue("size", file.size);
    writer.writeEnumValue<SourceType[]>("sourceType", file.sourceType);
    writer.writeStringValue("subjectTitle", file.subjectTitle);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileContentThreatSubmission(writer: SerializationWriter, fileContentThreatSubmission: Partial<FileContentThreatSubmission> | undefined = {}) : void {
    serializeFileThreatSubmission(writer, fileContentThreatSubmission)
    writer.writeStringValue("fileContent", fileContentThreatSubmission.fileContent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileDetails(writer: SerializationWriter, fileDetails: Partial<FileDetails> | undefined = {}) : void {
    writer.writeStringValue("fileName", fileDetails.fileName);
    writer.writeStringValue("filePath", fileDetails.filePath);
    writer.writeStringValue("filePublisher", fileDetails.filePublisher);
    writer.writeNumberValue("fileSize", fileDetails.fileSize);
    writer.writeStringValue("issuer", fileDetails.issuer);
    writer.writeStringValue("@odata.type", fileDetails.odataType);
    writer.writeStringValue("sha1", fileDetails.sha1);
    writer.writeStringValue("sha256", fileDetails.sha256);
    writer.writeStringValue("signer", fileDetails.signer);
    writer.writeAdditionalData(fileDetails.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileEvidence(writer: SerializationWriter, fileEvidence: Partial<FileEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, fileEvidence)
    writer.writeEnumValue<DetectionStatus>("detectionStatus", fileEvidence.detectionStatus);
    writer.writeObjectValue<FileDetails>("fileDetails", fileEvidence.fileDetails, serializeFileDetails);
    writer.writeStringValue("mdeDeviceId", fileEvidence.mdeDeviceId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileHash(writer: SerializationWriter, fileHash: Partial<FileHash> | undefined = {}) : void {
    writer.writeEnumValue<FileHashAlgorithm>("algorithm", fileHash.algorithm);
    writer.writeStringValue("@odata.type", fileHash.odataType);
    writer.writeStringValue("value", fileHash.value);
    writer.writeAdditionalData(fileHash.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileHashEvidence(writer: SerializationWriter, fileHashEvidence: Partial<FileHashEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, fileHashEvidence)
    writer.writeEnumValue<FileHashAlgorithm>("algorithm", fileHashEvidence.algorithm);
    writer.writeStringValue("value", fileHashEvidence.value);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFilePlanAppliedCategory(writer: SerializationWriter, filePlanAppliedCategory: Partial<FilePlanAppliedCategory> | undefined = {}) : void {
    serializeFilePlanDescriptorBase(writer, filePlanAppliedCategory)
    writer.writeObjectValue<FilePlanSubcategory>("subcategory", filePlanAppliedCategory.subcategory, serializeFilePlanSubcategory);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFilePlanAuthority(writer: SerializationWriter, filePlanAuthority: Partial<FilePlanAuthority> | undefined = {}) : void {
    serializeFilePlanDescriptorBase(writer, filePlanAuthority)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFilePlanCitation(writer: SerializationWriter, filePlanCitation: Partial<FilePlanCitation> | undefined = {}) : void {
    serializeFilePlanDescriptorBase(writer, filePlanCitation)
    writer.writeStringValue("citationJurisdiction", filePlanCitation.citationJurisdiction);
    writer.writeStringValue("citationUrl", filePlanCitation.citationUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFilePlanDepartment(writer: SerializationWriter, filePlanDepartment: Partial<FilePlanDepartment> | undefined = {}) : void {
    serializeFilePlanDescriptorBase(writer, filePlanDepartment)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFilePlanDescriptor(writer: SerializationWriter, filePlanDescriptor: Partial<FilePlanDescriptor> | undefined = {}) : void {
    serializeEntity(writer, filePlanDescriptor)
    writer.writeObjectValue<FilePlanAuthority>("authority", filePlanDescriptor.authority, serializeFilePlanAuthority);
    writer.writeObjectValue<AuthorityTemplate>("authorityTemplate", filePlanDescriptor.authorityTemplate, serializeAuthorityTemplate);
    writer.writeObjectValue<FilePlanAppliedCategory>("category", filePlanDescriptor.category, serializeFilePlanAppliedCategory);
    writer.writeObjectValue<CategoryTemplate>("categoryTemplate", filePlanDescriptor.categoryTemplate, serializeCategoryTemplate);
    writer.writeObjectValue<FilePlanCitation>("citation", filePlanDescriptor.citation, serializeFilePlanCitation);
    writer.writeObjectValue<CitationTemplate>("citationTemplate", filePlanDescriptor.citationTemplate, serializeCitationTemplate);
    writer.writeObjectValue<FilePlanDepartment>("department", filePlanDescriptor.department, serializeFilePlanDepartment);
    writer.writeObjectValue<DepartmentTemplate>("departmentTemplate", filePlanDescriptor.departmentTemplate, serializeDepartmentTemplate);
    writer.writeObjectValue<FilePlanReference>("filePlanReference", filePlanDescriptor.filePlanReference, serializeFilePlanReference);
    writer.writeObjectValue<FilePlanReferenceTemplate>("filePlanReferenceTemplate", filePlanDescriptor.filePlanReferenceTemplate, serializeFilePlanReferenceTemplate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFilePlanDescriptorBase(writer: SerializationWriter, filePlanDescriptorBase: Partial<FilePlanDescriptorBase> | undefined = {}) : void {
    writer.writeStringValue("displayName", filePlanDescriptorBase.displayName);
    writer.writeStringValue("@odata.type", filePlanDescriptorBase.odataType);
    writer.writeAdditionalData(filePlanDescriptorBase.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFilePlanDescriptorTemplate(writer: SerializationWriter, filePlanDescriptorTemplate: Partial<FilePlanDescriptorTemplate> | undefined = {}) : void {
    serializeEntity(writer, filePlanDescriptorTemplate)
    writer.writeObjectValue<IdentitySet>("createdBy", filePlanDescriptorTemplate.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", filePlanDescriptorTemplate.createdDateTime);
    writer.writeStringValue("displayName", filePlanDescriptorTemplate.displayName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFilePlanReference(writer: SerializationWriter, filePlanReference: Partial<FilePlanReference> | undefined = {}) : void {
    serializeFilePlanDescriptorBase(writer, filePlanReference)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFilePlanReferenceTemplate(writer: SerializationWriter, filePlanReferenceTemplate: Partial<FilePlanReferenceTemplate> | undefined = {}) : void {
    serializeFilePlanDescriptorTemplate(writer, filePlanReferenceTemplate)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFilePlanReferenceTemplateCollectionResponse(writer: SerializationWriter, filePlanReferenceTemplateCollectionResponse: Partial<FilePlanReferenceTemplateCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, filePlanReferenceTemplateCollectionResponse)
    writer.writeCollectionOfObjectValues<FilePlanReferenceTemplate>("value", filePlanReferenceTemplateCollectionResponse.value, serializeFilePlanReferenceTemplate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFilePlanSubcategory(writer: SerializationWriter, filePlanSubcategory: Partial<FilePlanSubcategory> | undefined = {}) : void {
    serializeFilePlanDescriptorBase(writer, filePlanSubcategory)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileThreatSubmission(writer: SerializationWriter, fileThreatSubmission: Partial<FileThreatSubmission> | undefined = {}) : void {
    serializeThreatSubmission(writer, fileThreatSubmission)
    writer.writeStringValue("fileName", fileThreatSubmission.fileName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileThreatSubmissionCollectionResponse(writer: SerializationWriter, fileThreatSubmissionCollectionResponse: Partial<FileThreatSubmissionCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, fileThreatSubmissionCollectionResponse)
    writer.writeCollectionOfObjectValues<FileThreatSubmission>("value", fileThreatSubmissionCollectionResponse.value, serializeFileThreatSubmission);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileUrlThreatSubmission(writer: SerializationWriter, fileUrlThreatSubmission: Partial<FileUrlThreatSubmission> | undefined = {}) : void {
    serializeFileThreatSubmission(writer, fileUrlThreatSubmission)
    writer.writeStringValue("fileUrl", fileUrlThreatSubmission.fileUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeForceUserPasswordResetResponseAction(writer: SerializationWriter, forceUserPasswordResetResponseAction: Partial<ForceUserPasswordResetResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, forceUserPasswordResetResponseAction)
    writer.writeEnumValue<ForceUserPasswordResetEntityIdentifier[]>("identifier", forceUserPasswordResetResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFormattedContent(writer: SerializationWriter, formattedContent: Partial<FormattedContent> | undefined = {}) : void {
    writer.writeStringValue("content", formattedContent.content);
    writer.writeEnumValue<ContentFormat>("format", formattedContent.format);
    writer.writeStringValue("@odata.type", formattedContent.odataType);
    writer.writeAdditionalData(formattedContent.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeGeoLocation(writer: SerializationWriter, geoLocation: Partial<GeoLocation> | undefined = {}) : void {
    writer.writeStringValue("city", geoLocation.city);
    writer.writeStringValue("countryName", geoLocation.countryName);
    writer.writeNumberValue("latitude", geoLocation.latitude);
    writer.writeNumberValue("longitude", geoLocation.longitude);
    writer.writeStringValue("@odata.type", geoLocation.odataType);
    writer.writeStringValue("state", geoLocation.state);
    writer.writeAdditionalData(geoLocation.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeGitHubOrganizationEvidence(writer: SerializationWriter, gitHubOrganizationEvidence: Partial<GitHubOrganizationEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, gitHubOrganizationEvidence)
    writer.writeStringValue("company", gitHubOrganizationEvidence.company);
    writer.writeStringValue("displayName", gitHubOrganizationEvidence.displayName);
    writer.writeStringValue("email", gitHubOrganizationEvidence.email);
    writer.writeStringValue("login", gitHubOrganizationEvidence.login);
    writer.writeStringValue("orgId", gitHubOrganizationEvidence.orgId);
    writer.writeStringValue("webUrl", gitHubOrganizationEvidence.webUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeGitHubRepoEvidence(writer: SerializationWriter, gitHubRepoEvidence: Partial<GitHubRepoEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, gitHubRepoEvidence)
    writer.writeStringValue("baseUrl", gitHubRepoEvidence.baseUrl);
    writer.writeStringValue("login", gitHubRepoEvidence.login);
    writer.writeStringValue("owner", gitHubRepoEvidence.owner);
    writer.writeStringValue("ownerType", gitHubRepoEvidence.ownerType);
    writer.writeStringValue("repoId", gitHubRepoEvidence.repoId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeGitHubUserEvidence(writer: SerializationWriter, gitHubUserEvidence: Partial<GitHubUserEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, gitHubUserEvidence)
    writer.writeStringValue("email", gitHubUserEvidence.email);
    writer.writeStringValue("login", gitHubUserEvidence.login);
    writer.writeStringValue("name", gitHubUserEvidence.name);
    writer.writeStringValue("userId", gitHubUserEvidence.userId);
    writer.writeStringValue("webUrl", gitHubUserEvidence.webUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeGoogleCloudResourceEvidence(writer: SerializationWriter, googleCloudResourceEvidence: Partial<GoogleCloudResourceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, googleCloudResourceEvidence)
    writer.writeStringValue("fullResourceName", googleCloudResourceEvidence.fullResourceName);
    writer.writeStringValue("location", googleCloudResourceEvidence.location);
    writer.writeEnumValue<GoogleCloudLocationType>("locationType", googleCloudResourceEvidence.locationType);
    writer.writeStringValue("projectId", googleCloudResourceEvidence.projectId);
    writer.writeNumberValue("projectNumber", googleCloudResourceEvidence.projectNumber);
    writer.writeStringValue("resourceName", googleCloudResourceEvidence.resourceName);
    writer.writeStringValue("resourceType", googleCloudResourceEvidence.resourceType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHardDeleteResponseAction(writer: SerializationWriter, hardDeleteResponseAction: Partial<HardDeleteResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, hardDeleteResponseAction)
    writer.writeEnumValue<EmailEntityIdentifier[]>("identifier", hardDeleteResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHealthIssue(writer: SerializationWriter, healthIssue: Partial<HealthIssue> | undefined = {}) : void {
    serializeEntity(writer, healthIssue)
    writer.writeCollectionOfPrimitiveValues<string>("additionalInformation", healthIssue.additionalInformation);
    writer.writeDateValue("createdDateTime", healthIssue.createdDateTime);
    writer.writeStringValue("description", healthIssue.description);
    writer.writeStringValue("displayName", healthIssue.displayName);
    writer.writeCollectionOfPrimitiveValues<string>("domainNames", healthIssue.domainNames);
    writer.writeEnumValue<HealthIssueType>("healthIssueType", healthIssue.healthIssueType);
    writer.writeStringValue("issueTypeId", healthIssue.issueTypeId);
    writer.writeDateValue("lastModifiedDateTime", healthIssue.lastModifiedDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("recommendations", healthIssue.recommendations);
    writer.writeCollectionOfPrimitiveValues<string>("recommendedActionCommands", healthIssue.recommendedActionCommands);
    writer.writeCollectionOfPrimitiveValues<string>("sensorDNSNames", healthIssue.sensorDNSNames);
    writer.writeEnumValue<HealthIssueSeverity>("severity", healthIssue.severity);
    writer.writeEnumValue<HealthIssueStatus>("status", healthIssue.status);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHealthIssueCollectionResponse(writer: SerializationWriter, healthIssueCollectionResponse: Partial<HealthIssueCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, healthIssueCollectionResponse)
    writer.writeCollectionOfObjectValues<HealthIssue>("value", healthIssueCollectionResponse.value, serializeHealthIssue);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHost(writer: SerializationWriter, host: Partial<Host> | undefined = {}) : void {
    serializeArtifact(writer, host)
    writer.writeCollectionOfObjectValues<HostPair>("childHostPairs", host.childHostPairs, serializeHostPair);
    writer.writeCollectionOfObjectValues<HostComponent>("components", host.components, serializeHostComponent);
    writer.writeCollectionOfObjectValues<HostCookie>("cookies", host.cookies, serializeHostCookie);
    writer.writeDateValue("firstSeenDateTime", host.firstSeenDateTime);
    writer.writeCollectionOfObjectValues<HostPair>("hostPairs", host.hostPairs, serializeHostPair);
    writer.writeDateValue("lastSeenDateTime", host.lastSeenDateTime);
    writer.writeCollectionOfObjectValues<HostPair>("parentHostPairs", host.parentHostPairs, serializeHostPair);
    writer.writeCollectionOfObjectValues<PassiveDnsRecord>("passiveDns", host.passiveDns, serializePassiveDnsRecord);
    writer.writeCollectionOfObjectValues<PassiveDnsRecord>("passiveDnsReverse", host.passiveDnsReverse, serializePassiveDnsRecord);
    writer.writeCollectionOfObjectValues<HostPort>("ports", host.ports, serializeHostPort);
    writer.writeObjectValue<HostReputation>("reputation", host.reputation, serializeHostReputation);
    writer.writeCollectionOfObjectValues<HostSslCertificate>("sslCertificates", host.sslCertificates, serializeHostSslCertificate);
    writer.writeCollectionOfObjectValues<Subdomain>("subdomains", host.subdomains, serializeSubdomain);
    writer.writeCollectionOfObjectValues<HostTracker>("trackers", host.trackers, serializeHostTracker);
    writer.writeObjectValue<WhoisRecord>("whois", host.whois, serializeWhoisRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostCollectionResponse(writer: SerializationWriter, hostCollectionResponse: Partial<HostCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostCollectionResponse)
    writer.writeCollectionOfObjectValues<Host>("value", hostCollectionResponse.value, serializeHost);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostComponent(writer: SerializationWriter, hostComponent: Partial<HostComponent> | undefined = {}) : void {
    serializeArtifact(writer, hostComponent)
    writer.writeStringValue("category", hostComponent.category);
    writer.writeDateValue("firstSeenDateTime", hostComponent.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", hostComponent.host, serializeHost);
    writer.writeDateValue("lastSeenDateTime", hostComponent.lastSeenDateTime);
    writer.writeStringValue("name", hostComponent.name);
    writer.writeStringValue("version", hostComponent.version);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostComponentCollectionResponse(writer: SerializationWriter, hostComponentCollectionResponse: Partial<HostComponentCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostComponentCollectionResponse)
    writer.writeCollectionOfObjectValues<HostComponent>("value", hostComponentCollectionResponse.value, serializeHostComponent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostCookie(writer: SerializationWriter, hostCookie: Partial<HostCookie> | undefined = {}) : void {
    serializeArtifact(writer, hostCookie)
    writer.writeStringValue("domain", hostCookie.domain);
    writer.writeDateValue("firstSeenDateTime", hostCookie.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", hostCookie.host, serializeHost);
    writer.writeDateValue("lastSeenDateTime", hostCookie.lastSeenDateTime);
    writer.writeStringValue("name", hostCookie.name);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostCookieCollectionResponse(writer: SerializationWriter, hostCookieCollectionResponse: Partial<HostCookieCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostCookieCollectionResponse)
    writer.writeCollectionOfObjectValues<HostCookie>("value", hostCookieCollectionResponse.value, serializeHostCookie);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostLogonSessionEvidence(writer: SerializationWriter, hostLogonSessionEvidence: Partial<HostLogonSessionEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, hostLogonSessionEvidence)
    writer.writeObjectValue<UserEvidence>("account", hostLogonSessionEvidence.account, serializeUserEvidence);
    writer.writeDateValue("endUtcDateTime", hostLogonSessionEvidence.endUtcDateTime);
    writer.writeObjectValue<DeviceEvidence>("host", hostLogonSessionEvidence.host, serializeDeviceEvidence);
    writer.writeStringValue("sessionId", hostLogonSessionEvidence.sessionId);
    writer.writeDateValue("startUtcDateTime", hostLogonSessionEvidence.startUtcDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostname(writer: SerializationWriter, hostname: Partial<Hostname> | undefined = {}) : void {
    serializeHost(writer, hostname)
    writer.writeStringValue("registrant", hostname.registrant);
    writer.writeStringValue("registrar", hostname.registrar);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPair(writer: SerializationWriter, hostPair: Partial<HostPair> | undefined = {}) : void {
    serializeEntity(writer, hostPair)
    writer.writeObjectValue<Host>("childHost", hostPair.childHost, serializeHost);
    writer.writeDateValue("firstSeenDateTime", hostPair.firstSeenDateTime);
    writer.writeDateValue("lastSeenDateTime", hostPair.lastSeenDateTime);
    writer.writeStringValue("linkKind", hostPair.linkKind);
    writer.writeObjectValue<Host>("parentHost", hostPair.parentHost, serializeHost);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPairCollectionResponse(writer: SerializationWriter, hostPairCollectionResponse: Partial<HostPairCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostPairCollectionResponse)
    writer.writeCollectionOfObjectValues<HostPair>("value", hostPairCollectionResponse.value, serializeHostPair);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPort(writer: SerializationWriter, hostPort: Partial<HostPort> | undefined = {}) : void {
    serializeEntity(writer, hostPort)
    writer.writeCollectionOfObjectValues<HostPortBanner>("banners", hostPort.banners, serializeHostPortBanner);
    writer.writeDateValue("firstSeenDateTime", hostPort.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", hostPort.host, serializeHost);
    writer.writeDateValue("lastScanDateTime", hostPort.lastScanDateTime);
    writer.writeDateValue("lastSeenDateTime", hostPort.lastSeenDateTime);
    writer.writeObjectValue<SslCertificate>("mostRecentSslCertificate", hostPort.mostRecentSslCertificate, serializeSslCertificate);
    writer.writeNumberValue("port", hostPort.port);
    writer.writeEnumValue<HostPortProtocol>("protocol", hostPort.protocol);
    writer.writeCollectionOfObjectValues<HostPortComponent>("services", hostPort.services, serializeHostPortComponent);
    writer.writeEnumValue<HostPortStatus>("status", hostPort.status);
    writer.writeNumberValue("timesObserved", hostPort.timesObserved);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPortBanner(writer: SerializationWriter, hostPortBanner: Partial<HostPortBanner> | undefined = {}) : void {
    writer.writeStringValue("banner", hostPortBanner.banner);
    writer.writeDateValue("firstSeenDateTime", hostPortBanner.firstSeenDateTime);
    writer.writeDateValue("lastSeenDateTime", hostPortBanner.lastSeenDateTime);
    writer.writeStringValue("@odata.type", hostPortBanner.odataType);
    writer.writeStringValue("scanProtocol", hostPortBanner.scanProtocol);
    writer.writeNumberValue("timesObserved", hostPortBanner.timesObserved);
    writer.writeAdditionalData(hostPortBanner.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPortCollectionResponse(writer: SerializationWriter, hostPortCollectionResponse: Partial<HostPortCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostPortCollectionResponse)
    writer.writeCollectionOfObjectValues<HostPort>("value", hostPortCollectionResponse.value, serializeHostPort);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPortComponent(writer: SerializationWriter, hostPortComponent: Partial<HostPortComponent> | undefined = {}) : void {
    writer.writeObjectValue<HostComponent>("component", hostPortComponent.component, serializeHostComponent);
    writer.writeDateValue("firstSeenDateTime", hostPortComponent.firstSeenDateTime);
    writer.writeBooleanValue("isRecent", hostPortComponent.isRecent);
    writer.writeDateValue("lastSeenDateTime", hostPortComponent.lastSeenDateTime);
    writer.writeStringValue("@odata.type", hostPortComponent.odataType);
    writer.writeAdditionalData(hostPortComponent.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostReputation(writer: SerializationWriter, hostReputation: Partial<HostReputation> | undefined = {}) : void {
    serializeEntity(writer, hostReputation)
    writer.writeEnumValue<HostReputationClassification>("classification", hostReputation.classification);
    writer.writeCollectionOfObjectValues<HostReputationRule>("rules", hostReputation.rules, serializeHostReputationRule);
    writer.writeNumberValue("score", hostReputation.score);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostReputationRule(writer: SerializationWriter, hostReputationRule: Partial<HostReputationRule> | undefined = {}) : void {
    writer.writeStringValue("description", hostReputationRule.description);
    writer.writeStringValue("name", hostReputationRule.name);
    writer.writeStringValue("@odata.type", hostReputationRule.odataType);
    writer.writeStringValue("relatedDetailsUrl", hostReputationRule.relatedDetailsUrl);
    writer.writeEnumValue<HostReputationRuleSeverity>("severity", hostReputationRule.severity);
    writer.writeAdditionalData(hostReputationRule.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostSslCertificate(writer: SerializationWriter, hostSslCertificate: Partial<HostSslCertificate> | undefined = {}) : void {
    serializeArtifact(writer, hostSslCertificate)
    writer.writeDateValue("firstSeenDateTime", hostSslCertificate.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", hostSslCertificate.host, serializeHost);
    writer.writeDateValue("lastSeenDateTime", hostSslCertificate.lastSeenDateTime);
    writer.writeCollectionOfObjectValues<HostSslCertificatePort>("ports", hostSslCertificate.ports, serializeHostSslCertificatePort);
    writer.writeObjectValue<SslCertificate>("sslCertificate", hostSslCertificate.sslCertificate, serializeSslCertificate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostSslCertificateCollectionResponse(writer: SerializationWriter, hostSslCertificateCollectionResponse: Partial<HostSslCertificateCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostSslCertificateCollectionResponse)
    writer.writeCollectionOfObjectValues<HostSslCertificate>("value", hostSslCertificateCollectionResponse.value, serializeHostSslCertificate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostSslCertificatePort(writer: SerializationWriter, hostSslCertificatePort: Partial<HostSslCertificatePort> | undefined = {}) : void {
    writer.writeDateValue("firstSeenDateTime", hostSslCertificatePort.firstSeenDateTime);
    writer.writeDateValue("lastSeenDateTime", hostSslCertificatePort.lastSeenDateTime);
    writer.writeStringValue("@odata.type", hostSslCertificatePort.odataType);
    writer.writeNumberValue("port", hostSslCertificatePort.port);
    writer.writeAdditionalData(hostSslCertificatePort.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostTracker(writer: SerializationWriter, hostTracker: Partial<HostTracker> | undefined = {}) : void {
    serializeArtifact(writer, hostTracker)
    writer.writeDateValue("firstSeenDateTime", hostTracker.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", hostTracker.host, serializeHost);
    writer.writeStringValue("kind", hostTracker.kind);
    writer.writeDateValue("lastSeenDateTime", hostTracker.lastSeenDateTime);
    writer.writeStringValue("value", hostTracker.value);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostTrackerCollectionResponse(writer: SerializationWriter, hostTrackerCollectionResponse: Partial<HostTrackerCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostTrackerCollectionResponse)
    writer.writeCollectionOfObjectValues<HostTracker>("value", hostTrackerCollectionResponse.value, serializeHostTracker);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHuntingQueryResults(writer: SerializationWriter, huntingQueryResults: Partial<HuntingQueryResults> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", huntingQueryResults.odataType);
    writer.writeCollectionOfObjectValues<HuntingRowResult>("results", huntingQueryResults.results, serializeHuntingRowResult);
    writer.writeCollectionOfObjectValues<SinglePropertySchema>("schema", huntingQueryResults.schema, serializeSinglePropertySchema);
    writer.writeAdditionalData(huntingQueryResults.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHuntingRowResult(writer: SerializationWriter, huntingRowResult: Partial<HuntingRowResult> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", huntingRowResult.odataType);
    writer.writeAdditionalData(huntingRowResult.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHyperlink(writer: SerializationWriter, hyperlink: Partial<Hyperlink> | undefined = {}) : void {
    writer.writeStringValue("name", hyperlink.name);
    writer.writeStringValue("@odata.type", hyperlink.odataType);
    writer.writeStringValue("url", hyperlink.url);
    writer.writeAdditionalData(hyperlink.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIdentityContainer(writer: SerializationWriter, identityContainer: Partial<IdentityContainer> | undefined = {}) : void {
    serializeEntity(writer, identityContainer)
    writer.writeCollectionOfObjectValues<HealthIssue>("healthIssues", identityContainer.healthIssues, serializeHealthIssue);
    writer.writeCollectionOfObjectValues<Sensor>("sensors", identityContainer.sensors, serializeSensor);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeImpactedAsset(writer: SerializationWriter, impactedAsset: Partial<ImpactedAsset> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", impactedAsset.odataType);
    writer.writeAdditionalData(impactedAsset.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeImpactedDeviceAsset(writer: SerializationWriter, impactedDeviceAsset: Partial<ImpactedDeviceAsset> | undefined = {}) : void {
    serializeImpactedAsset(writer, impactedDeviceAsset)
    writer.writeEnumValue<DeviceAssetIdentifier>("identifier", impactedDeviceAsset.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeImpactedMailboxAsset(writer: SerializationWriter, impactedMailboxAsset: Partial<ImpactedMailboxAsset> | undefined = {}) : void {
    serializeImpactedAsset(writer, impactedMailboxAsset)
    writer.writeEnumValue<MailboxAssetIdentifier>("identifier", impactedMailboxAsset.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeImpactedUserAsset(writer: SerializationWriter, impactedUserAsset: Partial<ImpactedUserAsset> | undefined = {}) : void {
    serializeImpactedAsset(writer, impactedUserAsset)
    writer.writeEnumValue<UserAssetIdentifier>("identifier", impactedUserAsset.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIncident(writer: SerializationWriter, incident: Partial<Incident> | undefined = {}) : void {
    serializeEntity(writer, incident)
    writer.writeCollectionOfObjectValues<Alert>("alerts", incident.alerts, serializeAlert);
    writer.writeStringValue("assignedTo", incident.assignedTo);
    writer.writeEnumValue<AlertClassification>("classification", incident.classification);
    writer.writeCollectionOfObjectValues<AlertComment>("comments", incident.comments, serializeAlertComment);
    writer.writeDateValue("createdDateTime", incident.createdDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("customTags", incident.customTags);
    writer.writeStringValue("description", incident.description);
    writer.writeEnumValue<AlertDetermination>("determination", incident.determination);
    writer.writeStringValue("displayName", incident.displayName);
    writer.writeStringValue("incidentWebUrl", incident.incidentWebUrl);
    writer.writeStringValue("lastModifiedBy", incident.lastModifiedBy);
    writer.writeDateValue("lastUpdateDateTime", incident.lastUpdateDateTime);
    writer.writeStringValue("recommendedActions", incident.recommendedActions);
    writer.writeCollectionOfObjectValues<RecommendedHuntingQuery>("recommendedHuntingQueries", incident.recommendedHuntingQueries, serializeRecommendedHuntingQuery);
    writer.writeStringValue("redirectIncidentId", incident.redirectIncidentId);
    writer.writeStringValue("resolvingComment", incident.resolvingComment);
    writer.writeEnumValue<AlertSeverity>("severity", incident.severity);
    writer.writeEnumValue<IncidentStatus>("status", incident.status);
    writer.writeCollectionOfPrimitiveValues<string>("systemTags", incident.systemTags);
    writer.writeStringValue("tenantId", incident.tenantId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIncidentCollectionResponse(writer: SerializationWriter, incidentCollectionResponse: Partial<IncidentCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, incidentCollectionResponse)
    writer.writeCollectionOfObjectValues<Incident>("value", incidentCollectionResponse.value, serializeIncident);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIndicator(writer: SerializationWriter, indicator: Partial<Indicator> | undefined = {}) : void {
    serializeEntity(writer, indicator)
    writer.writeObjectValue<Artifact>("artifact", indicator.artifact, serializeArtifact);
    writer.writeEnumValue<IndicatorSource>("source", indicator.source);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeInformationProtection(writer: SerializationWriter, informationProtection: Partial<InformationProtection> | undefined = {}) : void {
    serializeEntity(writer, informationProtection)
    writer.writeObjectValue<InformationProtectionPolicySetting>("labelPolicySettings", informationProtection.labelPolicySettings, serializeInformationProtectionPolicySetting);
    writer.writeCollectionOfObjectValues<SensitivityLabel>("sensitivityLabels", informationProtection.sensitivityLabels, serializeSensitivityLabel);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeInformationProtectionAction(writer: SerializationWriter, informationProtectionAction: Partial<InformationProtectionAction> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", informationProtectionAction.odataType);
    writer.writeAdditionalData(informationProtectionAction.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeInformationProtectionPolicySetting(writer: SerializationWriter, informationProtectionPolicySetting: Partial<InformationProtectionPolicySetting> | undefined = {}) : void {
    serializeEntity(writer, informationProtectionPolicySetting)
    writer.writeStringValue("defaultLabelId", informationProtectionPolicySetting.defaultLabelId);
    writer.writeBooleanValue("isDowngradeJustificationRequired", informationProtectionPolicySetting.isDowngradeJustificationRequired);
    writer.writeBooleanValue("isMandatory", informationProtectionPolicySetting.isMandatory);
    writer.writeStringValue("moreInfoUrl", informationProtectionPolicySetting.moreInfoUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeInitiateInvestigationResponseAction(writer: SerializationWriter, initiateInvestigationResponseAction: Partial<InitiateInvestigationResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, initiateInvestigationResponseAction)
    writer.writeEnumValue<DeviceIdEntityIdentifier[]>("identifier", initiateInvestigationResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIntelligenceProfile(writer: SerializationWriter, intelligenceProfile: Partial<IntelligenceProfile> | undefined = {}) : void {
    serializeEntity(writer, intelligenceProfile)
    writer.writeCollectionOfPrimitiveValues<string>("aliases", intelligenceProfile.aliases);
    writer.writeCollectionOfObjectValues<IntelligenceProfileCountryOrRegionOfOrigin>("countriesOrRegionsOfOrigin", intelligenceProfile.countriesOrRegionsOfOrigin, serializeIntelligenceProfileCountryOrRegionOfOrigin);
    writer.writeObjectValue<FormattedContent>("description", intelligenceProfile.description, serializeFormattedContent);
    writer.writeDateValue("firstActiveDateTime", intelligenceProfile.firstActiveDateTime);
    writer.writeCollectionOfObjectValues<IntelligenceProfileIndicator>("indicators", intelligenceProfile.indicators, serializeIntelligenceProfileIndicator);
    writer.writeEnumValue<IntelligenceProfileKind>("kind", intelligenceProfile.kind);
    writer.writeObjectValue<FormattedContent>("summary", intelligenceProfile.summary, serializeFormattedContent);
    writer.writeCollectionOfPrimitiveValues<string>("targets", intelligenceProfile.targets);
    writer.writeStringValue("title", intelligenceProfile.title);
    writer.writeObjectValue<FormattedContent>("tradecraft", intelligenceProfile.tradecraft, serializeFormattedContent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIntelligenceProfileCollectionResponse(writer: SerializationWriter, intelligenceProfileCollectionResponse: Partial<IntelligenceProfileCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, intelligenceProfileCollectionResponse)
    writer.writeCollectionOfObjectValues<IntelligenceProfile>("value", intelligenceProfileCollectionResponse.value, serializeIntelligenceProfile);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIntelligenceProfileCountryOrRegionOfOrigin(writer: SerializationWriter, intelligenceProfileCountryOrRegionOfOrigin: Partial<IntelligenceProfileCountryOrRegionOfOrigin> | undefined = {}) : void {
    writer.writeStringValue("code", intelligenceProfileCountryOrRegionOfOrigin.code);
    writer.writeStringValue("label", intelligenceProfileCountryOrRegionOfOrigin.label);
    writer.writeStringValue("@odata.type", intelligenceProfileCountryOrRegionOfOrigin.odataType);
    writer.writeAdditionalData(intelligenceProfileCountryOrRegionOfOrigin.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIntelligenceProfileIndicator(writer: SerializationWriter, intelligenceProfileIndicator: Partial<IntelligenceProfileIndicator> | undefined = {}) : void {
    serializeIndicator(writer, intelligenceProfileIndicator)
    writer.writeDateValue("firstSeenDateTime", intelligenceProfileIndicator.firstSeenDateTime);
    writer.writeDateValue("lastSeenDateTime", intelligenceProfileIndicator.lastSeenDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIntelligenceProfileIndicatorCollectionResponse(writer: SerializationWriter, intelligenceProfileIndicatorCollectionResponse: Partial<IntelligenceProfileIndicatorCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, intelligenceProfileIndicatorCollectionResponse)
    writer.writeCollectionOfObjectValues<IntelligenceProfileIndicator>("value", intelligenceProfileIndicatorCollectionResponse.value, serializeIntelligenceProfileIndicator);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIoTDeviceEvidence(writer: SerializationWriter, ioTDeviceEvidence: Partial<IoTDeviceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, ioTDeviceEvidence)
    writer.writeStringValue("deviceId", ioTDeviceEvidence.deviceId);
    writer.writeStringValue("deviceName", ioTDeviceEvidence.deviceName);
    writer.writeStringValue("devicePageLink", ioTDeviceEvidence.devicePageLink);
    writer.writeStringValue("deviceSubType", ioTDeviceEvidence.deviceSubType);
    writer.writeStringValue("deviceType", ioTDeviceEvidence.deviceType);
    writer.writeEnumValue<IoTDeviceImportanceType>("importance", ioTDeviceEvidence.importance);
    writer.writeObjectValue<AzureResourceEvidence>("ioTHub", ioTDeviceEvidence.ioTHub, serializeAzureResourceEvidence);
    writer.writeStringValue("ioTSecurityAgentId", ioTDeviceEvidence.ioTSecurityAgentId);
    writer.writeObjectValue<IpEvidence>("ipAddress", ioTDeviceEvidence.ipAddress, serializeIpEvidence);
    writer.writeBooleanValue("isAuthorized", ioTDeviceEvidence.isAuthorized);
    writer.writeBooleanValue("isProgramming", ioTDeviceEvidence.isProgramming);
    writer.writeBooleanValue("isScanner", ioTDeviceEvidence.isScanner);
    writer.writeStringValue("macAddress", ioTDeviceEvidence.macAddress);
    writer.writeStringValue("manufacturer", ioTDeviceEvidence.manufacturer);
    writer.writeStringValue("model", ioTDeviceEvidence.model);
    writer.writeObjectValue<NicEvidence>("nics", ioTDeviceEvidence.nics, serializeNicEvidence);
    writer.writeStringValue("operatingSystem", ioTDeviceEvidence.operatingSystem);
    writer.writeCollectionOfPrimitiveValues<string>("owners", ioTDeviceEvidence.owners);
    writer.writeCollectionOfPrimitiveValues<string>("protocols", ioTDeviceEvidence.protocols);
    writer.writeStringValue("purdueLayer", ioTDeviceEvidence.purdueLayer);
    writer.writeStringValue("sensor", ioTDeviceEvidence.sensor);
    writer.writeStringValue("serialNumber", ioTDeviceEvidence.serialNumber);
    writer.writeStringValue("site", ioTDeviceEvidence.site);
    writer.writeStringValue("source", ioTDeviceEvidence.source);
    writer.writeObjectValue<UrlEvidence>("sourceRef", ioTDeviceEvidence.sourceRef, serializeUrlEvidence);
    writer.writeStringValue("zone", ioTDeviceEvidence.zone);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIpAddress(writer: SerializationWriter, ipAddress: Partial<IpAddress> | undefined = {}) : void {
    serializeHost(writer, ipAddress)
    writer.writeObjectValue<AutonomousSystem>("autonomousSystem", ipAddress.autonomousSystem, serializeAutonomousSystem);
    writer.writeStringValue("countryOrRegion", ipAddress.countryOrRegion);
    writer.writeStringValue("hostingProvider", ipAddress.hostingProvider);
    writer.writeStringValue("netblock", ipAddress.netblock);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIpEvidence(writer: SerializationWriter, ipEvidence: Partial<IpEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, ipEvidence)
    writer.writeStringValue("countryLetterCode", ipEvidence.countryLetterCode);
    writer.writeStringValue("ipAddress", ipEvidence.ipAddress);
    writer.writeObjectValue<GeoLocation>("location", ipEvidence.location, serializeGeoLocation);
    writer.writeObjectValue<Stream>("stream", ipEvidence.stream, serializeStream);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIsolateDeviceResponseAction(writer: SerializationWriter, isolateDeviceResponseAction: Partial<IsolateDeviceResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, isolateDeviceResponseAction)
    writer.writeEnumValue<DeviceIdEntityIdentifier[]>("identifier", isolateDeviceResponseAction.identifier);
    writer.writeEnumValue<IsolationType>("isolationType", isolateDeviceResponseAction.isolationType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeJustifyAction(writer: SerializationWriter, justifyAction: Partial<JustifyAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, justifyAction)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKeyValuePair(writer: SerializationWriter, keyValuePair: Partial<KeyValuePair> | undefined = {}) : void {
    writer.writeStringValue("name", keyValuePair.name);
    writer.writeStringValue("@odata.type", keyValuePair.odataType);
    writer.writeStringValue("value", keyValuePair.value);
    writer.writeAdditionalData(keyValuePair.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesClusterEvidence(writer: SerializationWriter, kubernetesClusterEvidence: Partial<KubernetesClusterEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesClusterEvidence)
    writer.writeObjectValue<AlertEvidence>("cloudResource", kubernetesClusterEvidence.cloudResource, serializeAlertEvidence);
    writer.writeStringValue("distribution", kubernetesClusterEvidence.distribution);
    writer.writeStringValue("name", kubernetesClusterEvidence.name);
    writer.writeEnumValue<KubernetesPlatform>("platform", kubernetesClusterEvidence.platform);
    writer.writeStringValue("version", kubernetesClusterEvidence.version);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesControllerEvidence(writer: SerializationWriter, kubernetesControllerEvidence: Partial<KubernetesControllerEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesControllerEvidence)
    writer.writeObjectValue<Dictionary>("labels", kubernetesControllerEvidence.labels, serializeDictionary);
    writer.writeStringValue("name", kubernetesControllerEvidence.name);
    writer.writeObjectValue<KubernetesNamespaceEvidence>("namespace", kubernetesControllerEvidence.namespace, serializeKubernetesNamespaceEvidence);
    writer.writeStringValue("type", kubernetesControllerEvidence.type);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesNamespaceEvidence(writer: SerializationWriter, kubernetesNamespaceEvidence: Partial<KubernetesNamespaceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesNamespaceEvidence)
    writer.writeObjectValue<KubernetesClusterEvidence>("cluster", kubernetesNamespaceEvidence.cluster, serializeKubernetesClusterEvidence);
    writer.writeObjectValue<Dictionary>("labels", kubernetesNamespaceEvidence.labels, serializeDictionary);
    writer.writeStringValue("name", kubernetesNamespaceEvidence.name);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesPodEvidence(writer: SerializationWriter, kubernetesPodEvidence: Partial<KubernetesPodEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesPodEvidence)
    writer.writeCollectionOfObjectValues<ContainerEvidence>("containers", kubernetesPodEvidence.containers, serializeContainerEvidence);
    writer.writeObjectValue<KubernetesControllerEvidence>("controller", kubernetesPodEvidence.controller, serializeKubernetesControllerEvidence);
    writer.writeCollectionOfObjectValues<ContainerEvidence>("ephemeralContainers", kubernetesPodEvidence.ephemeralContainers, serializeContainerEvidence);
    writer.writeCollectionOfObjectValues<ContainerEvidence>("initContainers", kubernetesPodEvidence.initContainers, serializeContainerEvidence);
    writer.writeObjectValue<Dictionary>("labels", kubernetesPodEvidence.labels, serializeDictionary);
    writer.writeStringValue("name", kubernetesPodEvidence.name);
    writer.writeObjectValue<KubernetesNamespaceEvidence>("namespace", kubernetesPodEvidence.namespace, serializeKubernetesNamespaceEvidence);
    writer.writeObjectValue<IpEvidence>("podIp", kubernetesPodEvidence.podIp, serializeIpEvidence);
    writer.writeObjectValue<KubernetesServiceAccountEvidence>("serviceAccount", kubernetesPodEvidence.serviceAccount, serializeKubernetesServiceAccountEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesSecretEvidence(writer: SerializationWriter, kubernetesSecretEvidence: Partial<KubernetesSecretEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesSecretEvidence)
    writer.writeStringValue("name", kubernetesSecretEvidence.name);
    writer.writeObjectValue<KubernetesNamespaceEvidence>("namespace", kubernetesSecretEvidence.namespace, serializeKubernetesNamespaceEvidence);
    writer.writeStringValue("secretType", kubernetesSecretEvidence.secretType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesServiceAccountEvidence(writer: SerializationWriter, kubernetesServiceAccountEvidence: Partial<KubernetesServiceAccountEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesServiceAccountEvidence)
    writer.writeStringValue("name", kubernetesServiceAccountEvidence.name);
    writer.writeObjectValue<KubernetesNamespaceEvidence>("namespace", kubernetesServiceAccountEvidence.namespace, serializeKubernetesNamespaceEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesServiceEvidence(writer: SerializationWriter, kubernetesServiceEvidence: Partial<KubernetesServiceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesServiceEvidence)
    writer.writeObjectValue<IpEvidence>("clusterIP", kubernetesServiceEvidence.clusterIP, serializeIpEvidence);
    writer.writeCollectionOfObjectValues<IpEvidence>("externalIPs", kubernetesServiceEvidence.externalIPs, serializeIpEvidence);
    writer.writeObjectValue<Dictionary>("labels", kubernetesServiceEvidence.labels, serializeDictionary);
    writer.writeStringValue("name", kubernetesServiceEvidence.name);
    writer.writeObjectValue<KubernetesNamespaceEvidence>("namespace", kubernetesServiceEvidence.namespace, serializeKubernetesNamespaceEvidence);
    writer.writeObjectValue<Dictionary>("selector", kubernetesServiceEvidence.selector, serializeDictionary);
    writer.writeCollectionOfObjectValues<KubernetesServicePort>("servicePorts", kubernetesServiceEvidence.servicePorts, serializeKubernetesServicePort);
    writer.writeEnumValue<KubernetesServiceType>("serviceType", kubernetesServiceEvidence.serviceType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesServicePort(writer: SerializationWriter, kubernetesServicePort: Partial<KubernetesServicePort> | undefined = {}) : void {
    writer.writeStringValue("appProtocol", kubernetesServicePort.appProtocol);
    writer.writeStringValue("name", kubernetesServicePort.name);
    writer.writeNumberValue("nodePort", kubernetesServicePort.nodePort);
    writer.writeStringValue("@odata.type", kubernetesServicePort.odataType);
    writer.writeNumberValue("port", kubernetesServicePort.port);
    writer.writeEnumValue<ContainerPortProtocol>("protocol", kubernetesServicePort.protocol);
    writer.writeStringValue("targetPort", kubernetesServicePort.targetPort);
    writer.writeAdditionalData(kubernetesServicePort.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeLabelingOptions(writer: SerializationWriter, labelingOptions: Partial<LabelingOptions> | undefined = {}) : void {
    writer.writeEnumValue<AssignmentMethod>("assignmentMethod", labelingOptions.assignmentMethod);
    writer.writeObjectValue<DowngradeJustification>("downgradeJustification", labelingOptions.downgradeJustification, serializeDowngradeJustification);
    writer.writeCollectionOfObjectValues<KeyValuePair>("extendedProperties", labelingOptions.extendedProperties, serializeKeyValuePair);
    writer.writeStringValue("labelId", labelingOptions.labelId);
    writer.writeStringValue("@odata.type", labelingOptions.odataType);
    writer.writeAdditionalData(labelingOptions.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeLabelsRoot(writer: SerializationWriter, labelsRoot: Partial<LabelsRoot> | undefined = {}) : void {
    serializeEntity(writer, labelsRoot)
    writer.writeCollectionOfObjectValues<AuthorityTemplate>("authorities", labelsRoot.authorities, serializeAuthorityTemplate);
    writer.writeCollectionOfObjectValues<CategoryTemplate>("categories", labelsRoot.categories, serializeCategoryTemplate);
    writer.writeCollectionOfObjectValues<CitationTemplate>("citations", labelsRoot.citations, serializeCitationTemplate);
    writer.writeCollectionOfObjectValues<DepartmentTemplate>("departments", labelsRoot.departments, serializeDepartmentTemplate);
    writer.writeCollectionOfObjectValues<FilePlanReferenceTemplate>("filePlanReferences", labelsRoot.filePlanReferences, serializeFilePlanReferenceTemplate);
    writer.writeCollectionOfObjectValues<RetentionLabel>("retentionLabels", labelsRoot.retentionLabels, serializeRetentionLabel);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeLoggedOnUser(writer: SerializationWriter, loggedOnUser: Partial<LoggedOnUser> | undefined = {}) : void {
    writer.writeStringValue("accountName", loggedOnUser.accountName);
    writer.writeStringValue("domainName", loggedOnUser.domainName);
    writer.writeStringValue("@odata.type", loggedOnUser.odataType);
    writer.writeAdditionalData(loggedOnUser.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMailboxConfigurationEvidence(writer: SerializationWriter, mailboxConfigurationEvidence: Partial<MailboxConfigurationEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, mailboxConfigurationEvidence)
    writer.writeStringValue("configurationId", mailboxConfigurationEvidence.configurationId);
    writer.writeEnumValue<MailboxConfigurationType>("configurationType", mailboxConfigurationEvidence.configurationType);
    writer.writeStringValue("displayName", mailboxConfigurationEvidence.displayName);
    writer.writeGuidValue("externalDirectoryObjectId", mailboxConfigurationEvidence.externalDirectoryObjectId);
    writer.writeStringValue("mailboxPrimaryAddress", mailboxConfigurationEvidence.mailboxPrimaryAddress);
    writer.writeStringValue("upn", mailboxConfigurationEvidence.upn);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMailboxEvidence(writer: SerializationWriter, mailboxEvidence: Partial<MailboxEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, mailboxEvidence)
    writer.writeStringValue("displayName", mailboxEvidence.displayName);
    writer.writeStringValue("primaryAddress", mailboxEvidence.primaryAddress);
    writer.writeObjectValue<UserAccount>("userAccount", mailboxEvidence.userAccount, serializeUserAccount);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMailClusterEvidence(writer: SerializationWriter, mailClusterEvidence: Partial<MailClusterEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, mailClusterEvidence)
    writer.writeStringValue("clusterBy", mailClusterEvidence.clusterBy);
    writer.writeStringValue("clusterByValue", mailClusterEvidence.clusterByValue);
    writer.writeNumberValue("emailCount", mailClusterEvidence.emailCount);
    writer.writeCollectionOfPrimitiveValues<string>("networkMessageIds", mailClusterEvidence.networkMessageIds);
    writer.writeStringValue("query", mailClusterEvidence.query);
    writer.writeStringValue("urn", mailClusterEvidence.urn);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMalwareEvidence(writer: SerializationWriter, malwareEvidence: Partial<MalwareEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, malwareEvidence)
    writer.writeStringValue("category", malwareEvidence.category);
    writer.writeCollectionOfObjectValues<FileEvidence>("files", malwareEvidence.files, serializeFileEvidence);
    writer.writeStringValue("name", malwareEvidence.name);
    writer.writeCollectionOfObjectValues<ProcessEvidence>("processes", malwareEvidence.processes, serializeProcessEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMarkUserAsCompromisedResponseAction(writer: SerializationWriter, markUserAsCompromisedResponseAction: Partial<MarkUserAsCompromisedResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, markUserAsCompromisedResponseAction)
    writer.writeEnumValue<MarkUserAsCompromisedEntityIdentifier[]>("identifier", markUserAsCompromisedResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMetadataAction(writer: SerializationWriter, metadataAction: Partial<MetadataAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, metadataAction)
    writer.writeCollectionOfObjectValues<KeyValuePair>("metadataToAdd", metadataAction.metadataToAdd, serializeKeyValuePair);
    writer.writeCollectionOfPrimitiveValues<string>("metadataToRemove", metadataAction.metadataToRemove);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMoveToDeletedItemsResponseAction(writer: SerializationWriter, moveToDeletedItemsResponseAction: Partial<MoveToDeletedItemsResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, moveToDeletedItemsResponseAction)
    writer.writeEnumValue<EmailEntityIdentifier[]>("identifier", moveToDeletedItemsResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMoveToInboxResponseAction(writer: SerializationWriter, moveToInboxResponseAction: Partial<MoveToInboxResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, moveToInboxResponseAction)
    writer.writeEnumValue<EmailEntityIdentifier[]>("identifier", moveToInboxResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMoveToJunkResponseAction(writer: SerializationWriter, moveToJunkResponseAction: Partial<MoveToJunkResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, moveToJunkResponseAction)
    writer.writeEnumValue<EmailEntityIdentifier[]>("identifier", moveToJunkResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeNetworkAdapter(writer: SerializationWriter, networkAdapter: Partial<NetworkAdapter> | undefined = {}) : void {
    serializeEntity(writer, networkAdapter)
    writer.writeBooleanValue("isEnabled", networkAdapter.isEnabled);
    writer.writeStringValue("name", networkAdapter.name);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeNetworkConnectionEvidence(writer: SerializationWriter, networkConnectionEvidence: Partial<NetworkConnectionEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, networkConnectionEvidence)
    writer.writeObjectValue<IpEvidence>("destinationAddress", networkConnectionEvidence.destinationAddress, serializeIpEvidence);
    writer.writeNumberValue("destinationPort", networkConnectionEvidence.destinationPort);
    writer.writeEnumValue<ProtocolType>("protocol", networkConnectionEvidence.protocol);
    writer.writeObjectValue<IpEvidence>("sourceAddress", networkConnectionEvidence.sourceAddress, serializeIpEvidence);
    writer.writeNumberValue("sourcePort", networkConnectionEvidence.sourcePort);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeNicEvidence(writer: SerializationWriter, nicEvidence: Partial<NicEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, nicEvidence)
    writer.writeObjectValue<IpEvidence>("ipAddress", nicEvidence.ipAddress, serializeIpEvidence);
    writer.writeStringValue("macAddress", nicEvidence.macAddress);
    writer.writeCollectionOfPrimitiveValues<string>("vlans", nicEvidence.vlans);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOauthApplicationEvidence(writer: SerializationWriter, oauthApplicationEvidence: Partial<OauthApplicationEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, oauthApplicationEvidence)
    writer.writeStringValue("appId", oauthApplicationEvidence.appId);
    writer.writeStringValue("displayName", oauthApplicationEvidence.displayName);
    writer.writeStringValue("objectId", oauthApplicationEvidence.objectId);
    writer.writeStringValue("publisher", oauthApplicationEvidence.publisher);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOcrSettings(writer: SerializationWriter, ocrSettings: Partial<OcrSettings> | undefined = {}) : void {
    writer.writeBooleanValue("isEnabled", ocrSettings.isEnabled);
    writer.writeNumberValue("maxImageSize", ocrSettings.maxImageSize);
    writer.writeStringValue("@odata.type", ocrSettings.odataType);
    writer.writeDurationValue("timeout", ocrSettings.timeout);
    writer.writeAdditionalData(ocrSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOrganizationalScope(writer: SerializationWriter, organizationalScope: Partial<OrganizationalScope> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", organizationalScope.odataType);
    writer.writeCollectionOfPrimitiveValues<string>("scopeNames", organizationalScope.scopeNames);
    writer.writeEnumValue<ScopeType>("scopeType", organizationalScope.scopeType);
    writer.writeAdditionalData(organizationalScope.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePassiveDnsRecord(writer: SerializationWriter, passiveDnsRecord: Partial<PassiveDnsRecord> | undefined = {}) : void {
    serializeArtifact(writer, passiveDnsRecord)
    writer.writeObjectValue<Artifact>("artifact", passiveDnsRecord.artifact, serializeArtifact);
    writer.writeDateValue("collectedDateTime", passiveDnsRecord.collectedDateTime);
    writer.writeDateValue("firstSeenDateTime", passiveDnsRecord.firstSeenDateTime);
    writer.writeDateValue("lastSeenDateTime", passiveDnsRecord.lastSeenDateTime);
    writer.writeObjectValue<Host>("parentHost", passiveDnsRecord.parentHost, serializeHost);
    writer.writeStringValue("recordType", passiveDnsRecord.recordType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePassiveDnsRecordCollectionResponse(writer: SerializationWriter, passiveDnsRecordCollectionResponse: Partial<PassiveDnsRecordCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, passiveDnsRecordCollectionResponse)
    writer.writeCollectionOfObjectValues<PassiveDnsRecord>("value", passiveDnsRecordCollectionResponse.value, serializePassiveDnsRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePolicyBase(writer: SerializationWriter, policyBase: Partial<PolicyBase> | undefined = {}) : void {
    serializeEntity(writer, policyBase)
    writer.writeObjectValue<IdentitySet>("createdBy", policyBase.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", policyBase.createdDateTime);
    writer.writeStringValue("description", policyBase.description);
    writer.writeStringValue("displayName", policyBase.displayName);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", policyBase.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", policyBase.lastModifiedDateTime);
    writer.writeEnumValue<PolicyStatus>("status", policyBase.status);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProcessEvidence(writer: SerializationWriter, processEvidence: Partial<ProcessEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, processEvidence)
    writer.writeEnumValue<DetectionStatus>("detectionStatus", processEvidence.detectionStatus);
    writer.writeObjectValue<FileDetails>("imageFile", processEvidence.imageFile, serializeFileDetails);
    writer.writeStringValue("mdeDeviceId", processEvidence.mdeDeviceId);
    writer.writeDateValue("parentProcessCreationDateTime", processEvidence.parentProcessCreationDateTime);
    writer.writeNumberValue("parentProcessId", processEvidence.parentProcessId);
    writer.writeObjectValue<FileDetails>("parentProcessImageFile", processEvidence.parentProcessImageFile, serializeFileDetails);
    writer.writeStringValue("processCommandLine", processEvidence.processCommandLine);
    writer.writeDateValue("processCreationDateTime", processEvidence.processCreationDateTime);
    writer.writeNumberValue("processId", processEvidence.processId);
    writer.writeObjectValue<UserAccount>("userAccount", processEvidence.userAccount, serializeUserAccount);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProtectAdhocAction(writer: SerializationWriter, protectAdhocAction: Partial<ProtectAdhocAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, protectAdhocAction)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProtectByTemplateAction(writer: SerializationWriter, protectByTemplateAction: Partial<ProtectByTemplateAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, protectByTemplateAction)
    writer.writeStringValue("templateId", protectByTemplateAction.templateId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProtectDoNotForwardAction(writer: SerializationWriter, protectDoNotForwardAction: Partial<ProtectDoNotForwardAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, protectDoNotForwardAction)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProtectionRule(writer: SerializationWriter, protectionRule: Partial<ProtectionRule> | undefined = {}) : void {
    serializeEntity(writer, protectionRule)
    writer.writeStringValue("createdBy", protectionRule.createdBy);
    writer.writeDateValue("createdDateTime", protectionRule.createdDateTime);
    writer.writeStringValue("displayName", protectionRule.displayName);
    writer.writeBooleanValue("isEnabled", protectionRule.isEnabled);
    writer.writeStringValue("lastModifiedBy", protectionRule.lastModifiedBy);
    writer.writeDateValue("lastModifiedDateTime", protectionRule.lastModifiedDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeQueryCondition(writer: SerializationWriter, queryCondition: Partial<QueryCondition> | undefined = {}) : void {
    writer.writeDateValue("lastModifiedDateTime", queryCondition.lastModifiedDateTime);
    writer.writeStringValue("@odata.type", queryCondition.odataType);
    writer.writeStringValue("queryText", queryCondition.queryText);
    writer.writeAdditionalData(queryCondition.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRecommendedHuntingQuery(writer: SerializationWriter, recommendedHuntingQuery: Partial<RecommendedHuntingQuery> | undefined = {}) : void {
    writer.writeStringValue("kqlText", recommendedHuntingQuery.kqlText);
    writer.writeStringValue("@odata.type", recommendedHuntingQuery.odataType);
    writer.writeAdditionalData(recommendedHuntingQuery.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRecommendLabelAction(writer: SerializationWriter, recommendLabelAction: Partial<RecommendLabelAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, recommendLabelAction)
    writer.writeCollectionOfObjectValues<InformationProtectionAction>("actions", recommendLabelAction.actions, serializeInformationProtectionAction);
    writer.writeEnumValue<ActionSource>("actionSource", recommendLabelAction.actionSource);
    writer.writeCollectionOfPrimitiveValues<string>("responsibleSensitiveTypeIds", recommendLabelAction.responsibleSensitiveTypeIds);
    writer.writeStringValue("sensitivityLabelId", recommendLabelAction.sensitivityLabelId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRedundancyDetectionSettings(writer: SerializationWriter, redundancyDetectionSettings: Partial<RedundancyDetectionSettings> | undefined = {}) : void {
    writer.writeBooleanValue("isEnabled", redundancyDetectionSettings.isEnabled);
    writer.writeNumberValue("maxWords", redundancyDetectionSettings.maxWords);
    writer.writeNumberValue("minWords", redundancyDetectionSettings.minWords);
    writer.writeStringValue("@odata.type", redundancyDetectionSettings.odataType);
    writer.writeNumberValue("similarityThreshold", redundancyDetectionSettings.similarityThreshold);
    writer.writeAdditionalData(redundancyDetectionSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRegistryKeyEvidence(writer: SerializationWriter, registryKeyEvidence: Partial<RegistryKeyEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, registryKeyEvidence)
    writer.writeStringValue("registryHive", registryKeyEvidence.registryHive);
    writer.writeStringValue("registryKey", registryKeyEvidence.registryKey);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRegistryValueEvidence(writer: SerializationWriter, registryValueEvidence: Partial<RegistryValueEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, registryValueEvidence)
    writer.writeStringValue("mdeDeviceId", registryValueEvidence.mdeDeviceId);
    writer.writeStringValue("registryHive", registryValueEvidence.registryHive);
    writer.writeStringValue("registryKey", registryValueEvidence.registryKey);
    writer.writeStringValue("registryValue", registryValueEvidence.registryValue);
    writer.writeStringValue("registryValueName", registryValueEvidence.registryValueName);
    writer.writeStringValue("registryValueType", registryValueEvidence.registryValueType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRemoveContentFooterAction(writer: SerializationWriter, removeContentFooterAction: Partial<RemoveContentFooterAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, removeContentFooterAction)
    writer.writeCollectionOfPrimitiveValues<string>("uiElementNames", removeContentFooterAction.uiElementNames);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRemoveContentHeaderAction(writer: SerializationWriter, removeContentHeaderAction: Partial<RemoveContentHeaderAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, removeContentHeaderAction)
    writer.writeCollectionOfPrimitiveValues<string>("uiElementNames", removeContentHeaderAction.uiElementNames);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRemoveProtectionAction(writer: SerializationWriter, removeProtectionAction: Partial<RemoveProtectionAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, removeProtectionAction)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRemoveWatermarkAction(writer: SerializationWriter, removeWatermarkAction: Partial<RemoveWatermarkAction> | undefined = {}) : void {
    serializeInformationProtectionAction(writer, removeWatermarkAction)
    writer.writeCollectionOfPrimitiveValues<string>("uiElementNames", removeWatermarkAction.uiElementNames);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeResponseAction(writer: SerializationWriter, responseAction: Partial<ResponseAction> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", responseAction.odataType);
    writer.writeAdditionalData(responseAction.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRestrictAppExecutionResponseAction(writer: SerializationWriter, restrictAppExecutionResponseAction: Partial<RestrictAppExecutionResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, restrictAppExecutionResponseAction)
    writer.writeEnumValue<DeviceIdEntityIdentifier[]>("identifier", restrictAppExecutionResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionDuration(writer: SerializationWriter, retentionDuration: Partial<RetentionDuration> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", retentionDuration.odataType);
    writer.writeAdditionalData(retentionDuration.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionDurationForever(writer: SerializationWriter, retentionDurationForever: Partial<RetentionDurationForever> | undefined = {}) : void {
    serializeRetentionDuration(writer, retentionDurationForever)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionDurationInDays(writer: SerializationWriter, retentionDurationInDays: Partial<RetentionDurationInDays> | undefined = {}) : void {
    serializeRetentionDuration(writer, retentionDurationInDays)
    writer.writeNumberValue("days", retentionDurationInDays.days);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionEvent(writer: SerializationWriter, retentionEvent: Partial<RetentionEvent> | undefined = {}) : void {
    serializeEntity(writer, retentionEvent)
    writer.writeObjectValue<IdentitySet>("createdBy", retentionEvent.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", retentionEvent.createdDateTime);
    writer.writeStringValue("description", retentionEvent.description);
    writer.writeStringValue("displayName", retentionEvent.displayName);
    writer.writeCollectionOfObjectValues<EventPropagationResult>("eventPropagationResults", retentionEvent.eventPropagationResults, serializeEventPropagationResult);
    writer.writeCollectionOfObjectValues<EventQuery>("eventQueries", retentionEvent.eventQueries, serializeEventQuery);
    writer.writeObjectValue<RetentionEventStatus>("eventStatus", retentionEvent.eventStatus, serializeRetentionEventStatus);
    writer.writeDateValue("eventTriggerDateTime", retentionEvent.eventTriggerDateTime);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", retentionEvent.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", retentionEvent.lastModifiedDateTime);
    writer.writeDateValue("lastStatusUpdateDateTime", retentionEvent.lastStatusUpdateDateTime);
    writer.writeObjectValue<RetentionEventType>("retentionEventType", retentionEvent.retentionEventType, serializeRetentionEventType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionEventCollectionResponse(writer: SerializationWriter, retentionEventCollectionResponse: Partial<RetentionEventCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, retentionEventCollectionResponse)
    writer.writeCollectionOfObjectValues<RetentionEvent>("value", retentionEventCollectionResponse.value, serializeRetentionEvent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionEventStatus(writer: SerializationWriter, retentionEventStatus: Partial<RetentionEventStatus> | undefined = {}) : void {
    writer.writeObjectValue<PublicError>("error", retentionEventStatus.errorEscaped, serializePublicError);
    writer.writeStringValue("@odata.type", retentionEventStatus.odataType);
    writer.writeEnumValue<EventStatusType>("status", retentionEventStatus.status);
    writer.writeAdditionalData(retentionEventStatus.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionEventType(writer: SerializationWriter, retentionEventType: Partial<RetentionEventType> | undefined = {}) : void {
    serializeEntity(writer, retentionEventType)
    writer.writeObjectValue<IdentitySet>("createdBy", retentionEventType.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", retentionEventType.createdDateTime);
    writer.writeStringValue("description", retentionEventType.description);
    writer.writeStringValue("displayName", retentionEventType.displayName);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", retentionEventType.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", retentionEventType.lastModifiedDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionEventTypeCollectionResponse(writer: SerializationWriter, retentionEventTypeCollectionResponse: Partial<RetentionEventTypeCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, retentionEventTypeCollectionResponse)
    writer.writeCollectionOfObjectValues<RetentionEventType>("value", retentionEventTypeCollectionResponse.value, serializeRetentionEventType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionLabel(writer: SerializationWriter, retentionLabel: Partial<RetentionLabel> | undefined = {}) : void {
    serializeEntity(writer, retentionLabel)
    writer.writeEnumValue<ActionAfterRetentionPeriod>("actionAfterRetentionPeriod", retentionLabel.actionAfterRetentionPeriod);
    writer.writeEnumValue<BehaviorDuringRetentionPeriod>("behaviorDuringRetentionPeriod", retentionLabel.behaviorDuringRetentionPeriod);
    writer.writeObjectValue<IdentitySet>("createdBy", retentionLabel.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", retentionLabel.createdDateTime);
    writer.writeEnumValue<DefaultRecordBehavior>("defaultRecordBehavior", retentionLabel.defaultRecordBehavior);
    writer.writeStringValue("descriptionForAdmins", retentionLabel.descriptionForAdmins);
    writer.writeStringValue("descriptionForUsers", retentionLabel.descriptionForUsers);
    writer.writeObjectValue<FilePlanDescriptor>("descriptors", retentionLabel.descriptors, serializeFilePlanDescriptor);
    writer.writeStringValue("displayName", retentionLabel.displayName);
    writer.writeCollectionOfObjectValues<DispositionReviewStage>("dispositionReviewStages", retentionLabel.dispositionReviewStages, serializeDispositionReviewStage);
    writer.writeBooleanValue("isInUse", retentionLabel.isInUse);
    writer.writeStringValue("labelToBeApplied", retentionLabel.labelToBeApplied);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", retentionLabel.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", retentionLabel.lastModifiedDateTime);
    writer.writeObjectValue<RetentionDuration>("retentionDuration", retentionLabel.retentionDuration, serializeRetentionDuration);
    writer.writeObjectValue<RetentionEventType>("retentionEventType", retentionLabel.retentionEventType, serializeRetentionEventType);
    writer.writeEnumValue<RetentionTrigger>("retentionTrigger", retentionLabel.retentionTrigger);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionLabelCollectionResponse(writer: SerializationWriter, retentionLabelCollectionResponse: Partial<RetentionLabelCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, retentionLabelCollectionResponse)
    writer.writeCollectionOfObjectValues<RetentionLabel>("value", retentionLabelCollectionResponse.value, serializeRetentionLabel);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRuleSchedule(writer: SerializationWriter, ruleSchedule: Partial<RuleSchedule> | undefined = {}) : void {
    writer.writeDateValue("nextRunDateTime", ruleSchedule.nextRunDateTime);
    writer.writeStringValue("@odata.type", ruleSchedule.odataType);
    writer.writeStringValue("period", ruleSchedule.period);
    writer.writeAdditionalData(ruleSchedule.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRulesRoot(writer: SerializationWriter, rulesRoot: Partial<RulesRoot> | undefined = {}) : void {
    serializeEntity(writer, rulesRoot)
    writer.writeCollectionOfObjectValues<DetectionRule>("detectionRules", rulesRoot.detectionRules, serializeDetectionRule);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRunAntivirusScanResponseAction(writer: SerializationWriter, runAntivirusScanResponseAction: Partial<RunAntivirusScanResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, runAntivirusScanResponseAction)
    writer.writeEnumValue<DeviceIdEntityIdentifier[]>("identifier", runAntivirusScanResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRunDetails(writer: SerializationWriter, runDetails: Partial<RunDetails> | undefined = {}) : void {
    writer.writeEnumValue<HuntingRuleErrorCode>("errorCode", runDetails.errorCode);
    writer.writeStringValue("failureReason", runDetails.failureReason);
    writer.writeDateValue("lastRunDateTime", runDetails.lastRunDateTime);
    writer.writeStringValue("@odata.type", runDetails.odataType);
    writer.writeEnumValue<HuntingRuleRunStatus>("status", runDetails.status);
    writer.writeAdditionalData(runDetails.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSasTokenEvidence(writer: SerializationWriter, sasTokenEvidence: Partial<SasTokenEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, sasTokenEvidence)
    writer.writeStringValue("allowedIpAddresses", sasTokenEvidence.allowedIpAddresses);
    writer.writeCollectionOfPrimitiveValues<string>("allowedResourceTypes", sasTokenEvidence.allowedResourceTypes);
    writer.writeCollectionOfPrimitiveValues<string>("allowedServices", sasTokenEvidence.allowedServices);
    writer.writeDateValue("expiryDateTime", sasTokenEvidence.expiryDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("permissions", sasTokenEvidence.permissions);
    writer.writeStringValue("protocol", sasTokenEvidence.protocol);
    writer.writeStringValue("signatureHash", sasTokenEvidence.signatureHash);
    writer.writeStringValue("signedWith", sasTokenEvidence.signedWith);
    writer.writeDateValue("startDateTime", sasTokenEvidence.startDateTime);
    writer.writeObjectValue<AzureResourceEvidence>("storageResource", sasTokenEvidence.storageResource, serializeAzureResourceEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSearch(writer: SerializationWriter, search: Partial<Search> | undefined = {}) : void {
    serializeEntity(writer, search)
    writer.writeStringValue("contentQuery", search.contentQuery);
    writer.writeObjectValue<IdentitySet>("createdBy", search.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", search.createdDateTime);
    writer.writeStringValue("description", search.description);
    writer.writeStringValue("displayName", search.displayName);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", search.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", search.lastModifiedDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSecurity(writer: SerializationWriter, security: Partial<Security> | undefined = {}) : void {
    serializeEntity(writer, security)
    writer.writeObjectValue<InformationProtection>("informationProtection", security.informationProtection, serializeInformationProtection);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSecurityGroupEvidence(writer: SerializationWriter, securityGroupEvidence: Partial<SecurityGroupEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, securityGroupEvidence)
    writer.writeStringValue("displayName", securityGroupEvidence.displayName);
    writer.writeStringValue("securityGroupId", securityGroupEvidence.securityGroupId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSensitivityLabel(writer: SerializationWriter, sensitivityLabel: Partial<SensitivityLabel> | undefined = {}) : void {
    serializeEntity(writer, sensitivityLabel)
    writer.writeStringValue("color", sensitivityLabel.color);
    writer.writeCollectionOfPrimitiveValues<string>("contentFormats", sensitivityLabel.contentFormats);
    writer.writeStringValue("description", sensitivityLabel.description);
    writer.writeBooleanValue("hasProtection", sensitivityLabel.hasProtection);
    writer.writeBooleanValue("isActive", sensitivityLabel.isActive);
    writer.writeBooleanValue("isAppliable", sensitivityLabel.isAppliable);
    writer.writeStringValue("name", sensitivityLabel.name);
    writer.writeObjectValue<SensitivityLabel>("parent", sensitivityLabel.parent, serializeSensitivityLabel);
    writer.writeNumberValue("sensitivity", sensitivityLabel.sensitivity);
    writer.writeStringValue("tooltip", sensitivityLabel.tooltip);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSensitivityLabelCollectionResponse(writer: SerializationWriter, sensitivityLabelCollectionResponse: Partial<SensitivityLabelCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, sensitivityLabelCollectionResponse)
    writer.writeCollectionOfObjectValues<SensitivityLabel>("value", sensitivityLabelCollectionResponse.value, serializeSensitivityLabel);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSensor(writer: SerializationWriter, sensor: Partial<Sensor> | undefined = {}) : void {
    serializeEntity(writer, sensor)
    writer.writeDateValue("createdDateTime", sensor.createdDateTime);
    writer.writeEnumValue<DeploymentStatus>("deploymentStatus", sensor.deploymentStatus);
    writer.writeStringValue("displayName", sensor.displayName);
    writer.writeStringValue("domainName", sensor.domainName);
    writer.writeCollectionOfObjectValues<HealthIssue>("healthIssues", sensor.healthIssues, serializeHealthIssue);
    writer.writeEnumValue<SensorHealthStatus>("healthStatus", sensor.healthStatus);
    writer.writeNumberValue("openHealthIssuesCount", sensor.openHealthIssuesCount);
    writer.writeEnumValue<SensorType>("sensorType", sensor.sensorType);
    writer.writeObjectValue<SensorSettings>("settings", sensor.settings, serializeSensorSettings);
    writer.writeStringValue("version", sensor.version);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSensorCollectionResponse(writer: SerializationWriter, sensorCollectionResponse: Partial<SensorCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, sensorCollectionResponse)
    writer.writeCollectionOfObjectValues<Sensor>("value", sensorCollectionResponse.value, serializeSensor);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSensorDeploymentPackage(writer: SerializationWriter, sensorDeploymentPackage: Partial<SensorDeploymentPackage> | undefined = {}) : void {
    writer.writeStringValue("downloadUrl", sensorDeploymentPackage.downloadUrl);
    writer.writeStringValue("@odata.type", sensorDeploymentPackage.odataType);
    writer.writeStringValue("version", sensorDeploymentPackage.version);
    writer.writeAdditionalData(sensorDeploymentPackage.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSensorSettings(writer: SerializationWriter, sensorSettings: Partial<SensorSettings> | undefined = {}) : void {
    writer.writeStringValue("description", sensorSettings.description);
    writer.writeCollectionOfPrimitiveValues<string>("domainControllerDnsNames", sensorSettings.domainControllerDnsNames);
    writer.writeBooleanValue("isDelayedDeploymentEnabled", sensorSettings.isDelayedDeploymentEnabled);
    writer.writeCollectionOfObjectValues<NetworkAdapter>("networkAdapters", sensorSettings.networkAdapters, serializeNetworkAdapter);
    writer.writeStringValue("@odata.type", sensorSettings.odataType);
    writer.writeAdditionalData(sensorSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeServicePrincipalEvidence(writer: SerializationWriter, servicePrincipalEvidence: Partial<ServicePrincipalEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, servicePrincipalEvidence)
    writer.writeStringValue("appId", servicePrincipalEvidence.appId);
    writer.writeStringValue("appOwnerTenantId", servicePrincipalEvidence.appOwnerTenantId);
    writer.writeStringValue("servicePrincipalName", servicePrincipalEvidence.servicePrincipalName);
    writer.writeStringValue("servicePrincipalObjectId", servicePrincipalEvidence.servicePrincipalObjectId);
    writer.writeEnumValue<ServicePrincipalType>("servicePrincipalType", servicePrincipalEvidence.servicePrincipalType);
    writer.writeStringValue("tenantId", servicePrincipalEvidence.tenantId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSinglePropertySchema(writer: SerializationWriter, singlePropertySchema: Partial<SinglePropertySchema> | undefined = {}) : void {
    writer.writeStringValue("name", singlePropertySchema.name);
    writer.writeStringValue("@odata.type", singlePropertySchema.odataType);
    writer.writeStringValue("type", singlePropertySchema.type);
    writer.writeAdditionalData(singlePropertySchema.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSiteSource(writer: SerializationWriter, siteSource: Partial<SiteSource> | undefined = {}) : void {
    serializeDataSource(writer, siteSource)
    writer.writeObjectValue<Site>("site", siteSource.site, serializeSite);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSiteSourceCollectionResponse(writer: SerializationWriter, siteSourceCollectionResponse: Partial<SiteSourceCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, siteSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<SiteSource>("value", siteSourceCollectionResponse.value, serializeSiteSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSoftDeleteResponseAction(writer: SerializationWriter, softDeleteResponseAction: Partial<SoftDeleteResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, softDeleteResponseAction)
    writer.writeEnumValue<EmailEntityIdentifier[]>("identifier", softDeleteResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSslCertificate(writer: SerializationWriter, sslCertificate: Partial<SslCertificate> | undefined = {}) : void {
    serializeArtifact(writer, sslCertificate)
    writer.writeDateValue("expirationDateTime", sslCertificate.expirationDateTime);
    writer.writeStringValue("fingerprint", sslCertificate.fingerprint);
    writer.writeDateValue("firstSeenDateTime", sslCertificate.firstSeenDateTime);
    writer.writeDateValue("issueDateTime", sslCertificate.issueDateTime);
    writer.writeObjectValue<SslCertificateEntity>("issuer", sslCertificate.issuer, serializeSslCertificateEntity);
    writer.writeDateValue("lastSeenDateTime", sslCertificate.lastSeenDateTime);
    writer.writeCollectionOfObjectValues<Host>("relatedHosts", sslCertificate.relatedHosts, serializeHost);
    writer.writeStringValue("serialNumber", sslCertificate.serialNumber);
    writer.writeStringValue("sha1", sslCertificate.sha1);
    writer.writeObjectValue<SslCertificateEntity>("subject", sslCertificate.subject, serializeSslCertificateEntity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSslCertificateCollectionResponse(writer: SerializationWriter, sslCertificateCollectionResponse: Partial<SslCertificateCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, sslCertificateCollectionResponse)
    writer.writeCollectionOfObjectValues<SslCertificate>("value", sslCertificateCollectionResponse.value, serializeSslCertificate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSslCertificateEntity(writer: SerializationWriter, sslCertificateEntity: Partial<SslCertificateEntity> | undefined = {}) : void {
    writer.writeObjectValue<PhysicalAddress>("address", sslCertificateEntity.address, serializePhysicalAddress);
    writer.writeCollectionOfPrimitiveValues<string>("alternateNames", sslCertificateEntity.alternateNames);
    writer.writeStringValue("commonName", sslCertificateEntity.commonName);
    writer.writeStringValue("email", sslCertificateEntity.email);
    writer.writeStringValue("givenName", sslCertificateEntity.givenName);
    writer.writeStringValue("@odata.type", sslCertificateEntity.odataType);
    writer.writeStringValue("organizationName", sslCertificateEntity.organizationName);
    writer.writeStringValue("organizationUnitName", sslCertificateEntity.organizationUnitName);
    writer.writeStringValue("serialNumber", sslCertificateEntity.serialNumber);
    writer.writeStringValue("surname", sslCertificateEntity.surname);
    writer.writeAdditionalData(sslCertificateEntity.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeStopAndQuarantineFileResponseAction(writer: SerializationWriter, stopAndQuarantineFileResponseAction: Partial<StopAndQuarantineFileResponseAction> | undefined = {}) : void {
    serializeResponseAction(writer, stopAndQuarantineFileResponseAction)
    writer.writeEnumValue<StopAndQuarantineFileEntityIdentifier[]>("identifier", stopAndQuarantineFileResponseAction.identifier);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeStream(writer: SerializationWriter, stream: Partial<Stream> | undefined = {}) : void {
    writer.writeStringValue("name", stream.name);
    writer.writeStringValue("@odata.type", stream.odataType);
    writer.writeAdditionalData(stream.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeStringValueDictionary(writer: SerializationWriter, stringValueDictionary: Partial<StringValueDictionary> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", stringValueDictionary.odataType);
    writer.writeAdditionalData(stringValueDictionary.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubcategoryTemplate(writer: SerializationWriter, subcategoryTemplate: Partial<SubcategoryTemplate> | undefined = {}) : void {
    serializeFilePlanDescriptorTemplate(writer, subcategoryTemplate)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubcategoryTemplateCollectionResponse(writer: SerializationWriter, subcategoryTemplateCollectionResponse: Partial<SubcategoryTemplateCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, subcategoryTemplateCollectionResponse)
    writer.writeCollectionOfObjectValues<SubcategoryTemplate>("value", subcategoryTemplateCollectionResponse.value, serializeSubcategoryTemplate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubdomain(writer: SerializationWriter, subdomain: Partial<Subdomain> | undefined = {}) : void {
    serializeEntity(writer, subdomain)
    writer.writeDateValue("firstSeenDateTime", subdomain.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", subdomain.host, serializeHost);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubdomainCollectionResponse(writer: SerializationWriter, subdomainCollectionResponse: Partial<SubdomainCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, subdomainCollectionResponse)
    writer.writeCollectionOfObjectValues<Subdomain>("value", subdomainCollectionResponse.value, serializeSubdomain);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubmissionAdminReview(writer: SerializationWriter, submissionAdminReview: Partial<SubmissionAdminReview> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", submissionAdminReview.odataType);
    writer.writeStringValue("reviewBy", submissionAdminReview.reviewBy);
    writer.writeDateValue("reviewDateTime", submissionAdminReview.reviewDateTime);
    writer.writeEnumValue<SubmissionResultCategory>("reviewResult", submissionAdminReview.reviewResult);
    writer.writeAdditionalData(submissionAdminReview.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubmissionDetectedFile(writer: SerializationWriter, submissionDetectedFile: Partial<SubmissionDetectedFile> | undefined = {}) : void {
    writer.writeStringValue("fileHash", submissionDetectedFile.fileHash);
    writer.writeStringValue("fileName", submissionDetectedFile.fileName);
    writer.writeStringValue("@odata.type", submissionDetectedFile.odataType);
    writer.writeAdditionalData(submissionDetectedFile.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubmissionMailEvidence(writer: SerializationWriter, submissionMailEvidence: Partial<SubmissionMailEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, submissionMailEvidence)
    writer.writeStringValue("networkMessageId", submissionMailEvidence.networkMessageId);
    writer.writeStringValue("recipient", submissionMailEvidence.recipient);
    writer.writeStringValue("reportType", submissionMailEvidence.reportType);
    writer.writeStringValue("sender", submissionMailEvidence.sender);
    writer.writeStringValue("senderIp", submissionMailEvidence.senderIp);
    writer.writeStringValue("subject", submissionMailEvidence.subject);
    writer.writeDateValue("submissionDateTime", submissionMailEvidence.submissionDateTime);
    writer.writeStringValue("submissionId", submissionMailEvidence.submissionId);
    writer.writeStringValue("submitter", submissionMailEvidence.submitter);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubmissionResult(writer: SerializationWriter, submissionResult: Partial<SubmissionResult> | undefined = {}) : void {
    writer.writeEnumValue<SubmissionResultCategory>("category", submissionResult.category);
    writer.writeEnumValue<SubmissionResultDetail>("detail", submissionResult.detail);
    writer.writeCollectionOfObjectValues<SubmissionDetectedFile>("detectedFiles", submissionResult.detectedFiles, serializeSubmissionDetectedFile);
    writer.writeCollectionOfPrimitiveValues<string>("detectedUrls", submissionResult.detectedUrls);
    writer.writeStringValue("@odata.type", submissionResult.odataType);
    writer.writeEnumValue<UserMailboxSetting[]>("userMailboxSetting", submissionResult.userMailboxSetting);
    writer.writeAdditionalData(submissionResult.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubmissionUserIdentity(writer: SerializationWriter, submissionUserIdentity: Partial<SubmissionUserIdentity> | undefined = {}) : void {
    serializeIdentity(writer, submissionUserIdentity)
    writer.writeStringValue("email", submissionUserIdentity.email);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTag(writer: SerializationWriter, tag: Partial<Tag> | undefined = {}) : void {
    serializeEntity(writer, tag)
    writer.writeObjectValue<IdentitySet>("createdBy", tag.createdBy, serializeIdentitySet);
    writer.writeStringValue("description", tag.description);
    writer.writeStringValue("displayName", tag.displayName);
    writer.writeDateValue("lastModifiedDateTime", tag.lastModifiedDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTenantAllowBlockListEntryResult(writer: SerializationWriter, tenantAllowBlockListEntryResult: Partial<TenantAllowBlockListEntryResult> | undefined = {}) : void {
    writer.writeEnumValue<TenantAllowBlockListEntryType>("entryType", tenantAllowBlockListEntryResult.entryType);
    writer.writeDateValue("expirationDateTime", tenantAllowBlockListEntryResult.expirationDateTime);
    writer.writeStringValue("identity", tenantAllowBlockListEntryResult.identity);
    writer.writeStringValue("@odata.type", tenantAllowBlockListEntryResult.odataType);
    writer.writeEnumValue<LongRunningOperationStatus>("status", tenantAllowBlockListEntryResult.status);
    writer.writeStringValue("value", tenantAllowBlockListEntryResult.value);
    writer.writeAdditionalData(tenantAllowBlockListEntryResult.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTenantAllowOrBlockListAction(writer: SerializationWriter, tenantAllowOrBlockListAction: Partial<TenantAllowOrBlockListAction> | undefined = {}) : void {
    writer.writeEnumValue<TenantAllowBlockListAction>("action", tenantAllowOrBlockListAction.action);
    writer.writeDateValue("expirationDateTime", tenantAllowOrBlockListAction.expirationDateTime);
    writer.writeStringValue("note", tenantAllowOrBlockListAction.note);
    writer.writeStringValue("@odata.type", tenantAllowOrBlockListAction.odataType);
    writer.writeCollectionOfObjectValues<TenantAllowBlockListEntryResult>("results", tenantAllowOrBlockListAction.results, serializeTenantAllowBlockListEntryResult);
    writer.writeAdditionalData(tenantAllowOrBlockListAction.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeThreatIntelligence(writer: SerializationWriter, threatIntelligence: Partial<ThreatIntelligence> | undefined = {}) : void {
    serializeEntity(writer, threatIntelligence)
    writer.writeCollectionOfObjectValues<ArticleIndicator>("articleIndicators", threatIntelligence.articleIndicators, serializeArticleIndicator);
    writer.writeCollectionOfObjectValues<Article>("articles", threatIntelligence.articles, serializeArticle);
    writer.writeCollectionOfObjectValues<HostComponent>("hostComponents", threatIntelligence.hostComponents, serializeHostComponent);
    writer.writeCollectionOfObjectValues<HostCookie>("hostCookies", threatIntelligence.hostCookies, serializeHostCookie);
    writer.writeCollectionOfObjectValues<HostPair>("hostPairs", threatIntelligence.hostPairs, serializeHostPair);
    writer.writeCollectionOfObjectValues<HostPort>("hostPorts", threatIntelligence.hostPorts, serializeHostPort);
    writer.writeCollectionOfObjectValues<Host>("hosts", threatIntelligence.hosts, serializeHost);
    writer.writeCollectionOfObjectValues<HostSslCertificate>("hostSslCertificates", threatIntelligence.hostSslCertificates, serializeHostSslCertificate);
    writer.writeCollectionOfObjectValues<HostTracker>("hostTrackers", threatIntelligence.hostTrackers, serializeHostTracker);
    writer.writeCollectionOfObjectValues<IntelligenceProfileIndicator>("intelligenceProfileIndicators", threatIntelligence.intelligenceProfileIndicators, serializeIntelligenceProfileIndicator);
    writer.writeCollectionOfObjectValues<IntelligenceProfile>("intelProfiles", threatIntelligence.intelProfiles, serializeIntelligenceProfile);
    writer.writeCollectionOfObjectValues<PassiveDnsRecord>("passiveDnsRecords", threatIntelligence.passiveDnsRecords, serializePassiveDnsRecord);
    writer.writeCollectionOfObjectValues<SslCertificate>("sslCertificates", threatIntelligence.sslCertificates, serializeSslCertificate);
    writer.writeCollectionOfObjectValues<Subdomain>("subdomains", threatIntelligence.subdomains, serializeSubdomain);
    writer.writeCollectionOfObjectValues<Vulnerability>("vulnerabilities", threatIntelligence.vulnerabilities, serializeVulnerability);
    writer.writeCollectionOfObjectValues<WhoisHistoryRecord>("whoisHistoryRecords", threatIntelligence.whoisHistoryRecords, serializeWhoisHistoryRecord);
    writer.writeCollectionOfObjectValues<WhoisRecord>("whoisRecords", threatIntelligence.whoisRecords, serializeWhoisRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeThreatSubmission(writer: SerializationWriter, threatSubmission: Partial<ThreatSubmission> | undefined = {}) : void {
    serializeEntity(writer, threatSubmission)
    writer.writeObjectValue<SubmissionAdminReview>("adminReview", threatSubmission.adminReview, serializeSubmissionAdminReview);
    writer.writeEnumValue<SubmissionCategory>("category", threatSubmission.category);
    writer.writeEnumValue<SubmissionClientSource>("clientSource", threatSubmission.clientSource);
    writer.writeEnumValue<SubmissionContentType>("contentType", threatSubmission.contentType);
    writer.writeObjectValue<SubmissionUserIdentity>("createdBy", threatSubmission.createdBy, serializeSubmissionUserIdentity);
    writer.writeDateValue("createdDateTime", threatSubmission.createdDateTime);
    writer.writeObjectValue<SubmissionResult>("result", threatSubmission.result, serializeSubmissionResult);
    writer.writeEnumValue<SubmissionSource>("source", threatSubmission.source);
    writer.writeEnumValue<LongRunningOperationStatus>("status", threatSubmission.status);
    writer.writeStringValue("tenantId", threatSubmission.tenantId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeThreatSubmissionRoot(writer: SerializationWriter, threatSubmissionRoot: Partial<ThreatSubmissionRoot> | undefined = {}) : void {
    serializeEntity(writer, threatSubmissionRoot)
    writer.writeCollectionOfObjectValues<EmailThreatSubmission>("emailThreats", threatSubmissionRoot.emailThreats, serializeEmailThreatSubmission);
    writer.writeCollectionOfObjectValues<EmailThreatSubmissionPolicy>("emailThreatSubmissionPolicies", threatSubmissionRoot.emailThreatSubmissionPolicies, serializeEmailThreatSubmissionPolicy);
    writer.writeCollectionOfObjectValues<FileThreatSubmission>("fileThreats", threatSubmissionRoot.fileThreats, serializeFileThreatSubmission);
    writer.writeCollectionOfObjectValues<UrlThreatSubmission>("urlThreats", threatSubmissionRoot.urlThreats, serializeUrlThreatSubmission);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTopicModelingSettings(writer: SerializationWriter, topicModelingSettings: Partial<TopicModelingSettings> | undefined = {}) : void {
    writer.writeBooleanValue("dynamicallyAdjustTopicCount", topicModelingSettings.dynamicallyAdjustTopicCount);
    writer.writeBooleanValue("ignoreNumbers", topicModelingSettings.ignoreNumbers);
    writer.writeBooleanValue("isEnabled", topicModelingSettings.isEnabled);
    writer.writeStringValue("@odata.type", topicModelingSettings.odataType);
    writer.writeNumberValue("topicCount", topicModelingSettings.topicCount);
    writer.writeAdditionalData(topicModelingSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTriggersRoot(writer: SerializationWriter, triggersRoot: Partial<TriggersRoot> | undefined = {}) : void {
    serializeEntity(writer, triggersRoot)
    writer.writeCollectionOfObjectValues<RetentionEvent>("retentionEvents", triggersRoot.retentionEvents, serializeRetentionEvent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTriggerTypesRoot(writer: SerializationWriter, triggerTypesRoot: Partial<TriggerTypesRoot> | undefined = {}) : void {
    serializeEntity(writer, triggerTypesRoot)
    writer.writeCollectionOfObjectValues<RetentionEventType>("retentionEventTypes", triggerTypesRoot.retentionEventTypes, serializeRetentionEventType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUnclassifiedArtifact(writer: SerializationWriter, unclassifiedArtifact: Partial<UnclassifiedArtifact> | undefined = {}) : void {
    serializeArtifact(writer, unclassifiedArtifact)
    writer.writeStringValue("kind", unclassifiedArtifact.kind);
    writer.writeStringValue("value", unclassifiedArtifact.value);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUnifiedGroupSource(writer: SerializationWriter, unifiedGroupSource: Partial<UnifiedGroupSource> | undefined = {}) : void {
    serializeDataSource(writer, unifiedGroupSource)
    writer.writeObjectValue<Group>("group", unifiedGroupSource.group, serializeGroup);
    writer.writeEnumValue<SourceType[]>("includedSources", unifiedGroupSource.includedSources);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUnifiedGroupSourceCollectionResponse(writer: SerializationWriter, unifiedGroupSourceCollectionResponse: Partial<UnifiedGroupSourceCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, unifiedGroupSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<UnifiedGroupSource>("value", unifiedGroupSourceCollectionResponse.value, serializeUnifiedGroupSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUrlEvidence(writer: SerializationWriter, urlEvidence: Partial<UrlEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, urlEvidence)
    writer.writeStringValue("url", urlEvidence.url);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUrlThreatSubmission(writer: SerializationWriter, urlThreatSubmission: Partial<UrlThreatSubmission> | undefined = {}) : void {
    serializeThreatSubmission(writer, urlThreatSubmission)
    writer.writeStringValue("webUrl", urlThreatSubmission.webUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUrlThreatSubmissionCollectionResponse(writer: SerializationWriter, urlThreatSubmissionCollectionResponse: Partial<UrlThreatSubmissionCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, urlThreatSubmissionCollectionResponse)
    writer.writeCollectionOfObjectValues<UrlThreatSubmission>("value", urlThreatSubmissionCollectionResponse.value, serializeUrlThreatSubmission);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserAccount(writer: SerializationWriter, userAccount: Partial<UserAccount> | undefined = {}) : void {
    writer.writeStringValue("accountName", userAccount.accountName);
    writer.writeStringValue("azureAdUserId", userAccount.azureAdUserId);
    writer.writeStringValue("displayName", userAccount.displayName);
    writer.writeStringValue("domainName", userAccount.domainName);
    writer.writeStringValue("@odata.type", userAccount.odataType);
    writer.writeStringValue("userPrincipalName", userAccount.userPrincipalName);
    writer.writeStringValue("userSid", userAccount.userSid);
    writer.writeAdditionalData(userAccount.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserEvidence(writer: SerializationWriter, userEvidence: Partial<UserEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, userEvidence)
    writer.writeObjectValue<Stream>("stream", userEvidence.stream, serializeStream);
    writer.writeObjectValue<UserAccount>("userAccount", userEvidence.userAccount, serializeUserAccount);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserSource(writer: SerializationWriter, userSource: Partial<UserSource> | undefined = {}) : void {
    serializeDataSource(writer, userSource)
    writer.writeStringValue("email", userSource.email);
    writer.writeEnumValue<SourceType[]>("includedSources", userSource.includedSources);
    writer.writeStringValue("siteWebUrl", userSource.siteWebUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserSourceCollectionResponse(writer: SerializationWriter, userSourceCollectionResponse: Partial<UserSourceCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, userSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<UserSource>("value", userSourceCollectionResponse.value, serializeUserSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeVmMetadata(writer: SerializationWriter, vmMetadata: Partial<VmMetadata> | undefined = {}) : void {
    writer.writeEnumValue<VmCloudProvider>("cloudProvider", vmMetadata.cloudProvider);
    writer.writeStringValue("@odata.type", vmMetadata.odataType);
    writer.writeStringValue("resourceId", vmMetadata.resourceId);
    writer.writeStringValue("subscriptionId", vmMetadata.subscriptionId);
    writer.writeStringValue("vmId", vmMetadata.vmId);
    writer.writeAdditionalData(vmMetadata.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeVulnerability(writer: SerializationWriter, vulnerability: Partial<Vulnerability> | undefined = {}) : void {
    serializeEntity(writer, vulnerability)
    writer.writeBooleanValue("activeExploitsObserved", vulnerability.activeExploitsObserved);
    writer.writeCollectionOfObjectValues<Article>("articles", vulnerability.articles, serializeArticle);
    writer.writeCollectionOfPrimitiveValues<string>("commonWeaknessEnumerationIds", vulnerability.commonWeaknessEnumerationIds);
    writer.writeCollectionOfObjectValues<VulnerabilityComponent>("components", vulnerability.components, serializeVulnerabilityComponent);
    writer.writeDateValue("createdDateTime", vulnerability.createdDateTime);
    writer.writeObjectValue<CvssSummary>("cvss2Summary", vulnerability.cvss2Summary, serializeCvssSummary);
    writer.writeObjectValue<CvssSummary>("cvss3Summary", vulnerability.cvss3Summary, serializeCvssSummary);
    writer.writeObjectValue<FormattedContent>("description", vulnerability.description, serializeFormattedContent);
    writer.writeCollectionOfObjectValues<Hyperlink>("exploits", vulnerability.exploits, serializeHyperlink);
    writer.writeBooleanValue("exploitsAvailable", vulnerability.exploitsAvailable);
    writer.writeBooleanValue("hasChatter", vulnerability.hasChatter);
    writer.writeDateValue("lastModifiedDateTime", vulnerability.lastModifiedDateTime);
    writer.writeNumberValue("priorityScore", vulnerability.priorityScore);
    writer.writeDateValue("publishedDateTime", vulnerability.publishedDateTime);
    writer.writeCollectionOfObjectValues<Hyperlink>("references", vulnerability.references, serializeHyperlink);
    writer.writeObjectValue<FormattedContent>("remediation", vulnerability.remediation, serializeFormattedContent);
    writer.writeEnumValue<VulnerabilitySeverity>("severity", vulnerability.severity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeVulnerabilityCollectionResponse(writer: SerializationWriter, vulnerabilityCollectionResponse: Partial<VulnerabilityCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, vulnerabilityCollectionResponse)
    writer.writeCollectionOfObjectValues<Vulnerability>("value", vulnerabilityCollectionResponse.value, serializeVulnerability);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeVulnerabilityComponent(writer: SerializationWriter, vulnerabilityComponent: Partial<VulnerabilityComponent> | undefined = {}) : void {
    serializeEntity(writer, vulnerabilityComponent)
    writer.writeStringValue("name", vulnerabilityComponent.name);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeVulnerabilityComponentCollectionResponse(writer: SerializationWriter, vulnerabilityComponentCollectionResponse: Partial<VulnerabilityComponentCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, vulnerabilityComponentCollectionResponse)
    writer.writeCollectionOfObjectValues<VulnerabilityComponent>("value", vulnerabilityComponentCollectionResponse.value, serializeVulnerabilityComponent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisBaseRecord(writer: SerializationWriter, whoisBaseRecord: Partial<WhoisBaseRecord> | undefined = {}) : void {
    serializeEntity(writer, whoisBaseRecord)
    writer.writeObjectValue<WhoisContact>("abuse", whoisBaseRecord.abuse, serializeWhoisContact);
    writer.writeObjectValue<WhoisContact>("admin", whoisBaseRecord.admin, serializeWhoisContact);
    writer.writeObjectValue<WhoisContact>("billing", whoisBaseRecord.billing, serializeWhoisContact);
    writer.writeStringValue("domainStatus", whoisBaseRecord.domainStatus);
    writer.writeDateValue("expirationDateTime", whoisBaseRecord.expirationDateTime);
    writer.writeDateValue("firstSeenDateTime", whoisBaseRecord.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", whoisBaseRecord.host, serializeHost);
    writer.writeDateValue("lastSeenDateTime", whoisBaseRecord.lastSeenDateTime);
    writer.writeDateValue("lastUpdateDateTime", whoisBaseRecord.lastUpdateDateTime);
    writer.writeCollectionOfObjectValues<WhoisNameserver>("nameservers", whoisBaseRecord.nameservers, serializeWhoisNameserver);
    writer.writeObjectValue<WhoisContact>("noc", whoisBaseRecord.noc, serializeWhoisContact);
    writer.writeStringValue("rawWhoisText", whoisBaseRecord.rawWhoisText);
    writer.writeObjectValue<WhoisContact>("registrant", whoisBaseRecord.registrant, serializeWhoisContact);
    writer.writeObjectValue<WhoisContact>("registrar", whoisBaseRecord.registrar, serializeWhoisContact);
    writer.writeDateValue("registrationDateTime", whoisBaseRecord.registrationDateTime);
    writer.writeObjectValue<WhoisContact>("technical", whoisBaseRecord.technical, serializeWhoisContact);
    writer.writeStringValue("whoisServer", whoisBaseRecord.whoisServer);
    writer.writeObjectValue<WhoisContact>("zone", whoisBaseRecord.zone, serializeWhoisContact);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisContact(writer: SerializationWriter, whoisContact: Partial<WhoisContact> | undefined = {}) : void {
    writer.writeObjectValue<PhysicalAddress>("address", whoisContact.address, serializePhysicalAddress);
    writer.writeStringValue("email", whoisContact.email);
    writer.writeStringValue("fax", whoisContact.fax);
    writer.writeStringValue("name", whoisContact.name);
    writer.writeStringValue("@odata.type", whoisContact.odataType);
    writer.writeStringValue("organization", whoisContact.organization);
    writer.writeStringValue("telephone", whoisContact.telephone);
    writer.writeAdditionalData(whoisContact.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisHistoryRecord(writer: SerializationWriter, whoisHistoryRecord: Partial<WhoisHistoryRecord> | undefined = {}) : void {
    serializeWhoisBaseRecord(writer, whoisHistoryRecord)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisHistoryRecordCollectionResponse(writer: SerializationWriter, whoisHistoryRecordCollectionResponse: Partial<WhoisHistoryRecordCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, whoisHistoryRecordCollectionResponse)
    writer.writeCollectionOfObjectValues<WhoisHistoryRecord>("value", whoisHistoryRecordCollectionResponse.value, serializeWhoisHistoryRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisNameserver(writer: SerializationWriter, whoisNameserver: Partial<WhoisNameserver> | undefined = {}) : void {
    writer.writeDateValue("firstSeenDateTime", whoisNameserver.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", whoisNameserver.host, serializeHost);
    writer.writeDateValue("lastSeenDateTime", whoisNameserver.lastSeenDateTime);
    writer.writeStringValue("@odata.type", whoisNameserver.odataType);
    writer.writeAdditionalData(whoisNameserver.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisRecord(writer: SerializationWriter, whoisRecord: Partial<WhoisRecord> | undefined = {}) : void {
    serializeWhoisBaseRecord(writer, whoisRecord)
    writer.writeCollectionOfObjectValues<WhoisHistoryRecord>("history", whoisRecord.history, serializeWhoisHistoryRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisRecordCollectionResponse(writer: SerializationWriter, whoisRecordCollectionResponse: Partial<WhoisRecordCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, whoisRecordCollectionResponse)
    writer.writeCollectionOfObjectValues<WhoisRecord>("value", whoisRecordCollectionResponse.value, serializeWhoisRecord);
}
export interface ServicePrincipalEvidence extends AlertEvidence, Parsable {
    /**
     * The appId property
     */
    appId?: string;
    /**
     * The appOwnerTenantId property
     */
    appOwnerTenantId?: string;
    /**
     * The servicePrincipalName property
     */
    servicePrincipalName?: string;
    /**
     * The servicePrincipalObjectId property
     */
    servicePrincipalObjectId?: string;
    /**
     * The servicePrincipalType property
     */
    servicePrincipalType?: ServicePrincipalType;
    /**
     * The tenantId property
     */
    tenantId?: string;
}
export type ServicePrincipalType = (typeof ServicePrincipalTypeObject)[keyof typeof ServicePrincipalTypeObject];
export type ServiceSource = (typeof ServiceSourceObject)[keyof typeof ServiceSourceObject];
export interface SinglePropertySchema extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of the property.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The type of the property.
     */
    type?: string;
}
export interface SiteSource extends DataSource, Parsable {
    /**
     * The site property
     */
    site?: Site;
}
export interface SiteSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: SiteSource[];
}
export interface SoftDeleteResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: EmailEntityIdentifier[];
}
export type SourceType = (typeof SourceTypeObject)[keyof typeof SourceTypeObject];
export interface SslCertificate extends Artifact, Parsable {
    /**
     * The date and time when a certificate expires. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    expirationDateTime?: Date;
    /**
     * A hash of the certificate calculated on the data and signature.
     */
    fingerprint?: string;
    /**
     * The first date and time when this sslCertificate was observed. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The date and time when a certificate was issued. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    issueDateTime?: Date;
    /**
     * The entity that grants this certificate.
     */
    issuer?: SslCertificateEntity;
    /**
     * The most recent date and time when this sslCertificate was observed. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The hosts related with this sslCertificate.
     */
    relatedHosts?: Host[];
    /**
     * The serial number associated with an SSL certificate.
     */
    serialNumber?: string;
    /**
     * A SHA-1 hash of the certificate. Note: This is not the signature.
     */
    sha1?: string;
    /**
     * The person, site, machine, and so on, this certificate is for.
     */
    subject?: SslCertificateEntity;
}
export interface SslCertificateCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: SslCertificate[];
}
export interface SslCertificateEntity extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * A physical address of the entity.
     */
    address?: PhysicalAddress;
    /**
     * Alternate names for this entity that are part of the certificate.
     */
    alternateNames?: string[];
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * A common name for this entity.
     */
    commonName?: string;
    /**
     * An email for this entity.
     */
    email?: string;
    /**
     * If the entity is a person, this is the person's given name (first name).
     */
    givenName?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * If the entity is an organization, this is the name of the organization.
     */
    organizationName?: string;
    /**
     * If the entity is an organization, this communicates if a unit in the organization is named on the entity.
     */
    organizationUnitName?: string;
    /**
     * A serial number assigned to the entity; usually only available if the entity is the issuer.
     */
    serialNumber?: string;
    /**
     * If the entity is a person, this is the person's surname (last name).
     */
    surname?: string;
}
export type StopAndQuarantineFileEntityIdentifier = (typeof StopAndQuarantineFileEntityIdentifierObject)[keyof typeof StopAndQuarantineFileEntityIdentifierObject];
export interface StopAndQuarantineFileResponseAction extends Parsable, ResponseAction {
    /**
     * The identifier property
     */
    identifier?: StopAndQuarantineFileEntityIdentifier[];
}
export interface Stream extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name property
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface StringValueDictionary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface SubcategoryTemplate extends FilePlanDescriptorTemplate, Parsable {
}
export interface SubcategoryTemplateCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: SubcategoryTemplate[];
}
export interface Subdomain extends Entity, Parsable {
    /**
     * The first date and time when Microsoft Defender Threat Intelligence observed the subdomain. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
}
export interface SubdomainCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Subdomain[];
}
export interface SubmissionAdminReview extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Specifies who reviewed the email. The identification is an email ID or other identity strings.
     */
    reviewBy?: string;
    /**
     * Specifies the date time when the review occurred.
     */
    reviewDateTime?: Date;
    /**
     * Specifies what the review result was. The possible values are: notJunk, spam, phishing, malware, allowedByPolicy, blockedByPolicy, spoof, unknown, noResultAvailable, and unknownFutureValue.
     */
    reviewResult?: SubmissionResultCategory;
}
export type SubmissionCategory = (typeof SubmissionCategoryObject)[keyof typeof SubmissionCategoryObject];
export type SubmissionClientSource = (typeof SubmissionClientSourceObject)[keyof typeof SubmissionClientSourceObject];
export type SubmissionContentType = (typeof SubmissionContentTypeObject)[keyof typeof SubmissionContentTypeObject];
export interface SubmissionDetectedFile extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The file hash.
     */
    fileHash?: string;
    /**
     * The file name.
     */
    fileName?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface SubmissionMailEvidence extends AlertEvidence, Parsable {
    /**
     * The networkMessageId property
     */
    networkMessageId?: string;
    /**
     * The recipient property
     */
    recipient?: string;
    /**
     * The reportType property
     */
    reportType?: string;
    /**
     * The sender property
     */
    sender?: string;
    /**
     * The senderIp property
     */
    senderIp?: string;
    /**
     * The subject property
     */
    subject?: string;
    /**
     * The submissionDateTime property
     */
    submissionDateTime?: Date;
    /**
     * The submissionId property
     */
    submissionId?: string;
    /**
     * The submitter property
     */
    submitter?: string;
}
export interface SubmissionResult extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The submission result category. The possible values are: notJunk, spam, phishing, malware, allowedByPolicy, blockedByPolicy, spoof, unknown, noResultAvailable and unkownFutureValue.
     */
    category?: SubmissionResultCategory;
    /**
     * Specifies the extra details provided by Microsoft to substantiate their analysis result.
     */
    detail?: SubmissionResultDetail;
    /**
     * Specifies the files detected by Microsoft in the submitted emails.
     */
    detectedFiles?: SubmissionDetectedFile[];
    /**
     * Specifies the URLs detected by Microsoft in the submitted email.
     */
    detectedUrls?: string[];
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Specifies the setting for user mailbox denoted by a comma-separated string.
     */
    userMailboxSetting?: UserMailboxSetting[];
}
export type SubmissionResultCategory = (typeof SubmissionResultCategoryObject)[keyof typeof SubmissionResultCategoryObject];
export type SubmissionResultDetail = (typeof SubmissionResultDetailObject)[keyof typeof SubmissionResultDetailObject];
export type SubmissionSource = (typeof SubmissionSourceObject)[keyof typeof SubmissionSourceObject];
export interface SubmissionUserIdentity extends Identity, Parsable {
    /**
     * The email of user who is making the submission when logged in (delegated token case).
     */
    email?: string;
}
export interface Tag extends Entity, Parsable {
    /**
     * The createdBy property
     */
    createdBy?: IdentitySet;
    /**
     * The description property
     */
    description?: string;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The lastModifiedDateTime property
     */
    lastModifiedDateTime?: Date;
}
export type TenantAllowBlockListAction = (typeof TenantAllowBlockListActionObject)[keyof typeof TenantAllowBlockListActionObject];
export interface TenantAllowBlockListEntryResult extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The tenant allow-block list entry type. The possible values are: url, fileHash, sender, recipient and unkownFutureValue.
     */
    entryType?: TenantAllowBlockListEntryType;
    /**
     * Specifies the date and time when the entry expires.
     */
    expirationDateTime?: Date;
    /**
     * Specifies the identity of the entry generated by the tenant allow block list system.
     */
    identity?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Specifies whether the tenant allow block list entry creation operation was successful. The possible values are: notStarted, running, succeeded, failed, skipped and unkownFutureValue.
     */
    status?: LongRunningOperationStatus;
    /**
     * Specifies the value of the created tenant allow block list entry.
     */
    value?: string;
}
export type TenantAllowBlockListEntryType = (typeof TenantAllowBlockListEntryTypeObject)[keyof typeof TenantAllowBlockListEntryTypeObject];
export interface TenantAllowOrBlockListAction extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Specifies whether the tenant allow-or-block list is an allow or block. The possible values are: allow, block, and unkownFutureValue.
     */
    action?: TenantAllowBlockListAction;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Specifies when the tenant allow-block-list expires in date time.
     */
    expirationDateTime?: Date;
    /**
     * Specifies the note added to the tenant allow-or-block list entry in the format of string.
     */
    note?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Contains the result of the submission that lead to the tenant allow-block-list entry creation.
     */
    results?: TenantAllowBlockListEntryResult[];
}
export interface ThreatIntelligence extends Entity, Parsable {
    /**
     * Refers to indicators of threat or compromise highlighted in an article.Note: List retrieval is not yet supported.
     */
    articleIndicators?: ArticleIndicator[];
    /**
     * A list of article objects.
     */
    articles?: Article[];
    /**
     * Retrieve details about hostComponent objects.Note: List retrieval is not yet supported.
     */
    hostComponents?: HostComponent[];
    /**
     * Retrieve details about hostCookie objects.Note: List retrieval is not yet supported.
     */
    hostCookies?: HostCookie[];
    /**
     * Retrieve details about hostTracker objects.Note: List retrieval is not yet supported.
     */
    hostPairs?: HostPair[];
    /**
     * Retrieve details about hostPort objects.Note: List retrieval is not yet supported.
     */
    hostPorts?: HostPort[];
    /**
     * Refers to host objects that Microsoft Threat Intelligence has observed.Note: List retrieval is not yet supported.
     */
    hosts?: Host[];
    /**
     * Retrieve details about hostSslCertificate objects.Note: List retrieval is not yet supported.
     */
    hostSslCertificates?: HostSslCertificate[];
    /**
     * Retrieve details about hostTracker objects.Note: List retrieval is not yet supported.
     */
    hostTrackers?: HostTracker[];
    /**
     * The intelligenceProfileIndicators property
     */
    intelligenceProfileIndicators?: IntelligenceProfileIndicator[];
    /**
     * A list of intelligenceProfile objects.
     */
    intelProfiles?: IntelligenceProfile[];
    /**
     * Retrieve details about passiveDnsRecord objects.Note: List retrieval is not yet supported.
     */
    passiveDnsRecords?: PassiveDnsRecord[];
    /**
     * Retrieve details about sslCertificate objects.Note: List retrieval is not yet supported.
     */
    sslCertificates?: SslCertificate[];
    /**
     * Retrieve details about the subdomain.Note: List retrieval is not yet supported.
     */
    subdomains?: Subdomain[];
    /**
     * Retrieve details about vulnerabilities.Note: List retrieval is not yet supported.
     */
    vulnerabilities?: Vulnerability[];
    /**
     * Retrieve details about whoisHistoryRecord objects.Note: List retrieval is not yet supported.
     */
    whoisHistoryRecords?: WhoisHistoryRecord[];
    /**
     * A list of whoisRecord objects.
     */
    whoisRecords?: WhoisRecord[];
}
export interface ThreatSubmission extends Entity, Parsable {
    /**
     * Specifies the admin review property that constitutes of who reviewed the user submission, when and what was it identified as.
     */
    adminReview?: SubmissionAdminReview;
    /**
     * The category property
     */
    category?: SubmissionCategory;
    /**
     * Specifies the source of the submission. The possible values are: microsoft, other, and unkownFutureValue.
     */
    clientSource?: SubmissionClientSource;
    /**
     * Specifies the type of content being submitted. The possible values are: email, url, file, app, and unkownFutureValue.
     */
    contentType?: SubmissionContentType;
    /**
     * Specifies who submitted the email as a threat. Supports $filter = createdBy/email eq 'value'.
     */
    createdBy?: SubmissionUserIdentity;
    /**
     * Specifies when the threat submission was created. Supports $filter = createdDateTime ge 2022-01-01T00:00:00Z and createdDateTime lt 2022-01-02T00:00:00Z.
     */
    createdDateTime?: Date;
    /**
     * Specifies the result of the analysis performed by Microsoft.
     */
    result?: SubmissionResult;
    /**
     * Specifies the role of the submitter. Supports $filter = source eq 'value'. The possible values are: administrator,  user, and unkownFutureValue.
     */
    source?: SubmissionSource;
    /**
     * Indicates whether the threat submission has been analyzed by Microsoft. Supports $filter = status eq 'value'. The possible values are: notStarted, running, succeeded, failed, skipped, and unkownFutureValue.
     */
    status?: LongRunningOperationStatus;
    /**
     * Indicates the tenant id of the submitter. Not required when created using a POST operation. It's extracted from the token of the post API call.
     */
    tenantId?: string;
}
export interface ThreatSubmissionRoot extends Entity, Parsable {
    /**
     * The emailThreats property
     */
    emailThreats?: EmailThreatSubmission[];
    /**
     * The emailThreatSubmissionPolicies property
     */
    emailThreatSubmissionPolicies?: EmailThreatSubmissionPolicy[];
    /**
     * The fileThreats property
     */
    fileThreats?: FileThreatSubmission[];
    /**
     * The urlThreats property
     */
    urlThreats?: UrlThreatSubmission[];
}
export type ThreatType = (typeof ThreatTypeObject)[keyof typeof ThreatTypeObject];
export interface TopicModelingSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Indicates whether the themes model should dynamically optimize the number of generated topics. To learn more, see Adjust maximum number of themes dynamically.
     */
    dynamicallyAdjustTopicCount?: boolean;
    /**
     * Indicates whether the themes model should exclude numbers while parsing document texts. To learn more, see Include numbers in themes.
     */
    ignoreNumbers?: boolean;
    /**
     * Indicates whether themes model is enabled for the case.
     */
    isEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The total number of topics that the themes model will generate for a review set. To learn more, see Maximum number of themes.
     */
    topicCount?: number;
}
export interface TriggersRoot extends Entity, Parsable {
    /**
     * The retentionEvents property
     */
    retentionEvents?: RetentionEvent[];
}
export interface TriggerTypesRoot extends Entity, Parsable {
    /**
     * The retentionEventTypes property
     */
    retentionEventTypes?: RetentionEventType[];
}
export interface UnclassifiedArtifact extends Artifact, Parsable {
    /**
     * The kind for this unclassifiedArtifact resource, describing what this value means.
     */
    kind?: string;
    /**
     * The value for this unclassifiedArtifact.
     */
    value?: string;
}
export interface UnifiedGroupSource extends DataSource, Parsable {
    /**
     * The group property
     */
    group?: Group;
    /**
     * Specifies which sources are included in this group. Possible values are: mailbox, site.
     */
    includedSources?: SourceType[];
}
export interface UnifiedGroupSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UnifiedGroupSource[];
}
export interface UrlEvidence extends AlertEvidence, Parsable {
    /**
     * The Unique Resource Locator (URL).
     */
    url?: string;
}
export interface UrlThreatSubmission extends Parsable, ThreatSubmission {
    /**
     * Denotes the webUrl that needs to be submitted.
     */
    webUrl?: string;
}
export interface UrlThreatSubmissionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UrlThreatSubmission[];
}
export interface UserAccount extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The displayed name of the user account.
     */
    accountName?: string;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The user object identifier in Microsoft Entra ID.
     */
    azureAdUserId?: string;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The user display name in Microsoft Entra ID.
     */
    displayName?: string;
    /**
     * The name of the Active Directory domain of which the user is a member.
     */
    domainName?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The user principal name of the account in Microsoft Entra ID.
     */
    userPrincipalName?: string;
    /**
     * The local security identifier of the user account.
     */
    userSid?: string;
}
export type UserAssetIdentifier = (typeof UserAssetIdentifierObject)[keyof typeof UserAssetIdentifierObject];
export interface UserEvidence extends AlertEvidence, Parsable {
    /**
     * The stream property
     */
    stream?: Stream;
    /**
     * The user account details.
     */
    userAccount?: UserAccount;
}
export type UserMailboxSetting = (typeof UserMailboxSettingObject)[keyof typeof UserMailboxSettingObject];
export interface UserSource extends DataSource, Parsable {
    /**
     * Email address of the user's mailbox.
     */
    email?: string;
    /**
     * Specifies which sources are included in this group. Possible values are: mailbox, site.
     */
    includedSources?: SourceType[];
    /**
     * The URL of the user's OneDrive for Business site. Read-only.
     */
    siteWebUrl?: string;
}
export interface UserSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UserSource[];
}
export type VmCloudProvider = (typeof VmCloudProviderObject)[keyof typeof VmCloudProviderObject];
export interface VmMetadata extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The cloudProvider property
     */
    cloudProvider?: VmCloudProvider;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Unique identifier of the Azure resource.
     */
    resourceId?: string;
    /**
     * Unique identifier of the Azure subscription the customer tenant belongs to.
     */
    subscriptionId?: string;
    /**
     * Unique identifier of the virtual machine instance.
     */
    vmId?: string;
}
export interface Vulnerability extends Entity, Parsable {
    /**
     * Indicates whether this vulnerability has any known exploits associated to known bad actors.
     */
    activeExploitsObserved?: boolean;
    /**
     * Articles related to this vulnerability.
     */
    articles?: Article[];
    /**
     * Community-defined common weakness enumerations (CWE).
     */
    commonWeaknessEnumerationIds?: string[];
    /**
     * Components related to this vulnerability article.
     */
    components?: VulnerabilityComponent[];
    /**
     * The date and time when this vulnerability article was first created.
     */
    createdDateTime?: Date;
    /**
     * The cvss2Summary property
     */
    cvss2Summary?: CvssSummary;
    /**
     * The cvss3Summary property
     */
    cvss3Summary?: CvssSummary;
    /**
     * The description property
     */
    description?: FormattedContent;
    /**
     * Known exploits for this vulnerability.
     */
    exploits?: Hyperlink[];
    /**
     * Indicates whether this vulnerability has exploits in public sources (such as Packetstorm or Exploit-DB) online.
     */
    exploitsAvailable?: boolean;
    /**
     * Indicates whether chatter about this vulnerability has been discovered online.
     */
    hasChatter?: boolean;
    /**
     * The date and time when this vulnerability article was most recently updated.
     */
    lastModifiedDateTime?: Date;
    /**
     * A unique algorithm that reflects the priority of a vulnerability based on the CVSS score, exploits, chatter, and linkage to malware. This property also evaluates the recency of these components so users can understand which vulnerability should be remediated first.
     */
    priorityScore?: number;
    /**
     * The date and time when this vulnerability article was published.
     */
    publishedDateTime?: Date;
    /**
     * Reference links where further information can be learned about this vulnerability.
     */
    references?: Hyperlink[];
    /**
     * Any known remediation steps.
     */
    remediation?: FormattedContent;
    /**
     * The severity property
     */
    severity?: VulnerabilitySeverity;
}
export interface VulnerabilityCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Vulnerability[];
}
export interface VulnerabilityComponent extends Entity, Parsable {
    /**
     * The name of this vulnerability component.
     */
    name?: string;
}
export interface VulnerabilityComponentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: VulnerabilityComponent[];
}
export type VulnerabilitySeverity = (typeof VulnerabilitySeverityObject)[keyof typeof VulnerabilitySeverityObject];
export type WatermarkLayout = (typeof WatermarkLayoutObject)[keyof typeof WatermarkLayoutObject];
export interface WhoisBaseRecord extends Entity, Parsable {
    /**
     * The contact information for the abuse contact.
     */
    abuse?: WhoisContact;
    /**
     * The contact information for the admin contact.
     */
    admin?: WhoisContact;
    /**
     * The contact information for the billing contact.
     */
    billing?: WhoisContact;
    /**
     * The domain status for this WHOIS object.
     */
    domainStatus?: string;
    /**
     * The date and time when this WHOIS record expires with the registrar. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    expirationDateTime?: Date;
    /**
     * The first seen date and time of this WHOIS record. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The last seen date and time of this WHOIS record. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The date and time when this WHOIS record was last modified. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastUpdateDateTime?: Date;
    /**
     * The nameservers for this WHOIS object.
     */
    nameservers?: WhoisNameserver[];
    /**
     * The contact information for the noc contact.
     */
    noc?: WhoisContact;
    /**
     * The raw WHOIS details for this WHOIS object.
     */
    rawWhoisText?: string;
    /**
     * The contact information for the registrant contact.
     */
    registrant?: WhoisContact;
    /**
     * The contact information for the registrar contact.
     */
    registrar?: WhoisContact;
    /**
     * The date and time when this WHOIS record was registered with a registrar. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    registrationDateTime?: Date;
    /**
     * The contact information for the technical contact.
     */
    technical?: WhoisContact;
    /**
     * The WHOIS server that provides the details.
     */
    whoisServer?: string;
    /**
     * The contact information for the zone contact.
     */
    zone?: WhoisContact;
}
export interface WhoisContact extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The physical address of the entity.
     */
    address?: PhysicalAddress;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The email of this WHOIS contact.
     */
    email?: string;
    /**
     * The fax of this WHOIS contact. No format is guaranteed.
     */
    fax?: string;
    /**
     * The name of this WHOIS contact.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The organization of this WHOIS contact.
     */
    organization?: string;
    /**
     * The telephone of this WHOIS contact. No format is guaranteed.
     */
    telephone?: string;
}
export interface WhoisHistoryRecord extends Parsable, WhoisBaseRecord {
}
export interface WhoisHistoryRecordCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: WhoisHistoryRecord[];
}
export interface WhoisNameserver extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The first seen date and time of this WHOIS contact. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The last seen date and time of this WHOIS contact. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface WhoisRecord extends Parsable, WhoisBaseRecord {
    /**
     * The collection of historical records associated to this WHOIS object.
     */
    history?: WhoisHistoryRecord[];
}
export interface WhoisRecordCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: WhoisRecord[];
}
export const ActionAfterRetentionPeriodObject = {
    None: "none",
    Delete: "delete",
    StartDispositionReview: "startDispositionReview",
    Relabel: "relabel",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ActionSourceObject = {
    Manual: "manual",
    Automatic: "automatic",
    Recommended: "recommended",
    DefaultEscaped: "default",
} as const;
export const AdditionalDataOptionsObject = {
    AllVersions: "allVersions",
    LinkedFiles: "linkedFiles",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AdditionalOptionsObject = {
    None: "none",
    TeamsAndYammerConversations: "teamsAndYammerConversations",
    CloudAttachments: "cloudAttachments",
    AllDocumentVersions: "allDocumentVersions",
    SubfolderContents: "subfolderContents",
    ListAttachments: "listAttachments",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AlertClassificationObject = {
    Unknown: "unknown",
    FalsePositive: "falsePositive",
    TruePositive: "truePositive",
    InformationalExpectedActivity: "informationalExpectedActivity",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AlertDeterminationObject = {
    Unknown: "unknown",
    Apt: "apt",
    Malware: "malware",
    SecurityPersonnel: "securityPersonnel",
    SecurityTesting: "securityTesting",
    UnwantedSoftware: "unwantedSoftware",
    Other: "other",
    MultiStagedAttack: "multiStagedAttack",
    CompromisedAccount: "compromisedAccount",
    Phishing: "phishing",
    MaliciousUserActivity: "maliciousUserActivity",
    NotMalicious: "notMalicious",
    NotEnoughDataToValidate: "notEnoughDataToValidate",
    ConfirmedActivity: "confirmedActivity",
    LineOfBusinessApplication: "lineOfBusinessApplication",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AlertSeverityObject = {
    Unknown: "unknown",
    Informational: "informational",
    Low: "low",
    Medium: "medium",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AlertStatusObject = {
    Unknown: "unknown",
    NewEscaped: "new",
    InProgress: "inProgress",
    Resolved: "resolved",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AntispamDirectionalityObject = {
    Unknown: "unknown",
    Inbound: "inbound",
    Outbound: "outbound",
    IntraOrg: "intraOrg",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AssignmentMethodObject = {
    Standard: "standard",
    Privileged: "privileged",
    Auto: "auto",
} as const;
export const AuditLogQueryStatusObject = {
    NotStarted: "notStarted",
    Running: "running",
    Succeeded: "succeeded",
    Failed: "failed",
    Cancelled: "cancelled",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AuditLogRecordTypeObject = {
    ExchangeAdmin: "ExchangeAdmin",
    ExchangeItem: "ExchangeItem",
    ExchangeItemGroup: "ExchangeItemGroup",
    SharePoint: "SharePoint",
    SyntheticProbe: "SyntheticProbe",
    SharePointFileOperation: "SharePointFileOperation",
    OneDrive: "OneDrive",
    AzureActiveDirectory: "AzureActiveDirectory",
    AzureActiveDirectoryAccountLogon: "AzureActiveDirectoryAccountLogon",
    DataCenterSecurityCmdlet: "DataCenterSecurityCmdlet",
    ComplianceDLPSharePoint: "ComplianceDLPSharePoint",
    Sway: "Sway",
    ComplianceDLPExchange: "ComplianceDLPExchange",
    SharePointSharingOperation: "SharePointSharingOperation",
    AzureActiveDirectoryStsLogon: "AzureActiveDirectoryStsLogon",
    SkypeForBusinessPSTNUsage: "SkypeForBusinessPSTNUsage",
    SkypeForBusinessUsersBlocked: "SkypeForBusinessUsersBlocked",
    SecurityComplianceCenterEOPCmdlet: "SecurityComplianceCenterEOPCmdlet",
    ExchangeAggregatedOperation: "ExchangeAggregatedOperation",
    PowerBIAudit: "PowerBIAudit",
    CRM: "CRM",
    Yammer: "Yammer",
    SkypeForBusinessCmdlets: "SkypeForBusinessCmdlets",
    Discovery: "Discovery",
    MicrosoftTeams: "MicrosoftTeams",
    ThreatIntelligence: "ThreatIntelligence",
    MailSubmission: "MailSubmission",
    MicrosoftFlow: "MicrosoftFlow",
    AeD: "AeD",
    MicrosoftStream: "MicrosoftStream",
    ComplianceDLPSharePointClassification: "ComplianceDLPSharePointClassification",
    ThreatFinder: "ThreatFinder",
    Project: "Project",
    SharePointListOperation: "SharePointListOperation",
    SharePointCommentOperation: "SharePointCommentOperation",
    DataGovernance: "DataGovernance",
    Kaizala: "Kaizala",
    SecurityComplianceAlerts: "SecurityComplianceAlerts",
    ThreatIntelligenceUrl: "ThreatIntelligenceUrl",
    SecurityComplianceInsights: "SecurityComplianceInsights",
    MIPLabel: "MIPLabel",
    WorkplaceAnalytics: "WorkplaceAnalytics",
    PowerAppsApp: "PowerAppsApp",
    PowerAppsPlan: "PowerAppsPlan",
    ThreatIntelligenceAtpContent: "ThreatIntelligenceAtpContent",
    LabelContentExplorer: "LabelContentExplorer",
    TeamsHealthcare: "TeamsHealthcare",
    ExchangeItemAggregated: "ExchangeItemAggregated",
    HygieneEvent: "HygieneEvent",
    DataInsightsRestApiAudit: "DataInsightsRestApiAudit",
    InformationBarrierPolicyApplication: "InformationBarrierPolicyApplication",
    SharePointListItemOperation: "SharePointListItemOperation",
    SharePointContentTypeOperation: "SharePointContentTypeOperation",
    SharePointFieldOperation: "SharePointFieldOperation",
    MicrosoftTeamsAdmin: "MicrosoftTeamsAdmin",
    HRSignal: "HRSignal",
    MicrosoftTeamsDevice: "MicrosoftTeamsDevice",
    MicrosoftTeamsAnalytics: "MicrosoftTeamsAnalytics",
    InformationWorkerProtection: "InformationWorkerProtection",
    Campaign: "Campaign",
    DLPEndpoint: "DLPEndpoint",
    AirInvestigation: "AirInvestigation",
    Quarantine: "Quarantine",
    MicrosoftForms: "MicrosoftForms",
    ApplicationAudit: "ApplicationAudit",
    ComplianceSupervisionExchange: "ComplianceSupervisionExchange",
    CustomerKeyServiceEncryption: "CustomerKeyServiceEncryption",
    OfficeNative: "OfficeNative",
    MipAutoLabelSharePointItem: "MipAutoLabelSharePointItem",
    MipAutoLabelSharePointPolicyLocation: "MipAutoLabelSharePointPolicyLocation",
    MicrosoftTeamsShifts: "MicrosoftTeamsShifts",
    SecureScore: "SecureScore",
    MipAutoLabelExchangeItem: "MipAutoLabelExchangeItem",
    CortanaBriefing: "CortanaBriefing",
    Search: "Search",
    WDATPAlerts: "WDATPAlerts",
    PowerPlatformAdminDlp: "PowerPlatformAdminDlp",
    PowerPlatformAdminEnvironment: "PowerPlatformAdminEnvironment",
    MDATPAudit: "MDATPAudit",
    SensitivityLabelPolicyMatch: "SensitivityLabelPolicyMatch",
    SensitivityLabelAction: "SensitivityLabelAction",
    SensitivityLabeledFileAction: "SensitivityLabeledFileAction",
    AttackSim: "AttackSim",
    AirManualInvestigation: "AirManualInvestigation",
    SecurityComplianceRBAC: "SecurityComplianceRBAC",
    UserTraining: "UserTraining",
    AirAdminActionInvestigation: "AirAdminActionInvestigation",
    MSTIC: "MSTIC",
    PhysicalBadgingSignal: "PhysicalBadgingSignal",
    TeamsEasyApprovals: "TeamsEasyApprovals",
    AipDiscover: "AipDiscover",
    AipSensitivityLabelAction: "AipSensitivityLabelAction",
    AipProtectionAction: "AipProtectionAction",
    AipFileDeleted: "AipFileDeleted",
    AipHeartBeat: "AipHeartBeat",
    MCASAlerts: "MCASAlerts",
    OnPremisesFileShareScannerDlp: "OnPremisesFileShareScannerDlp",
    OnPremisesSharePointScannerDlp: "OnPremisesSharePointScannerDlp",
    ExchangeSearch: "ExchangeSearch",
    SharePointSearch: "SharePointSearch",
    PrivacyDataMinimization: "PrivacyDataMinimization",
    LabelAnalyticsAggregate: "LabelAnalyticsAggregate",
    MyAnalyticsSettings: "MyAnalyticsSettings",
    SecurityComplianceUserChange: "SecurityComplianceUserChange",
    ComplianceDLPExchangeClassification: "ComplianceDLPExchangeClassification",
    ComplianceDLPEndpoint: "ComplianceDLPEndpoint",
    MipExactDataMatch: "MipExactDataMatch",
    MSDEResponseActions: "MSDEResponseActions",
    MSDEGeneralSettings: "MSDEGeneralSettings",
    MSDEIndicatorsSettings: "MSDEIndicatorsSettings",
    MS365DCustomDetection: "MS365DCustomDetection",
    MSDERolesSettings: "MSDERolesSettings",
    MAPGAlerts: "MAPGAlerts",
    MAPGPolicy: "MAPGPolicy",
    MAPGRemediation: "MAPGRemediation",
    PrivacyRemediationAction: "PrivacyRemediationAction",
    PrivacyDigestEmail: "PrivacyDigestEmail",
    MipAutoLabelSimulationProgress: "MipAutoLabelSimulationProgress",
    MipAutoLabelSimulationCompletion: "MipAutoLabelSimulationCompletion",
    MipAutoLabelProgressFeedback: "MipAutoLabelProgressFeedback",
    DlpSensitiveInformationType: "DlpSensitiveInformationType",
    MipAutoLabelSimulationStatistics: "MipAutoLabelSimulationStatistics",
    LargeContentMetadata: "LargeContentMetadata",
    Microsoft365Group: "Microsoft365Group",
    CDPMlInferencingResult: "CDPMlInferencingResult",
    FilteringMailMetadata: "FilteringMailMetadata",
    CDPClassificationMailItem: "CDPClassificationMailItem",
    CDPClassificationDocument: "CDPClassificationDocument",
    OfficeScriptsRunAction: "OfficeScriptsRunAction",
    FilteringPostMailDeliveryAction: "FilteringPostMailDeliveryAction",
    CDPUnifiedFeedback: "CDPUnifiedFeedback",
    TenantAllowBlockList: "TenantAllowBlockList",
    ConsumptionResource: "ConsumptionResource",
    HealthcareSignal: "HealthcareSignal",
    DlpImportResult: "DlpImportResult",
    CDPCompliancePolicyExecution: "CDPCompliancePolicyExecution",
    MultiStageDisposition: "MultiStageDisposition",
    PrivacyDataMatch: "PrivacyDataMatch",
    FilteringDocMetadata: "FilteringDocMetadata",
    FilteringEmailFeatures: "FilteringEmailFeatures",
    PowerBIDlp: "PowerBIDlp",
    FilteringUrlInfo: "FilteringUrlInfo",
    FilteringAttachmentInfo: "FilteringAttachmentInfo",
    CoreReportingSettings: "CoreReportingSettings",
    ComplianceConnector: "ComplianceConnector",
    PowerPlatformLockboxResourceAccessRequest: "PowerPlatformLockboxResourceAccessRequest",
    PowerPlatformLockboxResourceCommand: "PowerPlatformLockboxResourceCommand",
    CDPPredictiveCodingLabel: "CDPPredictiveCodingLabel",
    CDPCompliancePolicyUserFeedback: "CDPCompliancePolicyUserFeedback",
    WebpageActivityEndpoint: "WebpageActivityEndpoint",
    OMEPortal: "OMEPortal",
    CMImprovementActionChange: "CMImprovementActionChange",
    FilteringUrlClick: "FilteringUrlClick",
    MipLabelAnalyticsAuditRecord: "MipLabelAnalyticsAuditRecord",
    FilteringEntityEvent: "FilteringEntityEvent",
    FilteringRuleHits: "FilteringRuleHits",
    FilteringMailSubmission: "FilteringMailSubmission",
    LabelExplorer: "LabelExplorer",
    MicrosoftManagedServicePlatform: "MicrosoftManagedServicePlatform",
    PowerPlatformServiceActivity: "PowerPlatformServiceActivity",
    ScorePlatformGenericAuditRecord: "ScorePlatformGenericAuditRecord",
    FilteringTimeTravelDocMetadata: "FilteringTimeTravelDocMetadata",
    Alert: "Alert",
    AlertStatus: "AlertStatus",
    AlertIncident: "AlertIncident",
    IncidentStatus: "IncidentStatus",
    CaseEscaped: "Case",
    CaseInvestigation: "CaseInvestigation",
    RecordsManagement: "RecordsManagement",
    PrivacyRemediation: "PrivacyRemediation",
    DataShareOperation: "DataShareOperation",
    CdpDlpSensitive: "CdpDlpSensitive",
    EHRConnector: "EHRConnector",
    FilteringMailGradingResult: "FilteringMailGradingResult",
    PublicFolder: "PublicFolder",
    PrivacyTenantAuditHistoryRecord: "PrivacyTenantAuditHistoryRecord",
    AipScannerDiscoverEvent: "AipScannerDiscoverEvent",
    EduDataLakeDownloadOperation: "EduDataLakeDownloadOperation",
    M365ComplianceConnector: "M365ComplianceConnector",
    MicrosoftGraphDataConnectOperation: "MicrosoftGraphDataConnectOperation",
    MicrosoftPurview: "MicrosoftPurview",
    FilteringEmailContentFeatures: "FilteringEmailContentFeatures",
    PowerPagesSite: "PowerPagesSite",
    PowerAppsResource: "PowerAppsResource",
    PlannerPlan: "PlannerPlan",
    PlannerCopyPlan: "PlannerCopyPlan",
    PlannerTask: "PlannerTask",
    PlannerRoster: "PlannerRoster",
    PlannerPlanList: "PlannerPlanList",
    PlannerTaskList: "PlannerTaskList",
    PlannerTenantSettings: "PlannerTenantSettings",
    ProjectForTheWebProject: "ProjectForTheWebProject",
    ProjectForTheWebTask: "ProjectForTheWebTask",
    ProjectForTheWebRoadmap: "ProjectForTheWebRoadmap",
    ProjectForTheWebRoadmapItem: "ProjectForTheWebRoadmapItem",
    ProjectForTheWebProjectSettings: "ProjectForTheWebProjectSettings",
    ProjectForTheWebRoadmapSettings: "ProjectForTheWebRoadmapSettings",
    QuarantineMetadata: "QuarantineMetadata",
    MicrosoftTodoAudit: "MicrosoftTodoAudit",
    TimeTravelFilteringDocMetadata: "TimeTravelFilteringDocMetadata",
    TeamsQuarantineMetadata: "TeamsQuarantineMetadata",
    SharePointAppPermissionOperation: "SharePointAppPermissionOperation",
    MicrosoftTeamsSensitivityLabelAction: "MicrosoftTeamsSensitivityLabelAction",
    FilteringTeamsMetadata: "FilteringTeamsMetadata",
    FilteringTeamsUrlInfo: "FilteringTeamsUrlInfo",
    FilteringTeamsPostDeliveryAction: "FilteringTeamsPostDeliveryAction",
    MDCAssessments: "MDCAssessments",
    MDCRegulatoryComplianceStandards: "MDCRegulatoryComplianceStandards",
    MDCRegulatoryComplianceControls: "MDCRegulatoryComplianceControls",
    MDCRegulatoryComplianceAssessments: "MDCRegulatoryComplianceAssessments",
    MDCSecurityConnectors: "MDCSecurityConnectors",
    MDADataSecuritySignal: "MDADataSecuritySignal",
    VivaGoals: "VivaGoals",
    FilteringRuntimeInfo: "FilteringRuntimeInfo",
    AttackSimAdmin: "AttackSimAdmin",
    MicrosoftGraphDataConnectConsent: "MicrosoftGraphDataConnectConsent",
    FilteringAtpDetonationInfo: "FilteringAtpDetonationInfo",
    PrivacyPortal: "PrivacyPortal",
    ManagedTenants: "ManagedTenants",
    UnifiedSimulationMatchedItem: "UnifiedSimulationMatchedItem",
    UnifiedSimulationSummary: "UnifiedSimulationSummary",
    UpdateQuarantineMetadata: "UpdateQuarantineMetadata",
    MS365DSuppressionRule: "MS365DSuppressionRule",
    PurviewDataMapOperation: "PurviewDataMapOperation",
    FilteringUrlPostClickAction: "FilteringUrlPostClickAction",
    IrmUserDefinedDetectionSignal: "IrmUserDefinedDetectionSignal",
    TeamsUpdates: "TeamsUpdates",
    PlannerRosterSensitivityLabel: "PlannerRosterSensitivityLabel",
    MS365DIncident: "MS365DIncident",
    FilteringDelistingMetadata: "FilteringDelistingMetadata",
    ComplianceDLPSharePointClassificationExtended: "ComplianceDLPSharePointClassificationExtended",
    MicrosoftDefenderForIdentityAudit: "MicrosoftDefenderForIdentityAudit",
    SupervisoryReviewDayXInsight: "SupervisoryReviewDayXInsight",
    DefenderExpertsforXDRAdmin: "DefenderExpertsforXDRAdmin",
    CDPEdgeBlockedMessage: "CDPEdgeBlockedMessage",
    HostedRpa: "HostedRpa",
    CdpContentExplorerAggregateRecord: "CdpContentExplorerAggregateRecord",
    CDPHygieneAttachmentInfo: "CDPHygieneAttachmentInfo",
    CDPHygieneSummary: "CDPHygieneSummary",
    CDPPostMailDeliveryAction: "CDPPostMailDeliveryAction",
    CDPEmailFeatures: "CDPEmailFeatures",
    CDPHygieneUrlInfo: "CDPHygieneUrlInfo",
    CDPUrlClick: "CDPUrlClick",
    CDPPackageManagerHygieneEvent: "CDPPackageManagerHygieneEvent",
    FilteringDocScan: "FilteringDocScan",
    TimeTravelFilteringDocScan: "TimeTravelFilteringDocScan",
    MAPGOnboard: "MAPGOnboard",
    VfamCreatePolicy: "VfamCreatePolicy",
    VfamUpdatePolicy: "VfamUpdatePolicy",
    VfamDeletePolicy: "VfamDeletePolicy",
    M365DAAD: "M365DAAD",
    CdpColdCrawlStatus: "CdpColdCrawlStatus",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AuditLogUserTypeObject = {
    Regular: "Regular",
    Reserved: "Reserved",
    Admin: "Admin",
    DcAdmin: "DcAdmin",
    System: "System",
    Application: "Application",
    ServicePrincipal: "ServicePrincipal",
    CustomPolicy: "CustomPolicy",
    SystemPolicy: "SystemPolicy",
    PartnerTechnician: "PartnerTechnician",
    Guest: "Guest",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const BehaviorDuringRetentionPeriodObject = {
    DoNotRetain: "doNotRetain",
    Retain: "retain",
    RetainAsRecord: "retainAsRecord",
    RetainAsRegulatoryRecord: "retainAsRegulatoryRecord",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const CaseActionObject = {
    ContentExport: "contentExport",
    ApplyTags: "applyTags",
    ConvertToPdf: "convertToPdf",
    Index: "index",
    EstimateStatistics: "estimateStatistics",
    AddToReviewSet: "addToReviewSet",
    HoldUpdate: "holdUpdate",
    UnknownFutureValue: "unknownFutureValue",
    PurgeData: "purgeData",
    ExportReport: "exportReport",
    ExportResult: "exportResult",
} as const;
export const CaseOperationStatusObject = {
    NotStarted: "notStarted",
    SubmissionFailed: "submissionFailed",
    Running: "running",
    Succeeded: "succeeded",
    PartiallySucceeded: "partiallySucceeded",
    Failed: "failed",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const CaseStatusObject = {
    Unknown: "unknown",
    Active: "active",
    PendingDelete: "pendingDelete",
    Closing: "closing",
    Closed: "closed",
    ClosedWithError: "closedWithError",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ChildSelectabilityObject = {
    One: "One",
    Many: "Many",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ContainerPortProtocolObject = {
    Udp: "udp",
    Tcp: "tcp",
    Sctp: "sctp",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ContentAlignmentObject = {
    Left: "left",
    Right: "right",
    Center: "center",
} as const;
export const ContentFormatObject = {
    Text: "text",
    Html: "html",
    Markdown: "markdown",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ContentStateObject = {
    Rest: "rest",
    Motion: "motion",
    Use: "use",
} as const;
export const DataSourceContainerStatusObject = {
    Active: "active",
    Released: "released",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DataSourceHoldStatusObject = {
    NotApplied: "notApplied",
    Applied: "applied",
    Applying: "applying",
    Removing: "removing",
    Partial: "partial",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DataSourceScopesObject = {
    None: "none",
    AllTenantMailboxes: "allTenantMailboxes",
    AllTenantSites: "allTenantSites",
    AllCaseCustodians: "allCaseCustodians",
    AllCaseNoncustodialDataSources: "allCaseNoncustodialDataSources",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DefaultRecordBehaviorObject = {
    StartLocked: "startLocked",
    StartUnlocked: "startUnlocked",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DefenderAvStatusObject = {
    NotReporting: "notReporting",
    Disabled: "disabled",
    NotUpdated: "notUpdated",
    Updated: "updated",
    Unknown: "unknown",
    NotSupported: "notSupported",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeliveryActionObject = {
    Unknown: "unknown",
    DeliveredToJunk: "deliveredToJunk",
    Delivered: "delivered",
    Blocked: "blocked",
    Replaced: "replaced",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeliveryLocationObject = {
    Unknown: "unknown",
    Inbox_folder: "inbox_folder",
    JunkFolder: "junkFolder",
    DeletedFolder: "deletedFolder",
    Quarantine: "quarantine",
    Onprem_external: "onprem_external",
    Failed: "failed",
    Dropped: "dropped",
    Others: "others",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeploymentStatusObject = {
    UpToDate: "upToDate",
    Outdated: "outdated",
    Updating: "updating",
    UpdateFailed: "updateFailed",
    NotConfigured: "notConfigured",
    Unreachable: "unreachable",
    Disconnected: "disconnected",
    StartFailure: "startFailure",
    Syncing: "syncing",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DetectionSourceObject = {
    Unknown: "unknown",
    MicrosoftDefenderForEndpoint: "microsoftDefenderForEndpoint",
    Antivirus: "antivirus",
    SmartScreen: "smartScreen",
    CustomTi: "customTi",
    MicrosoftDefenderForOffice365: "microsoftDefenderForOffice365",
    AutomatedInvestigation: "automatedInvestigation",
    MicrosoftThreatExperts: "microsoftThreatExperts",
    CustomDetection: "customDetection",
    MicrosoftDefenderForIdentity: "microsoftDefenderForIdentity",
    CloudAppSecurity: "cloudAppSecurity",
    Microsoft365Defender: "microsoft365Defender",
    AzureAdIdentityProtection: "azureAdIdentityProtection",
    Manual: "manual",
    MicrosoftDataLossPrevention: "microsoftDataLossPrevention",
    AppGovernancePolicy: "appGovernancePolicy",
    AppGovernanceDetection: "appGovernanceDetection",
    UnknownFutureValue: "unknownFutureValue",
    MicrosoftDefenderForCloud: "microsoftDefenderForCloud",
    MicrosoftDefenderForIoT: "microsoftDefenderForIoT",
    MicrosoftDefenderForServers: "microsoftDefenderForServers",
    MicrosoftDefenderForStorage: "microsoftDefenderForStorage",
    MicrosoftDefenderForDNS: "microsoftDefenderForDNS",
    MicrosoftDefenderForDatabases: "microsoftDefenderForDatabases",
    MicrosoftDefenderForContainers: "microsoftDefenderForContainers",
    MicrosoftDefenderForNetwork: "microsoftDefenderForNetwork",
    MicrosoftDefenderForAppService: "microsoftDefenderForAppService",
    MicrosoftDefenderForKeyVault: "microsoftDefenderForKeyVault",
    MicrosoftDefenderForResourceManager: "microsoftDefenderForResourceManager",
    MicrosoftDefenderForApiManagement: "microsoftDefenderForApiManagement",
    NrtAlerts: "nrtAlerts",
    ScheduledAlerts: "scheduledAlerts",
    MicrosoftDefenderThreatIntelligenceAnalytics: "microsoftDefenderThreatIntelligenceAnalytics",
    BuiltInMl: "builtInMl",
    MicrosoftInsiderRiskManagement: "microsoftInsiderRiskManagement",
    MicrosoftSentinel: "microsoftSentinel",
} as const;
export const DetectionStatusObject = {
    Detected: "detected",
    Blocked: "blocked",
    Prevented: "prevented",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeviceAssetIdentifierObject = {
    DeviceId: "deviceId",
    DeviceName: "deviceName",
    RemoteDeviceName: "remoteDeviceName",
    TargetDeviceName: "targetDeviceName",
    DestinationDeviceName: "destinationDeviceName",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeviceHealthStatusObject = {
    Active: "active",
    Inactive: "inactive",
    ImpairedCommunication: "impairedCommunication",
    NoSensorData: "noSensorData",
    NoSensorDataImpairedCommunication: "noSensorDataImpairedCommunication",
    Unknown: "unknown",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeviceIdEntityIdentifierObject = {
    DeviceId: "deviceId",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeviceRiskScoreObject = {
    None: "none",
    Informational: "informational",
    Low: "low",
    Medium: "medium",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DisableUserEntityIdentifierObject = {
    AccountSid: "accountSid",
    InitiatingProcessAccountSid: "initiatingProcessAccountSid",
    RequestAccountSid: "requestAccountSid",
    OnPremSid: "onPremSid",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EmailEntityIdentifierObject = {
    NetworkMessageId: "networkMessageId",
    RecipientEmailAddress: "recipientEmailAddress",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EventPropagationStatusObject = {
    None: "none",
    InProcessing: "inProcessing",
    Failed: "failed",
    Success: "success",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EventStatusTypeObject = {
    Pending: "pending",
    ErrorEscaped: "error",
    Success: "success",
    NotAvaliable: "notAvaliable",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EvidenceRemediationStatusObject = {
    None: "none",
    Remediated: "remediated",
    Prevented: "prevented",
    Blocked: "blocked",
    NotFound: "notFound",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EvidenceRoleObject = {
    Unknown: "unknown",
    Contextual: "contextual",
    Scanned: "scanned",
    Source: "source",
    Destination: "destination",
    Created: "created",
    Added: "added",
    Compromised: "compromised",
    Edited: "edited",
    Attacked: "attacked",
    Attacker: "attacker",
    CommandAndControl: "commandAndControl",
    Loaded: "loaded",
    Suspicious: "suspicious",
    PolicyViolator: "policyViolator",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EvidenceVerdictObject = {
    Unknown: "unknown",
    Suspicious: "suspicious",
    Malicious: "malicious",
    NoThreatsFound: "noThreatsFound",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ExportCriteriaObject = {
    SearchHits: "searchHits",
    PartiallyIndexed: "partiallyIndexed",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ExportFileStructureObject = {
    None: "none",
    Directory: "directory",
    Pst: "pst",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ExportFormatObject = {
    Pst: "pst",
    Msg: "msg",
    Eml: "eml",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ExportLocationObject = {
    ResponsiveLocations: "responsiveLocations",
    NonresponsiveLocations: "nonresponsiveLocations",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ExportOptionsObject = {
    OriginalFiles: "originalFiles",
    Text: "text",
    PdfReplacement: "pdfReplacement",
    FileInfo: "fileInfo",
    Tags: "tags",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const FileEntityIdentifierObject = {
    Sha1: "sha1",
    InitiatingProcessSHA1: "initiatingProcessSHA1",
    Sha256: "sha256",
    InitiatingProcessSHA256: "initiatingProcessSHA256",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const FileHashAlgorithmObject = {
    Unknown: "unknown",
    Md5: "md5",
    Sha1: "sha1",
    Sha256: "sha256",
    Sha256ac: "sha256ac",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const FileProcessingStatusObject = {
    Success: "success",
    InternalError: "internalError",
    UnknownError: "unknownError",
    ProcessingTimeout: "processingTimeout",
    InvalidFileId: "invalidFileId",
    FileSizeIsZero: "fileSizeIsZero",
    FileSizeIsTooLarge: "fileSizeIsTooLarge",
    FileDepthLimitExceeded: "fileDepthLimitExceeded",
    FileBodyIsTooLong: "fileBodyIsTooLong",
    FileTypeIsUnknown: "fileTypeIsUnknown",
    FileTypeIsNotSupported: "fileTypeIsNotSupported",
    MalformedFile: "malformedFile",
    ProtectedFile: "protectedFile",
    PoisonFile: "poisonFile",
    NoReviewSetSummaryGenerated: "noReviewSetSummaryGenerated",
    ExtractionException: "extractionException",
    OcrProcessingTimeout: "ocrProcessingTimeout",
    OcrFileSizeExceedsLimit: "ocrFileSizeExceedsLimit",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ForceUserPasswordResetEntityIdentifierObject = {
    AccountSid: "accountSid",
    InitiatingProcessAccountSid: "initiatingProcessAccountSid",
    RequestAccountSid: "requestAccountSid",
    OnPremSid: "onPremSid",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const GoogleCloudLocationTypeObject = {
    Unknown: "unknown",
    Regional: "regional",
    Zonal: "zonal",
    Global: "global",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HealthIssueSeverityObject = {
    Low: "low",
    Medium: "medium",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HealthIssueStatusObject = {
    Open: "open",
    Closed: "closed",
    Suppressed: "suppressed",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HealthIssueTypeObject = {
    Sensor: "sensor",
    Global: "global",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HostPortProtocolObject = {
    Tcp: "tcp",
    Udp: "udp",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HostPortStatusObject = {
    Open: "open",
    Filtered: "filtered",
    Closed: "closed",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HostReputationClassificationObject = {
    Unknown: "unknown",
    Neutral: "neutral",
    Suspicious: "suspicious",
    Malicious: "malicious",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HostReputationRuleSeverityObject = {
    Unknown: "unknown",
    Low: "low",
    Medium: "medium",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HuntingRuleErrorCodeObject = {
    QueryExecutionFailed: "queryExecutionFailed",
    QueryExecutionThrottling: "queryExecutionThrottling",
    QueryExceededResultSize: "queryExceededResultSize",
    QueryLimitsExceeded: "queryLimitsExceeded",
    QueryTimeout: "queryTimeout",
    AlertCreationFailed: "alertCreationFailed",
    AlertReportNotFound: "alertReportNotFound",
    PartialRowsFailed: "partialRowsFailed",
    UnknownFutureValue: "unknownFutureValue",
    NoImpactedEntity: "noImpactedEntity",
} as const;
export const HuntingRuleRunStatusObject = {
    Running: "running",
    Completed: "completed",
    Failed: "failed",
    PartiallyFailed: "partiallyFailed",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IncidentStatusObject = {
    Active: "active",
    Resolved: "resolved",
    InProgress: "inProgress",
    Redirected: "redirected",
    UnknownFutureValue: "unknownFutureValue",
    AwaitingAction: "awaitingAction",
} as const;
export const IndicatorSourceObject = {
    Microsoft: "microsoft",
    Osint: "osint",
    Public: "public",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IntelligenceProfileKindObject = {
    Actor: "actor",
    Tool: "tool",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IoTDeviceImportanceTypeObject = {
    Unknown: "unknown",
    Low: "low",
    Normal: "normal",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IsolationTypeObject = {
    Full: "full",
    Selective: "selective",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const KubernetesPlatformObject = {
    Unknown: "unknown",
    Aks: "aks",
    Eks: "eks",
    Gke: "gke",
    Arc: "arc",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const KubernetesServiceTypeObject = {
    Unknown: "unknown",
    ClusterIP: "clusterIP",
    ExternalName: "externalName",
    NodePort: "nodePort",
    LoadBalancer: "loadBalancer",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const LongRunningOperationStatusObject = {
    NotStarted: "notStarted",
    Running: "running",
    Succeeded: "succeeded",
    Failed: "failed",
    Skipped: "skipped",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const MailboxAssetIdentifierObject = {
    AccountUpn: "accountUpn",
    FileOwnerUpn: "fileOwnerUpn",
    InitiatingProcessAccountUpn: "initiatingProcessAccountUpn",
    LastModifyingAccountUpn: "lastModifyingAccountUpn",
    TargetAccountUpn: "targetAccountUpn",
    SenderFromAddress: "senderFromAddress",
    SenderDisplayName: "senderDisplayName",
    RecipientEmailAddress: "recipientEmailAddress",
    SenderMailFromAddress: "senderMailFromAddress",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const MailboxConfigurationTypeObject = {
    MailForwardingRule: "mailForwardingRule",
    OwaSettings: "owaSettings",
    EwsSettings: "ewsSettings",
    MailDelegation: "mailDelegation",
    UserInboxRule: "userInboxRule",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const MarkUserAsCompromisedEntityIdentifierObject = {
    AccountObjectId: "accountObjectId",
    InitiatingProcessAccountObjectId: "initiatingProcessAccountObjectId",
    ServicePrincipalId: "servicePrincipalId",
    RecipientObjectId: "recipientObjectId",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const OnboardingStatusObject = {
    InsufficientInfo: "insufficientInfo",
    Onboarded: "onboarded",
    CanBeOnboarded: "canBeOnboarded",
    Unsupported: "unsupported",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const PolicyStatusObject = {
    Pending: "pending",
    ErrorEscaped: "error",
    Success: "success",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ProtocolTypeObject = {
    Tcp: "tcp",
    Udp: "udp",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const PurgeAreasObject = {
    Mailboxes: "mailboxes",
    TeamsMessages: "teamsMessages",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const PurgeTypeObject = {
    Recoverable: "recoverable",
    PermanentlyDeleted: "permanentlyDeleted",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const QueryTypeObject = {
    Files: "files",
    Messages: "messages",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RemediationActionObject = {
    MoveToJunk: "moveToJunk",
    MoveToInbox: "moveToInbox",
    HardDelete: "hardDelete",
    SoftDelete: "softDelete",
    MoveToDeletedItems: "moveToDeletedItems",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RemediationSeverityObject = {
    Low: "low",
    Medium: "medium",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RetentionTriggerObject = {
    DateLabeled: "dateLabeled",
    DateCreated: "dateCreated",
    DateModified: "dateModified",
    DateOfEvent: "dateOfEvent",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ScopeTypeObject = {
    DeviceGroup: "deviceGroup",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SensorHealthStatusObject = {
    Healthy: "healthy",
    NotHealthyLow: "notHealthyLow",
    NotHealthyMedium: "notHealthyMedium",
    NotHealthyHigh: "notHealthyHigh",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SensorTypeObject = {
    AdConnectIntegrated: "adConnectIntegrated",
    AdcsIntegrated: "adcsIntegrated",
    AdfsIntegrated: "adfsIntegrated",
    DomainControllerIntegrated: "domainControllerIntegrated",
    DomainControllerStandalone: "domainControllerStandalone",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ServicePrincipalTypeObject = {
    Unknown: "unknown",
    Application: "application",
    ManagedIdentity: "managedIdentity",
    Legacy: "legacy",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ServiceSourceObject = {
    Unknown: "unknown",
    MicrosoftDefenderForEndpoint: "microsoftDefenderForEndpoint",
    MicrosoftDefenderForIdentity: "microsoftDefenderForIdentity",
    MicrosoftDefenderForCloudApps: "microsoftDefenderForCloudApps",
    MicrosoftDefenderForOffice365: "microsoftDefenderForOffice365",
    Microsoft365Defender: "microsoft365Defender",
    AzureAdIdentityProtection: "azureAdIdentityProtection",
    MicrosoftAppGovernance: "microsoftAppGovernance",
    DataLossPrevention: "dataLossPrevention",
    UnknownFutureValue: "unknownFutureValue",
    MicrosoftDefenderForCloud: "microsoftDefenderForCloud",
    MicrosoftSentinel: "microsoftSentinel",
    MicrosoftInsiderRiskManagement: "microsoftInsiderRiskManagement",
} as const;
export const SourceTypeObject = {
    Mailbox: "mailbox",
    Site: "site",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const StopAndQuarantineFileEntityIdentifierObject = {
    DeviceId: "deviceId",
    Sha1: "sha1",
    InitiatingProcessSHA1: "initiatingProcessSHA1",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SubmissionCategoryObject = {
    NotJunk: "notJunk",
    Spam: "spam",
    Phishing: "phishing",
    Malware: "malware",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SubmissionClientSourceObject = {
    Microsoft: "microsoft",
    Other: "other",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SubmissionContentTypeObject = {
    Email: "email",
    Url: "url",
    File: "file",
    App: "app",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SubmissionResultCategoryObject = {
    NotJunk: "notJunk",
    Spam: "spam",
    Phishing: "phishing",
    Malware: "malware",
    AllowedByPolicy: "allowedByPolicy",
    BlockedByPolicy: "blockedByPolicy",
    Spoof: "spoof",
    Unknown: "unknown",
    NoResultAvailable: "noResultAvailable",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SubmissionResultDetailObject = {
    None: "none",
    UnderInvestigation: "underInvestigation",
    SimulatedThreat: "simulatedThreat",
    AllowedBySecOps: "allowedBySecOps",
    AllowedByThirdPartyFilters: "allowedByThirdPartyFilters",
    MessageNotFound: "messageNotFound",
    UrlFileShouldNotBeBlocked: "urlFileShouldNotBeBlocked",
    UrlFileShouldBeBlocked: "urlFileShouldBeBlocked",
    UrlFileCannotMakeDecision: "urlFileCannotMakeDecision",
    DomainImpersonation: "domainImpersonation",
    UserImpersonation: "userImpersonation",
    BrandImpersonation: "brandImpersonation",
    OutboundShouldNotBeBlocked: "outboundShouldNotBeBlocked",
    OutboundShouldBeBlocked: "outboundShouldBeBlocked",
    OutboundBulk: "outboundBulk",
    OutboundCannotMakeDecision: "outboundCannotMakeDecision",
    OutboundNotRescanned: "outboundNotRescanned",
    ZeroHourAutoPurgeAllowed: "zeroHourAutoPurgeAllowed",
    ZeroHourAutoPurgeBlocked: "zeroHourAutoPurgeBlocked",
    ZeroHourAutoPurgeQuarantineReleased: "zeroHourAutoPurgeQuarantineReleased",
    OnPremisesSkip: "onPremisesSkip",
    AllowedByTenantAllowBlockList: "allowedByTenantAllowBlockList",
    BlockedByTenantAllowBlockList: "blockedByTenantAllowBlockList",
    AllowedUrlByTenantAllowBlockList: "allowedUrlByTenantAllowBlockList",
    AllowedFileByTenantAllowBlockList: "allowedFileByTenantAllowBlockList",
    AllowedSenderByTenantAllowBlockList: "allowedSenderByTenantAllowBlockList",
    AllowedRecipientByTenantAllowBlockList: "allowedRecipientByTenantAllowBlockList",
    BlockedUrlByTenantAllowBlockList: "blockedUrlByTenantAllowBlockList",
    BlockedFileByTenantAllowBlockList: "blockedFileByTenantAllowBlockList",
    BlockedSenderByTenantAllowBlockList: "blockedSenderByTenantAllowBlockList",
    BlockedRecipientByTenantAllowBlockList: "blockedRecipientByTenantAllowBlockList",
    AllowedByConnection: "allowedByConnection",
    BlockedByConnection: "blockedByConnection",
    AllowedByExchangeTransportRule: "allowedByExchangeTransportRule",
    BlockedByExchangeTransportRule: "blockedByExchangeTransportRule",
    QuarantineReleased: "quarantineReleased",
    QuarantineReleasedThenBlocked: "quarantineReleasedThenBlocked",
    JunkMailRuleDisabled: "junkMailRuleDisabled",
    AllowedByUserSetting: "allowedByUserSetting",
    BlockedByUserSetting: "blockedByUserSetting",
    AllowedByTenant: "allowedByTenant",
    BlockedByTenant: "blockedByTenant",
    InvalidFalsePositive: "invalidFalsePositive",
    InvalidFalseNegative: "invalidFalseNegative",
    SpoofBlocked: "spoofBlocked",
    GoodReclassifiedAsBad: "goodReclassifiedAsBad",
    GoodReclassifiedAsBulk: "goodReclassifiedAsBulk",
    GoodReclassifiedAsGood: "goodReclassifiedAsGood",
    GoodReclassifiedAsCannotMakeDecision: "goodReclassifiedAsCannotMakeDecision",
    BadReclassifiedAsGood: "badReclassifiedAsGood",
    BadReclassifiedAsBulk: "badReclassifiedAsBulk",
    BadReclassifiedAsBad: "badReclassifiedAsBad",
    BadReclassifiedAsCannotMakeDecision: "badReclassifiedAsCannotMakeDecision",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SubmissionSourceObject = {
    User: "user",
    Administrator: "administrator",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const TenantAllowBlockListActionObject = {
    Allow: "allow",
    Block: "block",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const TenantAllowBlockListEntryTypeObject = {
    Url: "url",
    FileHash: "fileHash",
    Sender: "sender",
    Recipient: "recipient",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ThreatTypeObject = {
    Unknown: "unknown",
    Spam: "spam",
    Malware: "malware",
    Phish: "phish",
    None: "none",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const UserAssetIdentifierObject = {
    AccountObjectId: "accountObjectId",
    AccountSid: "accountSid",
    AccountUpn: "accountUpn",
    AccountName: "accountName",
    AccountDomain: "accountDomain",
    AccountId: "accountId",
    RequestAccountSid: "requestAccountSid",
    RequestAccountName: "requestAccountName",
    RequestAccountDomain: "requestAccountDomain",
    RecipientObjectId: "recipientObjectId",
    ProcessAccountObjectId: "processAccountObjectId",
    InitiatingAccountSid: "initiatingAccountSid",
    InitiatingProcessAccountUpn: "initiatingProcessAccountUpn",
    InitiatingAccountName: "initiatingAccountName",
    InitiatingAccountDomain: "initiatingAccountDomain",
    ServicePrincipalId: "servicePrincipalId",
    ServicePrincipalName: "servicePrincipalName",
    TargetAccountUpn: "targetAccountUpn",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const UserMailboxSettingObject = {
    None: "none",
    JunkMailDeletion: "junkMailDeletion",
    IsFromAddressInAddressBook: "isFromAddressInAddressBook",
    IsFromAddressInAddressSafeList: "isFromAddressInAddressSafeList",
    IsFromAddressInAddressBlockList: "isFromAddressInAddressBlockList",
    IsFromAddressInAddressImplicitSafeList: "isFromAddressInAddressImplicitSafeList",
    IsFromAddressInAddressImplicitJunkList: "isFromAddressInAddressImplicitJunkList",
    IsFromDomainInDomainSafeList: "isFromDomainInDomainSafeList",
    IsFromDomainInDomainBlockList: "isFromDomainInDomainBlockList",
    IsRecipientInRecipientSafeList: "isRecipientInRecipientSafeList",
    CustomRule: "customRule",
    JunkMailRule: "junkMailRule",
    SenderPraPresent: "senderPraPresent",
    FromFirstTimeSender: "fromFirstTimeSender",
    Exclusive: "exclusive",
    PriorSeenPass: "priorSeenPass",
    SenderAuthenticationSucceeded: "senderAuthenticationSucceeded",
    IsJunkMailRuleEnabled: "isJunkMailRuleEnabled",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const VmCloudProviderObject = {
    Unknown: "unknown",
    Azure: "azure",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const VulnerabilitySeverityObject = {
    None: "none",
    Low: "low",
    Medium: "medium",
    High: "high",
    Critical: "critical",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const WatermarkLayoutObject = {
    Horizontal: "horizontal",
    Diagonal: "diagonal",
} as const;
/* tslint:enable */
/* eslint-enable */
