/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createDirectoryObjectFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeDirectoryObject, serializeEntity, type BaseCollectionPaginationCountResponse, type DirectoryObject, type Entity } from '../index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type DateOnly, type Guid, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface AdminCloudLicensing extends Entity, Parsable {
    /**
     * The set of all allotments within the organization. Read-only.
     */
    allotments?: Allotment[] | null;
    /**
     * The set of all asynchronous allotment assignment errors that affect the organization. Read-only.
     */
    assignmentErrors?: AssignmentError[] | null;
    /**
     * The set of all license assignments within the organization. Not nullable.
     */
    assignments?: Assignment[] | null;
}
export interface Allotment extends Entity, Parsable {
    /**
     * The number of licenses contained within the allotment. Not nullable. Read-only.
     */
    allottedUnits?: number | null;
    /**
     * The assignableTo property
     */
    assignableTo?: AssigneeTypes[] | null;
    /**
     * The list of license assignments that consume licenses from this allotment. Not nullable.
     */
    assignments?: Assignment[] | null;
    /**
     * The number of licenses that are currently consumed by assignments from this allotment. Not nullable. Read-only.
     */
    consumedUnits?: number | null;
    /**
     * The list of services that might be enabled or disabled for assignments from this allotment. Not nullable. Read-only.
     */
    services?: Service[] | null;
    /**
     * Unique identifier (GUID) for the service SKU that is equal to the skuId property on the related subscribedSku object. Read-only. Supports $filter.
     */
    skuId?: Guid | null;
    /**
     * Unique SKU display name that is equal to the skuPartNumber on the related subscribedSku object; for example, AAD_Premium. Read-only.
     */
    skuPartNumber?: string | null;
    /**
     * Basic information about the subscriptions that supports this allotment.
     */
    subscriptions?: Subscription[] | null;
    /**
     * List of over-assigned users who are in the waiting room for an allotment due to license capacity limits.
     */
    waitingMembers?: WaitingMember[] | null;
}
export interface AllotmentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Allotment[] | null;
}
export type AssigneeTypes = (typeof AssigneeTypesObject)[keyof typeof AssigneeTypesObject];
export interface Assignment extends Entity, Parsable {
    /**
     * The allotment from which licenses are assigned. Not nullable.
     */
    allotment?: Allotment | null;
    /**
     * The assignedTo property
     */
    assignedTo?: DirectoryObject | null;
    /**
     * The list of disabled service plans for this assignment. Not nullable.
     */
    disabledServicePlanIds?: Guid[] | null;
}
export interface AssignmentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Assignment[] | null;
}
export interface AssignmentError extends Entity, Parsable {
    /**
     * The assignedTo property
     */
    assignedTo?: DirectoryObject | null;
    /**
     * The error code associated with the assignment synchronization failure.
     */
    code?: string | null;
    /**
     * The error message associated with the assignment synchronization failure.
     */
    message?: string | null;
    /**
     * The date and time at which the error most recently occurred. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    occurrenceDateTime?: Date | null;
    /**
     * Unique identifier (GUID) for the service SKU that is equal to the skuId property on the related subscribedSku object. Read-only. Supports $filter.
     */
    skuId?: Guid | null;
    /**
     * The affected usageRight, if one exists. Read-only.
     */
    usageRight?: UsageRight | null;
}
export interface AssignmentErrorCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: AssignmentError[] | null;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AdminCloudLicensing}
 */
// @ts-ignore
export function createAdminCloudLicensingFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAdminCloudLicensing;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AllotmentCollectionResponse}
 */
// @ts-ignore
export function createAllotmentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAllotmentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Allotment}
 */
// @ts-ignore
export function createAllotmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAllotment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AssignmentCollectionResponse}
 */
// @ts-ignore
export function createAssignmentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAssignmentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AssignmentErrorCollectionResponse}
 */
// @ts-ignore
export function createAssignmentErrorCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAssignmentErrorCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AssignmentError}
 */
// @ts-ignore
export function createAssignmentErrorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAssignmentError;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Assignment}
 */
// @ts-ignore
export function createAssignmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAssignment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GroupCloudLicensing}
 */
// @ts-ignore
export function createGroupCloudLicensingFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGroupCloudLicensing;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Service}
 */
// @ts-ignore
export function createServiceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoService;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Subscription}
 */
// @ts-ignore
export function createSubscriptionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubscription;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UsageRight}
 */
// @ts-ignore
export function createUsageRightFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUsageRight;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserCloudLicensing}
 */
// @ts-ignore
export function createUserCloudLicensingFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserCloudLicensing;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WaitingMemberCollectionResponse}
 */
// @ts-ignore
export function createWaitingMemberCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWaitingMemberCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WaitingMember}
 */
// @ts-ignore
export function createWaitingMemberFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWaitingMember;
}
/**
 * The deserialization information for the current model
 * @param AdminCloudLicensing The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAdminCloudLicensing(adminCloudLicensing: Partial<AdminCloudLicensing> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(adminCloudLicensing),
        "allotments": n => { adminCloudLicensing.allotments = n.getCollectionOfObjectValues<Allotment>(createAllotmentFromDiscriminatorValue); },
        "assignmentErrors": n => { adminCloudLicensing.assignmentErrors = n.getCollectionOfObjectValues<AssignmentError>(createAssignmentErrorFromDiscriminatorValue); },
        "assignments": n => { adminCloudLicensing.assignments = n.getCollectionOfObjectValues<Assignment>(createAssignmentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Allotment The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAllotment(allotment: Partial<Allotment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(allotment),
        "allottedUnits": n => { allotment.allottedUnits = n.getNumberValue(); },
        "assignableTo": n => { allotment.assignableTo = n.getCollectionOfEnumValues<AssigneeTypes>(AssigneeTypesObject); },
        "assignments": n => { allotment.assignments = n.getCollectionOfObjectValues<Assignment>(createAssignmentFromDiscriminatorValue); },
        "consumedUnits": n => { allotment.consumedUnits = n.getNumberValue(); },
        "services": n => { allotment.services = n.getCollectionOfObjectValues<Service>(createServiceFromDiscriminatorValue); },
        "skuId": n => { allotment.skuId = n.getGuidValue(); },
        "skuPartNumber": n => { allotment.skuPartNumber = n.getStringValue(); },
        "subscriptions": n => { allotment.subscriptions = n.getCollectionOfObjectValues<Subscription>(createSubscriptionFromDiscriminatorValue); },
        "waitingMembers": n => { allotment.waitingMembers = n.getCollectionOfObjectValues<WaitingMember>(createWaitingMemberFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param AllotmentCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAllotmentCollectionResponse(allotmentCollectionResponse: Partial<AllotmentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(allotmentCollectionResponse),
        "value": n => { allotmentCollectionResponse.value = n.getCollectionOfObjectValues<Allotment>(createAllotmentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Assignment The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAssignment(assignment: Partial<Assignment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(assignment),
        "allotment": n => { assignment.allotment = n.getObjectValue<Allotment>(createAllotmentFromDiscriminatorValue); },
        "assignedTo": n => { assignment.assignedTo = n.getObjectValue<DirectoryObject>(createDirectoryObjectFromDiscriminatorValue); },
        "disabledServicePlanIds": n => { assignment.disabledServicePlanIds = n.getCollectionOfPrimitiveValues<Guid>(); },
    }
}
/**
 * The deserialization information for the current model
 * @param AssignmentCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAssignmentCollectionResponse(assignmentCollectionResponse: Partial<AssignmentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(assignmentCollectionResponse),
        "value": n => { assignmentCollectionResponse.value = n.getCollectionOfObjectValues<Assignment>(createAssignmentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param AssignmentError The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAssignmentError(assignmentError: Partial<AssignmentError> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(assignmentError),
        "assignedTo": n => { assignmentError.assignedTo = n.getObjectValue<DirectoryObject>(createDirectoryObjectFromDiscriminatorValue); },
        "code": n => { assignmentError.code = n.getStringValue(); },
        "message": n => { assignmentError.message = n.getStringValue(); },
        "occurrenceDateTime": n => { assignmentError.occurrenceDateTime = n.getDateValue(); },
        "skuId": n => { assignmentError.skuId = n.getGuidValue(); },
        "usageRight": n => { assignmentError.usageRight = n.getObjectValue<UsageRight>(createUsageRightFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param AssignmentErrorCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAssignmentErrorCollectionResponse(assignmentErrorCollectionResponse: Partial<AssignmentErrorCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(assignmentErrorCollectionResponse),
        "value": n => { assignmentErrorCollectionResponse.value = n.getCollectionOfObjectValues<AssignmentError>(createAssignmentErrorFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param GroupCloudLicensing The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGroupCloudLicensing(groupCloudLicensing: Partial<GroupCloudLicensing> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "assignments": n => { groupCloudLicensing.assignments = n.getCollectionOfObjectValues<Assignment>(createAssignmentFromDiscriminatorValue); },
        "backingStoreEnabled": n => { groupCloudLicensing.backingStoreEnabled = true; },
        "@odata.type": n => { groupCloudLicensing.odataType = n.getStringValue(); },
        "usageRights": n => { groupCloudLicensing.usageRights = n.getCollectionOfObjectValues<UsageRight>(createUsageRightFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Service The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoService(service: Partial<Service> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "assignableTo": n => { service.assignableTo = n.getCollectionOfEnumValues<AssigneeTypes>(AssigneeTypesObject); },
        "backingStoreEnabled": n => { service.backingStoreEnabled = true; },
        "@odata.type": n => { service.odataType = n.getStringValue(); },
        "planId": n => { service.planId = n.getGuidValue(); },
        "planName": n => { service.planName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Subscription The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSubscription(subscription: Partial<Subscription> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { subscription.backingStoreEnabled = true; },
        "nextLifecycleDate": n => { subscription.nextLifecycleDate = n.getDateOnlyValue(); },
        "@odata.type": n => { subscription.odataType = n.getStringValue(); },
        "startDate": n => { subscription.startDate = n.getDateOnlyValue(); },
        "state": n => { subscription.state = n.getEnumValue<SubscriptionState>(SubscriptionStateObject); },
        "subscriptionId": n => { subscription.subscriptionId = n.getStringValue(); },
        "tags": n => { subscription.tags = n.getCollectionOfEnumValues<SubscriptionTags>(SubscriptionTagsObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param UsageRight The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUsageRight(usageRight: Partial<UsageRight> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(usageRight),
        "allotments": n => { usageRight.allotments = n.getCollectionOfObjectValues<Allotment>(createAllotmentFromDiscriminatorValue); },
        "assignments": n => { usageRight.assignments = n.getCollectionOfObjectValues<Assignment>(createAssignmentFromDiscriminatorValue); },
        "services": n => { usageRight.services = n.getCollectionOfObjectValues<Service>(createServiceFromDiscriminatorValue); },
        "skuId": n => { usageRight.skuId = n.getGuidValue(); },
        "skuPartNumber": n => { usageRight.skuPartNumber = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UserCloudLicensing The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUserCloudLicensing(userCloudLicensing: Partial<UserCloudLicensing> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "assignmentErrors": n => { userCloudLicensing.assignmentErrors = n.getCollectionOfObjectValues<AssignmentError>(createAssignmentErrorFromDiscriminatorValue); },
        "assignments": n => { userCloudLicensing.assignments = n.getCollectionOfObjectValues<Assignment>(createAssignmentFromDiscriminatorValue); },
        "backingStoreEnabled": n => { userCloudLicensing.backingStoreEnabled = true; },
        "@odata.type": n => { userCloudLicensing.odataType = n.getStringValue(); },
        "usageRights": n => { userCloudLicensing.usageRights = n.getCollectionOfObjectValues<UsageRight>(createUsageRightFromDiscriminatorValue); },
        "waitingMembers": n => { userCloudLicensing.waitingMembers = n.getCollectionOfObjectValues<WaitingMember>(createWaitingMemberFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param WaitingMember The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWaitingMember(waitingMember: Partial<WaitingMember> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(waitingMember),
        "allotment": n => { waitingMember.allotment = n.getObjectValue<Allotment>(createAllotmentFromDiscriminatorValue); },
        "assignedTo": n => { waitingMember.assignedTo = n.getObjectValue<DirectoryObject>(createDirectoryObjectFromDiscriminatorValue); },
        "waitingSinceDateTime": n => { waitingMember.waitingSinceDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param WaitingMemberCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWaitingMemberCollectionResponse(waitingMemberCollectionResponse: Partial<WaitingMemberCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(waitingMemberCollectionResponse),
        "value": n => { waitingMemberCollectionResponse.value = n.getCollectionOfObjectValues<WaitingMember>(createWaitingMemberFromDiscriminatorValue); },
    }
}
export interface GroupCloudLicensing extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The assignments property
     */
    assignments?: Assignment[] | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The usageRights property
     */
    usageRights?: UsageRight[] | null;
}
/**
 * Serializes information the current object
 * @param AdminCloudLicensing The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAdminCloudLicensing(writer: SerializationWriter, adminCloudLicensing: Partial<AdminCloudLicensing> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!adminCloudLicensing || isSerializingDerivedType) { return; }
    serializeEntity(writer, adminCloudLicensing, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Allotment>("allotments", adminCloudLicensing.allotments, serializeAllotment);
    writer.writeCollectionOfObjectValues<AssignmentError>("assignmentErrors", adminCloudLicensing.assignmentErrors, serializeAssignmentError);
    writer.writeCollectionOfObjectValues<Assignment>("assignments", adminCloudLicensing.assignments, serializeAssignment);
}
/**
 * Serializes information the current object
 * @param Allotment The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAllotment(writer: SerializationWriter, allotment: Partial<Allotment> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!allotment || isSerializingDerivedType) { return; }
    serializeEntity(writer, allotment, isSerializingDerivedType)
    writer.writeNumberValue("allottedUnits", allotment.allottedUnits);
    writer.writeEnumValue<AssigneeTypes[]>("assignableTo", allotment.assignableTo);
    writer.writeCollectionOfObjectValues<Assignment>("assignments", allotment.assignments, serializeAssignment);
    writer.writeNumberValue("consumedUnits", allotment.consumedUnits);
    writer.writeCollectionOfObjectValues<Service>("services", allotment.services, serializeService);
    writer.writeGuidValue("skuId", allotment.skuId);
    writer.writeStringValue("skuPartNumber", allotment.skuPartNumber);
    writer.writeCollectionOfObjectValues<Subscription>("subscriptions", allotment.subscriptions, serializeSubscription);
    writer.writeCollectionOfObjectValues<WaitingMember>("waitingMembers", allotment.waitingMembers, serializeWaitingMember);
}
/**
 * Serializes information the current object
 * @param AllotmentCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAllotmentCollectionResponse(writer: SerializationWriter, allotmentCollectionResponse: Partial<AllotmentCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!allotmentCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, allotmentCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Allotment>("value", allotmentCollectionResponse.value, serializeAllotment);
}
/**
 * Serializes information the current object
 * @param Assignment The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAssignment(writer: SerializationWriter, assignment: Partial<Assignment> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!assignment || isSerializingDerivedType) { return; }
    serializeEntity(writer, assignment, isSerializingDerivedType)
    writer.writeObjectValue<Allotment>("allotment", assignment.allotment, serializeAllotment);
    writer.writeObjectValue<DirectoryObject>("assignedTo", assignment.assignedTo, serializeDirectoryObject);
    writer.writeCollectionOfPrimitiveValues<Guid>("disabledServicePlanIds", assignment.disabledServicePlanIds);
}
/**
 * Serializes information the current object
 * @param AssignmentCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAssignmentCollectionResponse(writer: SerializationWriter, assignmentCollectionResponse: Partial<AssignmentCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!assignmentCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, assignmentCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Assignment>("value", assignmentCollectionResponse.value, serializeAssignment);
}
/**
 * Serializes information the current object
 * @param AssignmentError The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAssignmentError(writer: SerializationWriter, assignmentError: Partial<AssignmentError> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!assignmentError || isSerializingDerivedType) { return; }
    serializeEntity(writer, assignmentError, isSerializingDerivedType)
    writer.writeObjectValue<DirectoryObject>("assignedTo", assignmentError.assignedTo, serializeDirectoryObject);
    writer.writeStringValue("code", assignmentError.code);
    writer.writeStringValue("message", assignmentError.message);
    writer.writeDateValue("occurrenceDateTime", assignmentError.occurrenceDateTime);
    writer.writeGuidValue("skuId", assignmentError.skuId);
    writer.writeObjectValue<UsageRight>("usageRight", assignmentError.usageRight, serializeUsageRight);
}
/**
 * Serializes information the current object
 * @param AssignmentErrorCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAssignmentErrorCollectionResponse(writer: SerializationWriter, assignmentErrorCollectionResponse: Partial<AssignmentErrorCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!assignmentErrorCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, assignmentErrorCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<AssignmentError>("value", assignmentErrorCollectionResponse.value, serializeAssignmentError);
}
/**
 * Serializes information the current object
 * @param GroupCloudLicensing The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGroupCloudLicensing(writer: SerializationWriter, groupCloudLicensing: Partial<GroupCloudLicensing> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!groupCloudLicensing || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<Assignment>("assignments", groupCloudLicensing.assignments, serializeAssignment);
    writer.writeStringValue("@odata.type", groupCloudLicensing.odataType);
    writer.writeCollectionOfObjectValues<UsageRight>("usageRights", groupCloudLicensing.usageRights, serializeUsageRight);
    writer.writeAdditionalData(groupCloudLicensing.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Service The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeService(writer: SerializationWriter, service: Partial<Service> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!service || isSerializingDerivedType) { return; }
    writer.writeEnumValue<AssigneeTypes[]>("assignableTo", service.assignableTo);
    writer.writeStringValue("@odata.type", service.odataType);
    writer.writeGuidValue("planId", service.planId);
    writer.writeStringValue("planName", service.planName);
    writer.writeAdditionalData(service.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Subscription The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSubscription(writer: SerializationWriter, subscription: Partial<Subscription> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!subscription || isSerializingDerivedType) { return; }
    writer.writeDateOnlyValue("nextLifecycleDate", subscription.nextLifecycleDate);
    writer.writeStringValue("@odata.type", subscription.odataType);
    writer.writeDateOnlyValue("startDate", subscription.startDate);
    writer.writeEnumValue<SubscriptionState>("state", subscription.state);
    writer.writeStringValue("subscriptionId", subscription.subscriptionId);
    writer.writeEnumValue<SubscriptionTags[]>("tags", subscription.tags);
    writer.writeAdditionalData(subscription.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UsageRight The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUsageRight(writer: SerializationWriter, usageRight: Partial<UsageRight> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!usageRight || isSerializingDerivedType) { return; }
    serializeEntity(writer, usageRight, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Allotment>("allotments", usageRight.allotments, serializeAllotment);
    writer.writeCollectionOfObjectValues<Assignment>("assignments", usageRight.assignments, serializeAssignment);
    writer.writeCollectionOfObjectValues<Service>("services", usageRight.services, serializeService);
    writer.writeGuidValue("skuId", usageRight.skuId);
    writer.writeStringValue("skuPartNumber", usageRight.skuPartNumber);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UserCloudLicensing The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUserCloudLicensing(writer: SerializationWriter, userCloudLicensing: Partial<UserCloudLicensing> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!userCloudLicensing || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<AssignmentError>("assignmentErrors", userCloudLicensing.assignmentErrors, serializeAssignmentError);
    writer.writeCollectionOfObjectValues<Assignment>("assignments", userCloudLicensing.assignments, serializeAssignment);
    writer.writeStringValue("@odata.type", userCloudLicensing.odataType);
    writer.writeCollectionOfObjectValues<UsageRight>("usageRights", userCloudLicensing.usageRights, serializeUsageRight);
    writer.writeCollectionOfObjectValues<WaitingMember>("waitingMembers", userCloudLicensing.waitingMembers, serializeWaitingMember);
    writer.writeAdditionalData(userCloudLicensing.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WaitingMember The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWaitingMember(writer: SerializationWriter, waitingMember: Partial<WaitingMember> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!waitingMember || isSerializingDerivedType) { return; }
    serializeEntity(writer, waitingMember, isSerializingDerivedType)
    writer.writeObjectValue<Allotment>("allotment", waitingMember.allotment, serializeAllotment);
    writer.writeObjectValue<DirectoryObject>("assignedTo", waitingMember.assignedTo, serializeDirectoryObject);
    writer.writeDateValue("waitingSinceDateTime", waitingMember.waitingSinceDateTime);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WaitingMemberCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWaitingMemberCollectionResponse(writer: SerializationWriter, waitingMemberCollectionResponse: Partial<WaitingMemberCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!waitingMemberCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, waitingMemberCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<WaitingMember>("value", waitingMemberCollectionResponse.value, serializeWaitingMember);
}
export interface Service extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The assignableTo property
     */
    assignableTo?: AssigneeTypes[] | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The unique identifier of the service plan that is equal to the servicePlanId property on the related servicePlanInfo objects.
     */
    planId?: Guid | null;
    /**
     * The name of the service plan that is equal to the servicePlanName property on the related servicePlanInfo objects.
     */
    planName?: string | null;
}
export interface Subscription extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The date on which the current state transitions to the next state.
     */
    nextLifecycleDate?: DateOnly | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The date when the subscription started.
     */
    startDate?: DateOnly | null;
    /**
     * The state property
     */
    state?: SubscriptionState | null;
    /**
     * Identifier for the subscription object.
     */
    subscriptionId?: string | null;
    /**
     * The tags property
     */
    tags?: SubscriptionTags[] | null;
}
export type SubscriptionState = (typeof SubscriptionStateObject)[keyof typeof SubscriptionStateObject];
export type SubscriptionTags = (typeof SubscriptionTagsObject)[keyof typeof SubscriptionTagsObject];
export interface UsageRight extends Entity, Parsable {
    /**
     * The set of allotments associated with the assignments that combine to form this usageRight.
     */
    allotments?: Allotment[] | null;
    /**
     * The set of assignments that combine to form this usageRight, including both direct assignments and assignments inherited through group membership.
     */
    assignments?: Assignment[] | null;
    /**
     * Information about the services associated with the usageRight. Not nullable. Read-only. Supports $filter on the planId property.
     */
    services?: Service[] | null;
    /**
     * Unique identifier (GUID) for the service SKU that is equal to the skuId property on the related subscribedSku object. Read-only. Supports $filter.
     */
    skuId?: Guid | null;
    /**
     * Unique SKU display name that is equal to the skuPartNumber on the related subscribedSku object; for example, AAD_Premium. Read-only.
     */
    skuPartNumber?: string | null;
}
export interface UserCloudLicensing extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The assignmentErrors property
     */
    assignmentErrors?: AssignmentError[] | null;
    /**
     * The assignments property
     */
    assignments?: Assignment[] | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The usageRights property
     */
    usageRights?: UsageRight[] | null;
    /**
     * The waitingMembers property
     */
    waitingMembers?: WaitingMember[] | null;
}
export interface WaitingMember extends Entity, Parsable {
    /**
     * The allotment property
     */
    allotment?: Allotment | null;
    /**
     * The assignedTo property
     */
    assignedTo?: DirectoryObject | null;
    /**
     * Indicates the moment when the user or device first waited for this license. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    waitingSinceDateTime?: Date | null;
}
export interface WaitingMemberCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: WaitingMember[] | null;
}
export const AssigneeTypesObject = {
    None: "none",
    User: "user",
    Group: "group",
    Device: "device",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SubscriptionStateObject = {
    Active: "active",
    Warning: "warning",
    Suspended: "suspended",
    LockedOut: "lockedOut",
    Deleted: "deleted",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SubscriptionTagsObject = {
    None: "none",
    Trial: "trial",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
