/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createDirectoryObjectFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeDirectoryObject, serializeEntity, type BaseCollectionPaginationCountResponse, type DirectoryObject, type Entity } from '../index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface Alert extends Entity, Parsable {
    /**
     * The alertType property
     */
    alertType?: AlertType | null;
    /**
     * The category property
     */
    category?: Category | null;
    /**
     * The time when Microsoft Entra Health monitoring generated the alert. Supports $orderby.
     */
    createdDateTime?: Date | null;
    /**
     * A key-value pair that contains the name of and link to the documentation to aid in investigation of the alert.
     */
    documentation?: Documentation | null;
    /**
     * Investigative information on the alert. This information typically includes counts of impacted objects, which include directory objects such as users, groups, and devices, and a pointer to supporting data.
     */
    enrichment?: Enrichment | null;
    /**
     * The scenario property
     */
    scenario?: Scenario | null;
    /**
     * The collection of signals that were used in the generation of the alert. These signals are sourced from serviceActivity APIs and are added to the alert as key-value pairs.
     */
    signals?: Signals | null;
    /**
     * The state property
     */
    state?: AlertState | null;
}
export interface AlertCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Alert[] | null;
}
export interface AlertConfiguration extends Entity, Parsable {
    /**
     * Defines the recipients of email notifications for an alert type. Currently, only one email notification configuration is supported for an alert configuration, meaning only one group can receive notifications for an alert type.
     */
    emailNotificationConfigurations?: EmailNotificationConfiguration[] | null;
}
export interface AlertConfigurationCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: AlertConfiguration[] | null;
}
export type AlertState = (typeof AlertStateObject)[keyof typeof AlertStateObject];
export type AlertType = (typeof AlertTypeObject)[keyof typeof AlertTypeObject];
export interface ApplicationImpactSummary extends DirectoryObjectImpactSummary, Parsable {
}
export type Category = (typeof CategoryObject)[keyof typeof CategoryObject];
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertCollectionResponse}
 */
// @ts-ignore
export function createAlertCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertConfigurationCollectionResponse}
 */
// @ts-ignore
export function createAlertConfigurationCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertConfigurationCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertConfiguration}
 */
// @ts-ignore
export function createAlertConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertConfiguration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Alert}
 */
// @ts-ignore
export function createAlertFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlert;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ApplicationImpactSummary}
 */
// @ts-ignore
export function createApplicationImpactSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoApplicationImpactSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeviceImpactSummary}
 */
// @ts-ignore
export function createDeviceImpactSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeviceImpactSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Dictionary}
 */
// @ts-ignore
export function createDictionaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.healthMonitoring.documentation":
                    return deserializeIntoDocumentation;
                case "#microsoft.graph.healthMonitoring.healthMonitoringDictionary":
                    return deserializeIntoHealthMonitoringDictionary;
                case "#microsoft.graph.healthMonitoring.signals":
                    return deserializeIntoSignals;
                case "#microsoft.graph.healthMonitoring.supportingData":
                    return deserializeIntoSupportingData;
            }
        }
    }
    return deserializeIntoDictionary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DirectoryObjectImpactSummary}
 */
// @ts-ignore
export function createDirectoryObjectImpactSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.healthMonitoring.applicationImpactSummary":
                    return deserializeIntoApplicationImpactSummary;
                case "#microsoft.graph.healthMonitoring.deviceImpactSummary":
                    return deserializeIntoDeviceImpactSummary;
                case "#microsoft.graph.healthMonitoring.groupImpactSummary":
                    return deserializeIntoGroupImpactSummary;
                case "#microsoft.graph.healthMonitoring.servicePrincipalImpactSummary":
                    return deserializeIntoServicePrincipalImpactSummary;
                case "#microsoft.graph.healthMonitoring.userImpactSummary":
                    return deserializeIntoUserImpactSummary;
            }
        }
    }
    return deserializeIntoDirectoryObjectImpactSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Documentation}
 */
// @ts-ignore
export function createDocumentationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDocumentation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EmailNotificationConfiguration}
 */
// @ts-ignore
export function createEmailNotificationConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEmailNotificationConfiguration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Enrichment}
 */
// @ts-ignore
export function createEnrichmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEnrichment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GroupImpactSummary}
 */
// @ts-ignore
export function createGroupImpactSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGroupImpactSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HealthMonitoringDictionary}
 */
// @ts-ignore
export function createHealthMonitoringDictionaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.healthMonitoring.documentation":
                    return deserializeIntoDocumentation;
                case "#microsoft.graph.healthMonitoring.signals":
                    return deserializeIntoSignals;
                case "#microsoft.graph.healthMonitoring.supportingData":
                    return deserializeIntoSupportingData;
            }
        }
    }
    return deserializeIntoHealthMonitoringDictionary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HealthMonitoringRoot}
 */
// @ts-ignore
export function createHealthMonitoringRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHealthMonitoringRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ResourceImpactSummary}
 */
// @ts-ignore
export function createResourceImpactSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.healthMonitoring.applicationImpactSummary":
                    return deserializeIntoApplicationImpactSummary;
                case "#microsoft.graph.healthMonitoring.deviceImpactSummary":
                    return deserializeIntoDeviceImpactSummary;
                case "#microsoft.graph.healthMonitoring.directoryObjectImpactSummary":
                    return deserializeIntoDirectoryObjectImpactSummary;
                case "#microsoft.graph.healthMonitoring.groupImpactSummary":
                    return deserializeIntoGroupImpactSummary;
                case "#microsoft.graph.healthMonitoring.servicePrincipalImpactSummary":
                    return deserializeIntoServicePrincipalImpactSummary;
                case "#microsoft.graph.healthMonitoring.userImpactSummary":
                    return deserializeIntoUserImpactSummary;
            }
        }
    }
    return deserializeIntoResourceImpactSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServicePrincipalImpactSummary}
 */
// @ts-ignore
export function createServicePrincipalImpactSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServicePrincipalImpactSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Signals}
 */
// @ts-ignore
export function createSignalsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSignals;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SupportingData}
 */
// @ts-ignore
export function createSupportingDataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSupportingData;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserImpactSummary}
 */
// @ts-ignore
export function createUserImpactSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserImpactSummary;
}
/**
 * The deserialization information for the current model
 * @param Alert The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlert(alert: Partial<Alert> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(alert),
        "alertType": n => { alert.alertType = n.getEnumValue<AlertType>(AlertTypeObject); },
        "category": n => { alert.category = n.getEnumValue<Category>(CategoryObject); },
        "createdDateTime": n => { alert.createdDateTime = n.getDateValue(); },
        "documentation": n => { alert.documentation = n.getObjectValue<Documentation>(createDocumentationFromDiscriminatorValue); },
        "enrichment": n => { alert.enrichment = n.getObjectValue<Enrichment>(createEnrichmentFromDiscriminatorValue); },
        "scenario": n => { alert.scenario = n.getEnumValue<Scenario>(ScenarioObject); },
        "signals": n => { alert.signals = n.getObjectValue<Signals>(createSignalsFromDiscriminatorValue); },
        "state": n => { alert.state = n.getEnumValue<AlertState>(AlertStateObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertCollectionResponse(alertCollectionResponse: Partial<AlertCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(alertCollectionResponse),
        "value": n => { alertCollectionResponse.value = n.getCollectionOfObjectValues<Alert>(createAlertFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertConfiguration The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertConfiguration(alertConfiguration: Partial<AlertConfiguration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(alertConfiguration),
        "emailNotificationConfigurations": n => { alertConfiguration.emailNotificationConfigurations = n.getCollectionOfObjectValues<EmailNotificationConfiguration>(createEmailNotificationConfigurationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertConfigurationCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertConfigurationCollectionResponse(alertConfigurationCollectionResponse: Partial<AlertConfigurationCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(alertConfigurationCollectionResponse),
        "value": n => { alertConfigurationCollectionResponse.value = n.getCollectionOfObjectValues<AlertConfiguration>(createAlertConfigurationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ApplicationImpactSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoApplicationImpactSummary(applicationImpactSummary: Partial<ApplicationImpactSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDirectoryObjectImpactSummary(applicationImpactSummary),
    }
}
/**
 * The deserialization information for the current model
 * @param DeviceImpactSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeviceImpactSummary(deviceImpactSummary: Partial<DeviceImpactSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDirectoryObjectImpactSummary(deviceImpactSummary),
    }
}
/**
 * The deserialization information for the current model
 * @param Dictionary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDictionary(dictionary: Partial<Dictionary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { dictionary.backingStoreEnabled = true; },
        "@odata.type": n => { dictionary.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DirectoryObjectImpactSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDirectoryObjectImpactSummary(directoryObjectImpactSummary: Partial<DirectoryObjectImpactSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResourceImpactSummary(directoryObjectImpactSummary),
        "resourceSampling": n => { directoryObjectImpactSummary.resourceSampling = n.getCollectionOfObjectValues<DirectoryObject>(createDirectoryObjectFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Documentation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDocumentation(documentation: Partial<Documentation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoHealthMonitoringDictionary(documentation),
    }
}
/**
 * The deserialization information for the current model
 * @param EmailNotificationConfiguration The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEmailNotificationConfiguration(emailNotificationConfiguration: Partial<EmailNotificationConfiguration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { emailNotificationConfiguration.backingStoreEnabled = true; },
        "groupId": n => { emailNotificationConfiguration.groupId = n.getStringValue(); },
        "isEnabled": n => { emailNotificationConfiguration.isEnabled = n.getBooleanValue(); },
        "@odata.type": n => { emailNotificationConfiguration.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Enrichment The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEnrichment(enrichment: Partial<Enrichment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { enrichment.backingStoreEnabled = true; },
        "impacts": n => { enrichment.impacts = n.getCollectionOfObjectValues<ResourceImpactSummary>(createResourceImpactSummaryFromDiscriminatorValue); },
        "@odata.type": n => { enrichment.odataType = n.getStringValue(); },
        "state": n => { enrichment.state = n.getEnumValue<EnrichmentState>(EnrichmentStateObject); },
        "supportingData": n => { enrichment.supportingData = n.getObjectValue<SupportingData>(createSupportingDataFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param GroupImpactSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGroupImpactSummary(groupImpactSummary: Partial<GroupImpactSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDirectoryObjectImpactSummary(groupImpactSummary),
    }
}
/**
 * The deserialization information for the current model
 * @param HealthMonitoringDictionary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoHealthMonitoringDictionary(healthMonitoringDictionary: Partial<HealthMonitoringDictionary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDictionary(healthMonitoringDictionary),
    }
}
/**
 * The deserialization information for the current model
 * @param HealthMonitoringRoot The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoHealthMonitoringRoot(healthMonitoringRoot: Partial<HealthMonitoringRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(healthMonitoringRoot),
    }
}
/**
 * The deserialization information for the current model
 * @param ResourceImpactSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoResourceImpactSummary(resourceImpactSummary: Partial<ResourceImpactSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { resourceImpactSummary.backingStoreEnabled = true; },
        "impactedCount": n => { resourceImpactSummary.impactedCount = n.getStringValue(); },
        "impactedCountLimitExceeded": n => { resourceImpactSummary.impactedCountLimitExceeded = n.getBooleanValue(); },
        "@odata.type": n => { resourceImpactSummary.odataType = n.getStringValue(); },
        "resourceType": n => { resourceImpactSummary.resourceType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ServicePrincipalImpactSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoServicePrincipalImpactSummary(servicePrincipalImpactSummary: Partial<ServicePrincipalImpactSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDirectoryObjectImpactSummary(servicePrincipalImpactSummary),
    }
}
/**
 * The deserialization information for the current model
 * @param Signals The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSignals(signals: Partial<Signals> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoHealthMonitoringDictionary(signals),
    }
}
/**
 * The deserialization information for the current model
 * @param SupportingData The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSupportingData(supportingData: Partial<SupportingData> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoHealthMonitoringDictionary(supportingData),
    }
}
/**
 * The deserialization information for the current model
 * @param UserImpactSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUserImpactSummary(userImpactSummary: Partial<UserImpactSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDirectoryObjectImpactSummary(userImpactSummary),
    }
}
export interface DeviceImpactSummary extends DirectoryObjectImpactSummary, Parsable {
}
export interface Dictionary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface DirectoryObjectImpactSummary extends Parsable, ResourceImpactSummary {
    /**
     * The resourceSampling property
     */
    resourceSampling?: DirectoryObject[] | null;
}
export interface Documentation extends HealthMonitoringDictionary, Parsable {
}
export interface EmailNotificationConfiguration extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The identifier of the group to send an email to. All group types with configured email addresses are supported.
     */
    groupId?: string | null;
    /**
     * Indicates whether email notifications are enabled on the alert type.
     */
    isEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface Enrichment extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * A collection of resource impact summaries that gives a high level view of the kind of resources that were impacted and to what degree.
     */
    impacts?: ResourceImpactSummary[] | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The state property
     */
    state?: EnrichmentState | null;
    /**
     * A collection of supportingData locations that can be queried for debugging the alert.
     */
    supportingData?: SupportingData | null;
}
export type EnrichmentState = (typeof EnrichmentStateObject)[keyof typeof EnrichmentStateObject];
export interface GroupImpactSummary extends DirectoryObjectImpactSummary, Parsable {
}
export interface HealthMonitoringDictionary extends Dictionary, Parsable {
}
export interface HealthMonitoringRoot extends Entity, Parsable {
}
export interface ResourceImpactSummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The number of resources impacted. The number could be an exhaustive count or a sampling count.
     */
    impactedCount?: string | null;
    /**
     * Indicates whether impactedCount is exhaustive or a sampling. When this value is true, the limit was exceeded and impactedCount represents a sampling; otherwise, impactedCount represents the true number of impacts.
     */
    impactedCountLimitExceeded?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The type of resource that was impacted. Examples include user, group, application, servicePrincipal, device.
     */
    resourceType?: string | null;
}
export type Scenario = (typeof ScenarioObject)[keyof typeof ScenarioObject];
/**
 * Serializes information the current object
 * @param Alert The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlert(writer: SerializationWriter, alert: Partial<Alert> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alert || isSerializingDerivedType) { return; }
    serializeEntity(writer, alert, isSerializingDerivedType)
    writer.writeEnumValue<AlertType>("alertType", alert.alertType);
    writer.writeEnumValue<Category>("category", alert.category);
    writer.writeDateValue("createdDateTime", alert.createdDateTime);
    writer.writeObjectValue<Documentation>("documentation", alert.documentation, serializeDocumentation);
    writer.writeObjectValue<Enrichment>("enrichment", alert.enrichment, serializeEnrichment);
    writer.writeEnumValue<Scenario>("scenario", alert.scenario);
    writer.writeObjectValue<Signals>("signals", alert.signals, serializeSignals);
    writer.writeEnumValue<AlertState>("state", alert.state);
}
/**
 * Serializes information the current object
 * @param AlertCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertCollectionResponse(writer: SerializationWriter, alertCollectionResponse: Partial<AlertCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, alertCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Alert>("value", alertCollectionResponse.value, serializeAlert);
}
/**
 * Serializes information the current object
 * @param AlertConfiguration The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertConfiguration(writer: SerializationWriter, alertConfiguration: Partial<AlertConfiguration> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertConfiguration || isSerializingDerivedType) { return; }
    serializeEntity(writer, alertConfiguration, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<EmailNotificationConfiguration>("emailNotificationConfigurations", alertConfiguration.emailNotificationConfigurations, serializeEmailNotificationConfiguration);
}
/**
 * Serializes information the current object
 * @param AlertConfigurationCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertConfigurationCollectionResponse(writer: SerializationWriter, alertConfigurationCollectionResponse: Partial<AlertConfigurationCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertConfigurationCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, alertConfigurationCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<AlertConfiguration>("value", alertConfigurationCollectionResponse.value, serializeAlertConfiguration);
}
/**
 * Serializes information the current object
 * @param ApplicationImpactSummary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeApplicationImpactSummary(writer: SerializationWriter, applicationImpactSummary: Partial<ApplicationImpactSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!applicationImpactSummary || isSerializingDerivedType) { return; }
    serializeDirectoryObjectImpactSummary(writer, applicationImpactSummary, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param DeviceImpactSummary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeviceImpactSummary(writer: SerializationWriter, deviceImpactSummary: Partial<DeviceImpactSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deviceImpactSummary || isSerializingDerivedType) { return; }
    serializeDirectoryObjectImpactSummary(writer, deviceImpactSummary, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param Dictionary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDictionary(writer: SerializationWriter, dictionary: Partial<Dictionary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!dictionary || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", dictionary.odataType);
    writer.writeAdditionalData(dictionary.additionalData);
    switch (dictionary.odataType) {
        case "#microsoft.graph.healthMonitoring.documentation":
            serializeDocumentation(writer, dictionary, true);
        break;
        case "#microsoft.graph.healthMonitoring.healthMonitoringDictionary":
            serializeHealthMonitoringDictionary(writer, dictionary, true);
        break;
        case "#microsoft.graph.healthMonitoring.signals":
            serializeSignals(writer, dictionary, true);
        break;
        case "#microsoft.graph.healthMonitoring.supportingData":
            serializeSupportingData(writer, dictionary, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param DirectoryObjectImpactSummary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDirectoryObjectImpactSummary(writer: SerializationWriter, directoryObjectImpactSummary: Partial<DirectoryObjectImpactSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!directoryObjectImpactSummary || isSerializingDerivedType) { return; }
    serializeResourceImpactSummary(writer, directoryObjectImpactSummary, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<DirectoryObject>("resourceSampling", directoryObjectImpactSummary.resourceSampling, serializeDirectoryObject);
    switch (directoryObjectImpactSummary.odataType) {
        case "#microsoft.graph.healthMonitoring.applicationImpactSummary":
            serializeApplicationImpactSummary(writer, directoryObjectImpactSummary, true);
        break;
        case "#microsoft.graph.healthMonitoring.deviceImpactSummary":
            serializeDeviceImpactSummary(writer, directoryObjectImpactSummary, true);
        break;
        case "#microsoft.graph.healthMonitoring.groupImpactSummary":
            serializeGroupImpactSummary(writer, directoryObjectImpactSummary, true);
        break;
        case "#microsoft.graph.healthMonitoring.servicePrincipalImpactSummary":
            serializeServicePrincipalImpactSummary(writer, directoryObjectImpactSummary, true);
        break;
        case "#microsoft.graph.healthMonitoring.userImpactSummary":
            serializeUserImpactSummary(writer, directoryObjectImpactSummary, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param Documentation The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDocumentation(writer: SerializationWriter, documentation: Partial<Documentation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!documentation || isSerializingDerivedType) { return; }
    serializeHealthMonitoringDictionary(writer, documentation, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param EmailNotificationConfiguration The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEmailNotificationConfiguration(writer: SerializationWriter, emailNotificationConfiguration: Partial<EmailNotificationConfiguration> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!emailNotificationConfiguration || isSerializingDerivedType) { return; }
    writer.writeStringValue("groupId", emailNotificationConfiguration.groupId);
    writer.writeBooleanValue("isEnabled", emailNotificationConfiguration.isEnabled);
    writer.writeStringValue("@odata.type", emailNotificationConfiguration.odataType);
    writer.writeAdditionalData(emailNotificationConfiguration.additionalData);
}
/**
 * Serializes information the current object
 * @param Enrichment The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEnrichment(writer: SerializationWriter, enrichment: Partial<Enrichment> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!enrichment || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<ResourceImpactSummary>("impacts", enrichment.impacts, serializeResourceImpactSummary);
    writer.writeStringValue("@odata.type", enrichment.odataType);
    writer.writeEnumValue<EnrichmentState>("state", enrichment.state);
    writer.writeObjectValue<SupportingData>("supportingData", enrichment.supportingData, serializeSupportingData);
    writer.writeAdditionalData(enrichment.additionalData);
}
/**
 * Serializes information the current object
 * @param GroupImpactSummary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGroupImpactSummary(writer: SerializationWriter, groupImpactSummary: Partial<GroupImpactSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!groupImpactSummary || isSerializingDerivedType) { return; }
    serializeDirectoryObjectImpactSummary(writer, groupImpactSummary, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param HealthMonitoringDictionary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeHealthMonitoringDictionary(writer: SerializationWriter, healthMonitoringDictionary: Partial<HealthMonitoringDictionary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!healthMonitoringDictionary || isSerializingDerivedType) { return; }
    serializeDictionary(writer, healthMonitoringDictionary, isSerializingDerivedType)
    switch (healthMonitoringDictionary.odataType) {
        case "#microsoft.graph.healthMonitoring.documentation":
            serializeDocumentation(writer, healthMonitoringDictionary, true);
        break;
        case "#microsoft.graph.healthMonitoring.signals":
            serializeSignals(writer, healthMonitoringDictionary, true);
        break;
        case "#microsoft.graph.healthMonitoring.supportingData":
            serializeSupportingData(writer, healthMonitoringDictionary, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param HealthMonitoringRoot The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeHealthMonitoringRoot(writer: SerializationWriter, healthMonitoringRoot: Partial<HealthMonitoringRoot> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!healthMonitoringRoot || isSerializingDerivedType) { return; }
    serializeEntity(writer, healthMonitoringRoot, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ResourceImpactSummary The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeResourceImpactSummary(writer: SerializationWriter, resourceImpactSummary: Partial<ResourceImpactSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!resourceImpactSummary || isSerializingDerivedType) { return; }
    writer.writeStringValue("impactedCount", resourceImpactSummary.impactedCount);
    writer.writeBooleanValue("impactedCountLimitExceeded", resourceImpactSummary.impactedCountLimitExceeded);
    writer.writeStringValue("@odata.type", resourceImpactSummary.odataType);
    writer.writeStringValue("resourceType", resourceImpactSummary.resourceType);
    writer.writeAdditionalData(resourceImpactSummary.additionalData);
    switch (resourceImpactSummary.odataType) {
        case "#microsoft.graph.healthMonitoring.applicationImpactSummary":
            serializeApplicationImpactSummary(writer, resourceImpactSummary, true);
        break;
        case "#microsoft.graph.healthMonitoring.deviceImpactSummary":
            serializeDeviceImpactSummary(writer, resourceImpactSummary, true);
        break;
        case "#microsoft.graph.healthMonitoring.directoryObjectImpactSummary":
            serializeDirectoryObjectImpactSummary(writer, resourceImpactSummary, true);
        break;
        case "#microsoft.graph.healthMonitoring.groupImpactSummary":
            serializeGroupImpactSummary(writer, resourceImpactSummary, true);
        break;
        case "#microsoft.graph.healthMonitoring.servicePrincipalImpactSummary":
            serializeServicePrincipalImpactSummary(writer, resourceImpactSummary, true);
        break;
        case "#microsoft.graph.healthMonitoring.userImpactSummary":
            serializeUserImpactSummary(writer, resourceImpactSummary, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ServicePrincipalImpactSummary The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeServicePrincipalImpactSummary(writer: SerializationWriter, servicePrincipalImpactSummary: Partial<ServicePrincipalImpactSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!servicePrincipalImpactSummary || isSerializingDerivedType) { return; }
    serializeDirectoryObjectImpactSummary(writer, servicePrincipalImpactSummary, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Signals The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSignals(writer: SerializationWriter, signals: Partial<Signals> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!signals || isSerializingDerivedType) { return; }
    serializeHealthMonitoringDictionary(writer, signals, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SupportingData The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSupportingData(writer: SerializationWriter, supportingData: Partial<SupportingData> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!supportingData || isSerializingDerivedType) { return; }
    serializeHealthMonitoringDictionary(writer, supportingData, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UserImpactSummary The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUserImpactSummary(writer: SerializationWriter, userImpactSummary: Partial<UserImpactSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!userImpactSummary || isSerializingDerivedType) { return; }
    serializeDirectoryObjectImpactSummary(writer, userImpactSummary, isSerializingDerivedType)
}
export interface ServicePrincipalImpactSummary extends DirectoryObjectImpactSummary, Parsable {
}
export interface Signals extends HealthMonitoringDictionary, Parsable {
}
export interface SupportingData extends HealthMonitoringDictionary, Parsable {
}
export interface UserImpactSummary extends DirectoryObjectImpactSummary, Parsable {
}
export const AlertStateObject = {
    Active: "active",
    Resolved: "resolved",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AlertTypeObject = {
    Unknown: "unknown",
    MfaSignInFailure: "mfaSignInFailure",
    ManagedDeviceSignInFailure: "managedDeviceSignInFailure",
    CompliantDeviceSignInFailure: "compliantDeviceSignInFailure",
    UnknownFutureValue: "unknownFutureValue",
    ConditionalAccessBlockedSignIn: "conditionalAccessBlockedSignIn",
    SamlSignInFailure: "samlSignInFailure",
} as const;
export const CategoryObject = {
    Unknown: "unknown",
    Authentication: "authentication",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EnrichmentStateObject = {
    None: "none",
    InProgress: "inProgress",
    Enriched: "enriched",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ScenarioObject = {
    Unknown: "unknown",
    Mfa: "mfa",
    Devices: "devices",
    UnknownFutureValue: "unknownFutureValue",
    ConditionalAccess: "conditionalAccess",
    Saml: "saml",
} as const;
/* tslint:enable */
/* eslint-enable */
