/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createDeviceFromDiscriminatorValue as I35341c37cb1156f9816804144a0da7ca28a5bc5a466a4a6c4dd18a73c9fef2f1, createServicePrincipalFromDiscriminatorValue, createUserFromDiscriminatorValue as I76468935476edf00ba62610ba93d13d7194a94fc3b9375d1eacaf60b72b6323e, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoDictionary, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeDevice as I93801fe1d0700e2dfbaabaac8a107eaad07c485b973484cdebd0254423e093c4, serializeDictionary, serializeEntity, serializeServicePrincipal, serializeUser as I52fb59bcf4aad10419ab5ac07e13466b759ff69b47806ecf063de624d08c4da3, type BaseCollectionPaginationCountResponse, type Device as I353170b9ab043a51be0a29bf9ffeadaa40f51ff6511c066ae82d223c77decf60, type Dictionary, type Entity, type ServicePrincipal, type User as I4bfcbb20fa90605575bab96c7572912b314f024f9b0899d027a654508ef72465 } from '../index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export type AccessType = (typeof AccessTypeObject)[keyof typeof AccessTypeObject];
export interface Alert extends Entity, Parsable {
    /**
     * List of possible action items to take based on the alert (if applicable).
     */
    actions?: AlertAction[] | null;
    /**
     * The alertType property
     */
    alertType?: AlertType | null;
    /**
     * Categories associated with the alert.
     */
    categories?: IntentCategory[] | null;
    /**
     * Component name related to the alert.
     */
    componentName?: string | null;
    /**
     * The time the alert was created in the system. Required.
     */
    creationDateTime?: Date | null;
    /**
     * Text description explaining the alert.
     */
    description?: string | null;
    /**
     * Alert detection technology.
     */
    detectionTechnology?: string | null;
    /**
     * The display name of the alert. Required.
     */
    displayName?: string | null;
    /**
     * Extended properties for the alert.
     */
    extendedProperties?: ExtendedProperties | null;
    /**
     * The time of the first activity related to the alert.
     */
    firstActivityDateTime?: Date | null;
    /**
     * Indicates if the alert is a preview.
     */
    isPreview?: boolean | null;
    /**
     * The time of the last activity related to the alert.
     */
    lastActivityDateTime?: Date | null;
    /**
     * The filtering policy associated with the alert. This relationship allows you to retrieve or manage the filtering policy that triggered or is related to the alert instance.
     */
    policy?: FilteringPolicy | null;
    /**
     * The name of the product that raised the alert.
     */
    productName?: string | null;
    /**
     * List of related resources to the alert (if applicable).
     */
    relatedResources?: RelatedResource[] | null;
    /**
     * The severity property
     */
    severity?: AlertSeverity | null;
    /**
     * Sub-techniques associated with the alert.
     */
    subTechniques?: string[] | null;
    /**
     * Techniques associated with the alert.
     */
    techniques?: string[] | null;
    /**
     * The name of the vendor that raised the alert.
     */
    vendorName?: string | null;
}
export interface AlertAction extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * A link to more information or to perform the action (if applicable).
     */
    actionLink?: string | null;
    /**
     * Text describing the action. Required.
     */
    actionText?: string | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface AlertCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Alert[] | null;
}
export interface AlertFrequencyPoint extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Total number of high alert severity. Required.
     */
    highSeverityCount?: number | null;
    /**
     * Total number of informational alert severity. Required.
     */
    informationalSeverityCount?: number | null;
    /**
     * Total number of low alert severity. Required.
     */
    lowSeverityCount?: number | null;
    /**
     * Total number of medium alert severity. Required.
     */
    mediumSeverityCount?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The time bucket for counting the alert severities. Required.
     */
    timeStampDateTime?: Date | null;
}
export type AlertSeverity = (typeof AlertSeverityObject)[keyof typeof AlertSeverityObject];
export interface AlertSeveritySummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Total number of alerts with this specific severity. Required.
     */
    count?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The severity property
     */
    severity?: AlertSeverity | null;
}
export interface AlertSummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The alertType property
     */
    alertType?: AlertType | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Total number of alerts with this specific severity and type. Required.
     */
    count?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The severity property
     */
    severity?: AlertSeverity | null;
}
export type AlertType = (typeof AlertTypeObject)[keyof typeof AlertTypeObject];
export type Algorithm = (typeof AlgorithmObject)[keyof typeof AlgorithmObject];
export interface ApplicationSnapshot extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The unique identifier of the application accessed during the transaction.
     */
    appId?: string | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface AssociatedBranch extends Association, Parsable {
    /**
     * Identifier for the branch.
     */
    branchId?: string | null;
}
export interface Association extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export type BandwidthCapacityInMbps = (typeof BandwidthCapacityInMbpsObject)[keyof typeof BandwidthCapacityInMbpsObject];
export interface BgpConfiguration extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Specifies the ASN of the BGP.
     */
    asn?: number | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Specifies the BGP IP address.
     */
    ipAddress?: string | null;
    /**
     * Specifies the BGP IP address of peer (Microsoft, in this case).
     */
    localIpAddress?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Specifies the BGP IP address of customer's on-premise VPN router configuration.
     */
    peerIpAddress?: string | null;
}
export interface BranchConnectivityConfiguration extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Unique identifier or a specific reference assigned to a branchSite. Key.
     */
    branchId?: string | null;
    /**
     * Display name assigned to a branchSite.
     */
    branchName?: string | null;
    /**
     * List of connectivity configurations for deviceLink objects.
     */
    links?: ConnectivityConfigurationLink[] | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface BranchSite extends Entity, Parsable {
    /**
     * Determines the maximum allowed Mbps (megabits per second) bandwidth from a branch site. The possible values are:250,500,750,1000.
     */
    bandwidthCapacity?: number | null;
    /**
     * Specifies the connectivity details of all device links associated with a branch.
     */
    connectivityConfiguration?: BranchConnectivityConfiguration | null;
    /**
     * Determines the branch site status. The possible values are: pending, connected, inactive, error.
     */
    connectivityState?: ConnectivityState | null;
    /**
     * The branch site is created in the specified country. DO NOT USE.
     */
    country?: string | null;
    /**
     * Each unique CPE device associated with a branch is specified. Supports $expand.
     */
    deviceLinks?: DeviceLink[] | null;
    /**
     * Each forwarding profile associated with a branch site is specified. Supports $expand.
     */
    forwardingProfiles?: ForwardingProfile[] | null;
    /**
     * last modified time.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * Name.
     */
    name?: string | null;
    /**
     * The region property
     */
    region?: Region | null;
    /**
     * The branch version.
     */
    version?: string | null;
}
export interface BranchSiteCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: BranchSite[] | null;
}
export type ClientFallbackAction = (typeof ClientFallbackActionObject)[keyof typeof ClientFallbackActionObject];
export interface ConditionalAccessPolicy extends Entity, Parsable {
    /**
     * Indicates the date and time the conditional access policy was created.
     */
    createdDateTime?: Date | null;
    /**
     * Provides a summary of the conditional access policy.
     */
    description?: string | null;
    /**
     * Represents the human-readable name or title assigned to the conditional access policy.
     */
    displayName?: string | null;
    /**
     * Indicates the date and time when the conditional access policy was last modified.
     */
    modifiedDateTime?: Date | null;
}
export interface ConditionalAccessPolicyCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ConditionalAccessPolicy[] | null;
}
export interface ConditionalAccessSettings extends Entity, Parsable {
    /**
     * The signalingStatus property
     */
    signalingStatus?: Status | null;
}
export interface Connection extends Entity, Parsable {
    /**
     * The version of the client that initiated the connection.
     */
    agentVersion?: string | null;
    /**
     * appId (or client ID) of the destination Microsoft Entra application.
     */
    applicationSnapshot?: ApplicationSnapshot | null;
    /**
     * The time the connection was created.
     */
    createdDateTime?: Date | null;
    /**
     * The destination FQDN of the connection.
     */
    destinationFqdn?: string | null;
    /**
     * The destination IP of the connection.
     */
    destinationIp?: string | null;
    /**
     * The destination port of the connection.
     */
    destinationPort?: number | null;
    /**
     * The category of the device. The possible values are: client, branch, unknownFutureValue, remoteNetwork. Use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: remoteNetwork.
     */
    deviceCategory?: DeviceCategory | null;
    /**
     * The DeviceID.
     */
    deviceId?: string | null;
    /**
     * The device operating system type.
     */
    deviceOperatingSystem?: string | null;
    /**
     * The device operating system version.
     */
    deviceOperatingSystemVersion?: string | null;
    /**
     * The time the connection was terminated.
     */
    endDateTime?: Date | null;
    /**
     * The process initiating the traffic connection.
     */
    initiatingProcessName?: string | null;
    /**
     * When the connection was last updated.
     */
    lastUpdateDateTime?: Date | null;
    /**
     * The network protocol of the connection. The possible values are: ip, icmp, igmp, ggp, ipv4, tcp, pup, udp, idp, ipv6, ipv6RoutingHeader, ipv6FragmentHeader, ipSecEncapsulatingSecurityPayload, ipSecAuthenticationHeader, icmpV6, ipv6NoNextHeader, ipv6DestinationOptions, nd, raw, ipx, spx, spxII, unknownFutureValue.
     */
    networkProtocol?: NetworkingProtocol | null;
    /**
     * The Point-of-Presence processing region of the traffic.
     */
    popProcessingRegion?: string | null;
    /**
     * Private access details.
     */
    privateAccessDetails?: PrivateAccessDetails | null;
    /**
     * Accumulative bytes received.
     */
    receivedBytes?: number | null;
    /**
     * Accumulative bytes sent.
     */
    sentBytes?: number | null;
    /**
     * The source IP of the connection.
     */
    sourceIp?: string | null;
    /**
     * The source port of the connection.
     */
    sourcePort?: number | null;
    /**
     * Status of the connection. The possible values are: open, active, closed, unknownFutureValue.
     */
    status?: ConnectionStatus | null;
    /**
     * The ID of the tenant where the connection was initiated.
     */
    tenantId?: string | null;
    /**
     * The trafficType property
     */
    trafficType?: TrafficType | null;
    /**
     * The number of blocked transactions belonging to the connection.
     */
    transactionBlockCount?: number | null;
    /**
     * The number of transactions belonging to the connection.
     */
    transactionCount?: number | null;
    /**
     * The transport protocol of the connection. The possible values are: ip, icmp, igmp, ggp, ipv4, tcp, pup, udp, idp, ipv6, ipv6RoutingHeader, ipv6FragmentHeader, ipSecEncapsulatingSecurityPayload, ipSecAuthenticationHeader, icmpV6, ipv6NoNextHeader, ipv6DestinationOptions, nd, raw, ipx, spx, spxII, unknownFutureValue.
     */
    transportProtocol?: NetworkingProtocol | null;
    /**
     * The user ID.
     */
    userId?: string | null;
    /**
     * The principal name of the user.
     */
    userPrincipalName?: string | null;
}
export interface ConnectionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Connection[] | null;
}
export type ConnectionStatus = (typeof ConnectionStatusObject)[keyof typeof ConnectionStatusObject];
export interface ConnectionSummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Total number of connections for the specified traffic type.
     */
    totalCount?: number | null;
    /**
     * The trafficType property
     */
    trafficType?: TrafficType | null;
}
export interface Connectivity extends Entity, Parsable {
    /**
     * The locations for connectivity. DEPRECATED AND TO BE RETIRED SOON. Use the remoteNetwork relationship and its associated APIs instead.
     */
    branches?: BranchSite[] | null;
    /**
     * The locations, such as branches, that are connected to Global Secure Access services through an IPsec tunnel.
     */
    remoteNetworks?: RemoteNetwork[] | null;
    /**
     * The URL category.
     */
    webCategories?: WebCategory[] | null;
}
export interface ConnectivityConfigurationLink extends Entity, Parsable {
    /**
     * Specifies the name of the link.
     */
    displayName?: string | null;
    /**
     * Specifies Microsoft's end of the tunnel configuration for a device link.
     */
    localConfigurations?: LocalConnectivityConfiguration[] | null;
    /**
     * The peerConfiguration property
     */
    peerConfiguration?: PeerConnectivityConfiguration | null;
}
export interface ConnectivityConfigurationLinkCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ConnectivityConfigurationLink[] | null;
}
export type ConnectivityState = (typeof ConnectivityStateObject)[keyof typeof ConnectivityStateObject];
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertAction}
 */
// @ts-ignore
export function createAlertActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertCollectionResponse}
 */
// @ts-ignore
export function createAlertCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertFrequencyPoint}
 */
// @ts-ignore
export function createAlertFrequencyPointFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertFrequencyPoint;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Alert}
 */
// @ts-ignore
export function createAlertFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlert;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertSeveritySummary}
 */
// @ts-ignore
export function createAlertSeveritySummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertSeveritySummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertSummary}
 */
// @ts-ignore
export function createAlertSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ApplicationSnapshot}
 */
// @ts-ignore
export function createApplicationSnapshotFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoApplicationSnapshot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AssociatedBranch}
 */
// @ts-ignore
export function createAssociatedBranchFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAssociatedBranch;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Association}
 */
// @ts-ignore
export function createAssociationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.associatedBranch":
                    return deserializeIntoAssociatedBranch;
            }
        }
    }
    return deserializeIntoAssociation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BgpConfiguration}
 */
// @ts-ignore
export function createBgpConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBgpConfiguration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BranchConnectivityConfiguration}
 */
// @ts-ignore
export function createBranchConnectivityConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBranchConnectivityConfiguration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BranchSiteCollectionResponse}
 */
// @ts-ignore
export function createBranchSiteCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBranchSiteCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BranchSite}
 */
// @ts-ignore
export function createBranchSiteFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBranchSite;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ConditionalAccessPolicyCollectionResponse}
 */
// @ts-ignore
export function createConditionalAccessPolicyCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConditionalAccessPolicyCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ConditionalAccessPolicy}
 */
// @ts-ignore
export function createConditionalAccessPolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConditionalAccessPolicy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ConditionalAccessSettings}
 */
// @ts-ignore
export function createConditionalAccessSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConditionalAccessSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ConnectionCollectionResponse}
 */
// @ts-ignore
export function createConnectionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConnectionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Connection}
 */
// @ts-ignore
export function createConnectionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConnection;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ConnectionSummary}
 */
// @ts-ignore
export function createConnectionSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConnectionSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ConnectivityConfigurationLinkCollectionResponse}
 */
// @ts-ignore
export function createConnectivityConfigurationLinkCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConnectivityConfigurationLinkCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ConnectivityConfigurationLink}
 */
// @ts-ignore
export function createConnectivityConfigurationLinkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConnectivityConfigurationLink;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Connectivity}
 */
// @ts-ignore
export function createConnectivityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConnectivity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CrossTenantAccess}
 */
// @ts-ignore
export function createCrossTenantAccessFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCrossTenantAccess;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CrossTenantAccessSettings}
 */
// @ts-ignore
export function createCrossTenantAccessSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCrossTenantAccessSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CrossTenantSummary}
 */
// @ts-ignore
export function createCrossTenantSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCrossTenantSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Destination}
 */
// @ts-ignore
export function createDestinationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDestination;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DestinationSummary}
 */
// @ts-ignore
export function createDestinationSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDestinationSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Device}
 */
// @ts-ignore
export function createDeviceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDevice;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeviceLinkCollectionResponse}
 */
// @ts-ignore
export function createDeviceLinkCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeviceLinkCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeviceLink}
 */
// @ts-ignore
export function createDeviceLinkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeviceLink;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeviceUsageSummary}
 */
// @ts-ignore
export function createDeviceUsageSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeviceUsageSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DiscoveredApplicationSegmentReport}
 */
// @ts-ignore
export function createDiscoveredApplicationSegmentReportFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDiscoveredApplicationSegmentReport;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EntitiesSummary}
 */
// @ts-ignore
export function createEntitiesSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEntitiesSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExtendedProperties}
 */
// @ts-ignore
export function createExtendedPropertiesFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExtendedProperties;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalCertificateAuthorityCertificateCollectionResponse}
 */
// @ts-ignore
export function createExternalCertificateAuthorityCertificateCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternalCertificateAuthorityCertificateCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalCertificateAuthorityCertificate}
 */
// @ts-ignore
export function createExternalCertificateAuthorityCertificateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternalCertificateAuthorityCertificate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilteringPolicyCollectionResponse}
 */
// @ts-ignore
export function createFilteringPolicyCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilteringPolicyCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilteringPolicy}
 */
// @ts-ignore
export function createFilteringPolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilteringPolicy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilteringPolicyLink}
 */
// @ts-ignore
export function createFilteringPolicyLinkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilteringPolicyLink;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilteringProfileCollectionResponse}
 */
// @ts-ignore
export function createFilteringProfileCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilteringProfileCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilteringProfile}
 */
// @ts-ignore
export function createFilteringProfileFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFilteringProfile;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FilteringRule}
 */
// @ts-ignore
export function createFilteringRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.fqdnFilteringRule":
                    return deserializeIntoFqdnFilteringRule;
                case "#microsoft.graph.networkaccess.webCategoryFilteringRule":
                    return deserializeIntoWebCategoryFilteringRule;
            }
        }
    }
    return deserializeIntoFilteringRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ForwardingOptions}
 */
// @ts-ignore
export function createForwardingOptionsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoForwardingOptions;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ForwardingPolicyCollectionResponse}
 */
// @ts-ignore
export function createForwardingPolicyCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoForwardingPolicyCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ForwardingPolicy}
 */
// @ts-ignore
export function createForwardingPolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoForwardingPolicy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ForwardingPolicyLink}
 */
// @ts-ignore
export function createForwardingPolicyLinkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoForwardingPolicyLink;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ForwardingProfileCollectionResponse}
 */
// @ts-ignore
export function createForwardingProfileCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoForwardingProfileCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ForwardingProfile}
 */
// @ts-ignore
export function createForwardingProfileFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoForwardingProfile;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ForwardingRule}
 */
// @ts-ignore
export function createForwardingRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.internetAccessForwardingRule":
                    return deserializeIntoInternetAccessForwardingRule;
                case "#microsoft.graph.networkaccess.m365ForwardingRule":
                    return deserializeIntoM365ForwardingRule;
                case "#microsoft.graph.networkaccess.privateAccessForwardingRule":
                    return deserializeIntoPrivateAccessForwardingRule;
            }
        }
    }
    return deserializeIntoForwardingRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FqdnFilteringRule}
 */
// @ts-ignore
export function createFqdnFilteringRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFqdnFilteringRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Fqdn}
 */
// @ts-ignore
export function createFqdnFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFqdn;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Headers}
 */
// @ts-ignore
export function createHeadersFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHeaders;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {InternetAccessForwardingRule}
 */
// @ts-ignore
export function createInternetAccessForwardingRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoInternetAccessForwardingRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IpAddress}
 */
// @ts-ignore
export function createIpAddressFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIpAddress;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IpRange}
 */
// @ts-ignore
export function createIpRangeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIpRange;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IpSubnet}
 */
// @ts-ignore
export function createIpSubnetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIpSubnet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LocalConnectivityConfiguration}
 */
// @ts-ignore
export function createLocalConnectivityConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLocalConnectivityConfiguration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Logs}
 */
// @ts-ignore
export function createLogsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLogs;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {M365ForwardingRule}
 */
// @ts-ignore
export function createM365ForwardingRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoM365ForwardingRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NetworkAccessRoot}
 */
// @ts-ignore
export function createNetworkAccessRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNetworkAccessRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NetworkAccessTrafficCollectionResponse}
 */
// @ts-ignore
export function createNetworkAccessTrafficCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNetworkAccessTrafficCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NetworkAccessTraffic}
 */
// @ts-ignore
export function createNetworkAccessTrafficFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNetworkAccessTraffic;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PeerConnectivityConfiguration}
 */
// @ts-ignore
export function createPeerConnectivityConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPeerConnectivityConfiguration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Policy}
 */
// @ts-ignore
export function createPolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.filteringPolicy":
                    return deserializeIntoFilteringPolicy;
                case "#microsoft.graph.networkaccess.forwardingPolicy":
                    return deserializeIntoForwardingPolicy;
                case "#microsoft.graph.networkaccess.threatIntelligencePolicy":
                    return deserializeIntoThreatIntelligencePolicy;
                case "#microsoft.graph.networkaccess.tlsInspectionPolicy":
                    return deserializeIntoTlsInspectionPolicy;
            }
        }
    }
    return deserializeIntoPolicy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PolicyLinkCollectionResponse}
 */
// @ts-ignore
export function createPolicyLinkCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPolicyLinkCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PolicyLink}
 */
// @ts-ignore
export function createPolicyLinkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.filteringPolicyLink":
                    return deserializeIntoFilteringPolicyLink;
                case "#microsoft.graph.networkaccess.forwardingPolicyLink":
                    return deserializeIntoForwardingPolicyLink;
                case "#microsoft.graph.networkaccess.threatIntelligencePolicyLink":
                    return deserializeIntoThreatIntelligencePolicyLink;
                case "#microsoft.graph.networkaccess.tlsInspectionPolicyLink":
                    return deserializeIntoTlsInspectionPolicyLink;
            }
        }
    }
    return deserializeIntoPolicyLink;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PolicyRuleCollectionResponse}
 */
// @ts-ignore
export function createPolicyRuleCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPolicyRuleCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PolicyRuleDelta}
 */
// @ts-ignore
export function createPolicyRuleDeltaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPolicyRuleDelta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PolicyRule}
 */
// @ts-ignore
export function createPolicyRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.filteringRule":
                    return deserializeIntoFilteringRule;
                case "#microsoft.graph.networkaccess.forwardingRule":
                    return deserializeIntoForwardingRule;
                case "#microsoft.graph.networkaccess.fqdnFilteringRule":
                    return deserializeIntoFqdnFilteringRule;
                case "#microsoft.graph.networkaccess.internetAccessForwardingRule":
                    return deserializeIntoInternetAccessForwardingRule;
                case "#microsoft.graph.networkaccess.m365ForwardingRule":
                    return deserializeIntoM365ForwardingRule;
                case "#microsoft.graph.networkaccess.privateAccessForwardingRule":
                    return deserializeIntoPrivateAccessForwardingRule;
                case "#microsoft.graph.networkaccess.threatIntelligenceRule":
                    return deserializeIntoThreatIntelligenceRule;
                case "#microsoft.graph.networkaccess.tlsInspectionRule":
                    return deserializeIntoTlsInspectionRule;
                case "#microsoft.graph.networkaccess.webCategoryFilteringRule":
                    return deserializeIntoWebCategoryFilteringRule;
            }
        }
    }
    return deserializeIntoPolicyRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PrivateAccessDetails}
 */
// @ts-ignore
export function createPrivateAccessDetailsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPrivateAccessDetails;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PrivateAccessForwardingRule}
 */
// @ts-ignore
export function createPrivateAccessForwardingRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPrivateAccessForwardingRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Profile}
 */
// @ts-ignore
export function createProfileFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.filteringProfile":
                    return deserializeIntoFilteringProfile;
                case "#microsoft.graph.networkaccess.forwardingProfile":
                    return deserializeIntoForwardingProfile;
            }
        }
    }
    return deserializeIntoProfile;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RedundancyConfiguration}
 */
// @ts-ignore
export function createRedundancyConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRedundancyConfiguration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedDestination}
 */
// @ts-ignore
export function createRelatedDestinationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedDestination;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedDevice}
 */
// @ts-ignore
export function createRelatedDeviceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedDevice;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedFile}
 */
// @ts-ignore
export function createRelatedFileFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedFile;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedFileHash}
 */
// @ts-ignore
export function createRelatedFileHashFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedFileHash;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedMalware}
 */
// @ts-ignore
export function createRelatedMalwareFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedMalware;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedRemoteNetwork}
 */
// @ts-ignore
export function createRelatedRemoteNetworkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedRemoteNetwork;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedResource}
 */
// @ts-ignore
export function createRelatedResourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.relatedDestination":
                    return deserializeIntoRelatedDestination;
                case "#microsoft.graph.networkaccess.relatedDevice":
                    return deserializeIntoRelatedDevice;
                case "#microsoft.graph.networkaccess.relatedFile":
                    return deserializeIntoRelatedFile;
                case "#microsoft.graph.networkaccess.relatedFileHash":
                    return deserializeIntoRelatedFileHash;
                case "#microsoft.graph.networkaccess.relatedMalware":
                    return deserializeIntoRelatedMalware;
                case "#microsoft.graph.networkaccess.relatedRemoteNetwork":
                    return deserializeIntoRelatedRemoteNetwork;
                case "#microsoft.graph.networkaccess.relatedTenant":
                    return deserializeIntoRelatedTenant;
                case "#microsoft.graph.networkaccess.relatedThreatIntelligence":
                    return deserializeIntoRelatedThreatIntelligence;
                case "#microsoft.graph.networkaccess.relatedToken":
                    return deserializeIntoRelatedToken;
                case "#microsoft.graph.networkaccess.relatedTransaction":
                    return deserializeIntoRelatedTransaction;
                case "#microsoft.graph.networkaccess.relatedUrl":
                    return deserializeIntoRelatedUrl;
                case "#microsoft.graph.networkaccess.relatedUser":
                    return deserializeIntoRelatedUser;
                case "#microsoft.graph.networkaccess.relatedWebCategory":
                    return deserializeIntoRelatedWebCategory;
            }
        }
    }
    return deserializeIntoRelatedResource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedTenant}
 */
// @ts-ignore
export function createRelatedTenantFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedTenant;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedThreatIntelligence}
 */
// @ts-ignore
export function createRelatedThreatIntelligenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedThreatIntelligence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedToken}
 */
// @ts-ignore
export function createRelatedTokenFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedToken;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedTransaction}
 */
// @ts-ignore
export function createRelatedTransactionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedTransaction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedUrl}
 */
// @ts-ignore
export function createRelatedUrlFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedUrl;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedUser}
 */
// @ts-ignore
export function createRelatedUserFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedUser;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelatedWebCategory}
 */
// @ts-ignore
export function createRelatedWebCategoryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelatedWebCategory;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RemoteNetworkCollectionResponse}
 */
// @ts-ignore
export function createRemoteNetworkCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRemoteNetworkCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RemoteNetworkConnectivityConfiguration}
 */
// @ts-ignore
export function createRemoteNetworkConnectivityConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRemoteNetworkConnectivityConfiguration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RemoteNetwork}
 */
// @ts-ignore
export function createRemoteNetworkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRemoteNetwork;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RemoteNetworkHealthEventCollectionResponse}
 */
// @ts-ignore
export function createRemoteNetworkHealthEventCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRemoteNetworkHealthEventCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RemoteNetworkHealthEvent}
 */
// @ts-ignore
export function createRemoteNetworkHealthEventFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRemoteNetworkHealthEvent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Reports}
 */
// @ts-ignore
export function createReportsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoReports;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RuleDestination}
 */
// @ts-ignore
export function createRuleDestinationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.fqdn":
                    return deserializeIntoFqdn;
                case "#microsoft.graph.networkaccess.ipAddress":
                    return deserializeIntoIpAddress;
                case "#microsoft.graph.networkaccess.ipRange":
                    return deserializeIntoIpRange;
                case "#microsoft.graph.networkaccess.ipSubnet":
                    return deserializeIntoIpSubnet;
                case "#microsoft.graph.networkaccess.url":
                    return deserializeIntoUrl;
                case "#microsoft.graph.networkaccess.webCategory":
                    return deserializeIntoWebCategory;
            }
        }
    }
    return deserializeIntoRuleDestination;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Settings}
 */
// @ts-ignore
export function createSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TenantStatus}
 */
// @ts-ignore
export function createTenantStatusFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTenantStatus;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThirdPartyTokenDetails}
 */
// @ts-ignore
export function createThirdPartyTokenDetailsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThirdPartyTokenDetails;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatIntelligenceDestination}
 */
// @ts-ignore
export function createThreatIntelligenceDestinationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.threatIntelligenceFqdnDestination":
                    return deserializeIntoThreatIntelligenceFqdnDestination;
            }
        }
    }
    return deserializeIntoThreatIntelligenceDestination;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatIntelligenceFqdnDestination}
 */
// @ts-ignore
export function createThreatIntelligenceFqdnDestinationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThreatIntelligenceFqdnDestination;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatIntelligenceMatchingConditions}
 */
// @ts-ignore
export function createThreatIntelligenceMatchingConditionsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThreatIntelligenceMatchingConditions;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatIntelligencePolicyCollectionResponse}
 */
// @ts-ignore
export function createThreatIntelligencePolicyCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThreatIntelligencePolicyCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatIntelligencePolicy}
 */
// @ts-ignore
export function createThreatIntelligencePolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThreatIntelligencePolicy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatIntelligencePolicyLink}
 */
// @ts-ignore
export function createThreatIntelligencePolicyLinkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThreatIntelligencePolicyLink;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatIntelligencePolicySettings}
 */
// @ts-ignore
export function createThreatIntelligencePolicySettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThreatIntelligencePolicySettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatIntelligenceRule}
 */
// @ts-ignore
export function createThreatIntelligenceRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThreatIntelligenceRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatIntelligenceRuleSettings}
 */
// @ts-ignore
export function createThreatIntelligenceRuleSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThreatIntelligenceRuleSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TlsInspectionDestination}
 */
// @ts-ignore
export function createTlsInspectionDestinationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.tlsInspectionFqdnDestination":
                    return deserializeIntoTlsInspectionFqdnDestination;
                case "#microsoft.graph.networkaccess.tlsInspectionWebCategoryDestination":
                    return deserializeIntoTlsInspectionWebCategoryDestination;
            }
        }
    }
    return deserializeIntoTlsInspectionDestination;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TlsInspectionFqdnDestination}
 */
// @ts-ignore
export function createTlsInspectionFqdnDestinationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTlsInspectionFqdnDestination;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TlsInspectionMatchingConditions}
 */
// @ts-ignore
export function createTlsInspectionMatchingConditionsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTlsInspectionMatchingConditions;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TlsInspectionPolicyCollectionResponse}
 */
// @ts-ignore
export function createTlsInspectionPolicyCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTlsInspectionPolicyCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TlsInspectionPolicy}
 */
// @ts-ignore
export function createTlsInspectionPolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTlsInspectionPolicy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TlsInspectionPolicyLink}
 */
// @ts-ignore
export function createTlsInspectionPolicyLinkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTlsInspectionPolicyLink;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TlsInspectionPolicySettings}
 */
// @ts-ignore
export function createTlsInspectionPolicySettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTlsInspectionPolicySettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TlsInspectionRule}
 */
// @ts-ignore
export function createTlsInspectionRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTlsInspectionRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TlsInspectionRuleSettings}
 */
// @ts-ignore
export function createTlsInspectionRuleSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTlsInspectionRuleSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TlsInspectionWebCategoryDestination}
 */
// @ts-ignore
export function createTlsInspectionWebCategoryDestinationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTlsInspectionWebCategoryDestination;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TlsTermination}
 */
// @ts-ignore
export function createTlsTerminationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTlsTermination;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TransactionSummary}
 */
// @ts-ignore
export function createTransactionSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTransactionSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TunnelConfiguration}
 */
// @ts-ignore
export function createTunnelConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.networkaccess.tunnelConfigurationIKEv2Custom":
                    return deserializeIntoTunnelConfigurationIKEv2Custom;
                case "#microsoft.graph.networkaccess.tunnelConfigurationIKEv2Default":
                    return deserializeIntoTunnelConfigurationIKEv2Default;
            }
        }
    }
    return deserializeIntoTunnelConfiguration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TunnelConfigurationIKEv2Custom}
 */
// @ts-ignore
export function createTunnelConfigurationIKEv2CustomFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTunnelConfigurationIKEv2Custom;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TunnelConfigurationIKEv2Default}
 */
// @ts-ignore
export function createTunnelConfigurationIKEv2DefaultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTunnelConfigurationIKEv2Default;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Url}
 */
// @ts-ignore
export function createUrlFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUrl;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UsageProfilingPoint}
 */
// @ts-ignore
export function createUsageProfilingPointFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUsageProfilingPoint;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {User}
 */
// @ts-ignore
export function createUserFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUser;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ValidityDate}
 */
// @ts-ignore
export function createValidityDateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoValidityDate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WebCategoriesSummary}
 */
// @ts-ignore
export function createWebCategoriesSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWebCategoriesSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WebCategoryFilteringRule}
 */
// @ts-ignore
export function createWebCategoryFilteringRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWebCategoryFilteringRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WebCategory}
 */
// @ts-ignore
export function createWebCategoryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWebCategory;
}
export interface CrossTenantAccess extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The number of devices that accessed the external tenant.
     */
    deviceCount?: number | null;
    /**
     * The timestamp of the most recent access to the external tenant.
     */
    lastAccessDateTime?: Date | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The tenant ID of the external tenant.
     */
    resourceTenantId?: string | null;
    /**
     * The name of the external tenant.
     */
    resourceTenantName?: string | null;
    /**
     * The domain of the external tenant.
     */
    resourceTenantPrimaryDomain?: string | null;
    /**
     * The usageStatus property
     */
    usageStatus?: UsageStatus | null;
    /**
     * The number of users that accessed the external tenant.
     */
    userCount?: number | null;
}
export interface CrossTenantAccessSettings extends Entity, Parsable {
    /**
     * The networkPacketTaggingStatus property
     */
    networkPacketTaggingStatus?: Status | null;
}
export interface CrossTenantSummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The total number of authentication sessions between startDateTime and endDateTime.
     */
    authTransactionCount?: number | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The number of unique devices that performed cross-tenant access.
     */
    deviceCount?: number | null;
    /**
     * The number of unique tenants that were accessed between endDateTime and discoveryPivotDateTime, but weren't accessed between discoveryPivotDateTime and startDateTime.
     */
    newTenantCount?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The number of tenants that are rarely used.
     */
    rarelyUsedTenantCount?: number | null;
    /**
     * The number of unique tenants that were accessed, not including the device's tenant.
     */
    tenantCount?: number | null;
    /**
     * The number of unique users that performed cross-tenant access.
     */
    userCount?: number | null;
}
/**
 * The deserialization information for the current model
 * @param Alert The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlert(alert: Partial<Alert> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(alert),
        "actions": n => { alert.actions = n.getCollectionOfObjectValues<AlertAction>(createAlertActionFromDiscriminatorValue); },
        "alertType": n => { alert.alertType = n.getEnumValue<AlertType>(AlertTypeObject); },
        "categories": n => { alert.categories = n.getCollectionOfEnumValues<IntentCategory>(IntentCategoryObject); },
        "componentName": n => { alert.componentName = n.getStringValue(); },
        "creationDateTime": n => { alert.creationDateTime = n.getDateValue(); },
        "description": n => { alert.description = n.getStringValue(); },
        "detectionTechnology": n => { alert.detectionTechnology = n.getStringValue(); },
        "displayName": n => { alert.displayName = n.getStringValue(); },
        "extendedProperties": n => { alert.extendedProperties = n.getObjectValue<ExtendedProperties>(createExtendedPropertiesFromDiscriminatorValue); },
        "firstActivityDateTime": n => { alert.firstActivityDateTime = n.getDateValue(); },
        "isPreview": n => { alert.isPreview = n.getBooleanValue(); },
        "lastActivityDateTime": n => { alert.lastActivityDateTime = n.getDateValue(); },
        "policy": n => { alert.policy = n.getObjectValue<FilteringPolicy>(createFilteringPolicyFromDiscriminatorValue); },
        "productName": n => { alert.productName = n.getStringValue(); },
        "relatedResources": n => { alert.relatedResources = n.getCollectionOfObjectValues<RelatedResource>(createRelatedResourceFromDiscriminatorValue); },
        "severity": n => { alert.severity = n.getEnumValue<AlertSeverity>(AlertSeverityObject); },
        "subTechniques": n => { alert.subTechniques = n.getCollectionOfPrimitiveValues<string>(); },
        "techniques": n => { alert.techniques = n.getCollectionOfPrimitiveValues<string>(); },
        "vendorName": n => { alert.vendorName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertAction The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertAction(alertAction: Partial<AlertAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "actionLink": n => { alertAction.actionLink = n.getStringValue(); },
        "actionText": n => { alertAction.actionText = n.getStringValue(); },
        "backingStoreEnabled": n => { alertAction.backingStoreEnabled = true; },
        "@odata.type": n => { alertAction.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertCollectionResponse(alertCollectionResponse: Partial<AlertCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(alertCollectionResponse),
        "value": n => { alertCollectionResponse.value = n.getCollectionOfObjectValues<Alert>(createAlertFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertFrequencyPoint The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertFrequencyPoint(alertFrequencyPoint: Partial<AlertFrequencyPoint> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { alertFrequencyPoint.backingStoreEnabled = true; },
        "highSeverityCount": n => { alertFrequencyPoint.highSeverityCount = n.getNumberValue(); },
        "informationalSeverityCount": n => { alertFrequencyPoint.informationalSeverityCount = n.getNumberValue(); },
        "lowSeverityCount": n => { alertFrequencyPoint.lowSeverityCount = n.getNumberValue(); },
        "mediumSeverityCount": n => { alertFrequencyPoint.mediumSeverityCount = n.getNumberValue(); },
        "@odata.type": n => { alertFrequencyPoint.odataType = n.getStringValue(); },
        "timeStampDateTime": n => { alertFrequencyPoint.timeStampDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertSeveritySummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertSeveritySummary(alertSeveritySummary: Partial<AlertSeveritySummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { alertSeveritySummary.backingStoreEnabled = true; },
        "count": n => { alertSeveritySummary.count = n.getNumberValue(); },
        "@odata.type": n => { alertSeveritySummary.odataType = n.getStringValue(); },
        "severity": n => { alertSeveritySummary.severity = n.getEnumValue<AlertSeverity>(AlertSeverityObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertSummary(alertSummary: Partial<AlertSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "alertType": n => { alertSummary.alertType = n.getEnumValue<AlertType>(AlertTypeObject); },
        "backingStoreEnabled": n => { alertSummary.backingStoreEnabled = true; },
        "count": n => { alertSummary.count = n.getNumberValue(); },
        "@odata.type": n => { alertSummary.odataType = n.getStringValue(); },
        "severity": n => { alertSummary.severity = n.getEnumValue<AlertSeverity>(AlertSeverityObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param ApplicationSnapshot The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoApplicationSnapshot(applicationSnapshot: Partial<ApplicationSnapshot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "appId": n => { applicationSnapshot.appId = n.getStringValue(); },
        "backingStoreEnabled": n => { applicationSnapshot.backingStoreEnabled = true; },
        "@odata.type": n => { applicationSnapshot.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param AssociatedBranch The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAssociatedBranch(associatedBranch: Partial<AssociatedBranch> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAssociation(associatedBranch),
        "branchId": n => { associatedBranch.branchId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Association The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAssociation(association: Partial<Association> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { association.backingStoreEnabled = true; },
        "@odata.type": n => { association.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param BgpConfiguration The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoBgpConfiguration(bgpConfiguration: Partial<BgpConfiguration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "asn": n => { bgpConfiguration.asn = n.getNumberValue(); },
        "backingStoreEnabled": n => { bgpConfiguration.backingStoreEnabled = true; },
        "ipAddress": n => { bgpConfiguration.ipAddress = n.getStringValue(); },
        "localIpAddress": n => { bgpConfiguration.localIpAddress = n.getStringValue(); },
        "@odata.type": n => { bgpConfiguration.odataType = n.getStringValue(); },
        "peerIpAddress": n => { bgpConfiguration.peerIpAddress = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param BranchConnectivityConfiguration The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoBranchConnectivityConfiguration(branchConnectivityConfiguration: Partial<BranchConnectivityConfiguration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { branchConnectivityConfiguration.backingStoreEnabled = true; },
        "branchId": n => { branchConnectivityConfiguration.branchId = n.getStringValue(); },
        "branchName": n => { branchConnectivityConfiguration.branchName = n.getStringValue(); },
        "links": n => { branchConnectivityConfiguration.links = n.getCollectionOfObjectValues<ConnectivityConfigurationLink>(createConnectivityConfigurationLinkFromDiscriminatorValue); },
        "@odata.type": n => { branchConnectivityConfiguration.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param BranchSite The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoBranchSite(branchSite: Partial<BranchSite> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(branchSite),
        "bandwidthCapacity": n => { branchSite.bandwidthCapacity = n.getNumberValue(); },
        "connectivityConfiguration": n => { branchSite.connectivityConfiguration = n.getObjectValue<BranchConnectivityConfiguration>(createBranchConnectivityConfigurationFromDiscriminatorValue); },
        "connectivityState": n => { branchSite.connectivityState = n.getEnumValue<ConnectivityState>(ConnectivityStateObject); },
        "country": n => { branchSite.country = n.getStringValue(); },
        "deviceLinks": n => { branchSite.deviceLinks = n.getCollectionOfObjectValues<DeviceLink>(createDeviceLinkFromDiscriminatorValue); },
        "forwardingProfiles": n => { branchSite.forwardingProfiles = n.getCollectionOfObjectValues<ForwardingProfile>(createForwardingProfileFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { branchSite.lastModifiedDateTime = n.getDateValue(); },
        "name": n => { branchSite.name = n.getStringValue(); },
        "region": n => { branchSite.region = n.getEnumValue<Region>(RegionObject); },
        "version": n => { branchSite.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param BranchSiteCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoBranchSiteCollectionResponse(branchSiteCollectionResponse: Partial<BranchSiteCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(branchSiteCollectionResponse),
        "value": n => { branchSiteCollectionResponse.value = n.getCollectionOfObjectValues<BranchSite>(createBranchSiteFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ConditionalAccessPolicy The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoConditionalAccessPolicy(conditionalAccessPolicy: Partial<ConditionalAccessPolicy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(conditionalAccessPolicy),
        "createdDateTime": n => { conditionalAccessPolicy.createdDateTime = n.getDateValue(); },
        "description": n => { conditionalAccessPolicy.description = n.getStringValue(); },
        "displayName": n => { conditionalAccessPolicy.displayName = n.getStringValue(); },
        "modifiedDateTime": n => { conditionalAccessPolicy.modifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ConditionalAccessPolicyCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoConditionalAccessPolicyCollectionResponse(conditionalAccessPolicyCollectionResponse: Partial<ConditionalAccessPolicyCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(conditionalAccessPolicyCollectionResponse),
        "value": n => { conditionalAccessPolicyCollectionResponse.value = n.getCollectionOfObjectValues<ConditionalAccessPolicy>(createConditionalAccessPolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ConditionalAccessSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoConditionalAccessSettings(conditionalAccessSettings: Partial<ConditionalAccessSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(conditionalAccessSettings),
        "signalingStatus": n => { conditionalAccessSettings.signalingStatus = n.getEnumValue<Status>(StatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param Connection The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoConnection(connection: Partial<Connection> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(connection),
        "agentVersion": n => { connection.agentVersion = n.getStringValue(); },
        "applicationSnapshot": n => { connection.applicationSnapshot = n.getObjectValue<ApplicationSnapshot>(createApplicationSnapshotFromDiscriminatorValue); },
        "createdDateTime": n => { connection.createdDateTime = n.getDateValue(); },
        "destinationFqdn": n => { connection.destinationFqdn = n.getStringValue(); },
        "destinationIp": n => { connection.destinationIp = n.getStringValue(); },
        "destinationPort": n => { connection.destinationPort = n.getNumberValue(); },
        "deviceCategory": n => { connection.deviceCategory = n.getEnumValue<DeviceCategory>(DeviceCategoryObject); },
        "deviceId": n => { connection.deviceId = n.getStringValue(); },
        "deviceOperatingSystem": n => { connection.deviceOperatingSystem = n.getStringValue(); },
        "deviceOperatingSystemVersion": n => { connection.deviceOperatingSystemVersion = n.getStringValue(); },
        "endDateTime": n => { connection.endDateTime = n.getDateValue(); },
        "initiatingProcessName": n => { connection.initiatingProcessName = n.getStringValue(); },
        "lastUpdateDateTime": n => { connection.lastUpdateDateTime = n.getDateValue(); },
        "networkProtocol": n => { connection.networkProtocol = n.getEnumValue<NetworkingProtocol>(NetworkingProtocolObject); },
        "popProcessingRegion": n => { connection.popProcessingRegion = n.getStringValue(); },
        "privateAccessDetails": n => { connection.privateAccessDetails = n.getObjectValue<PrivateAccessDetails>(createPrivateAccessDetailsFromDiscriminatorValue); },
        "receivedBytes": n => { connection.receivedBytes = n.getNumberValue(); },
        "sentBytes": n => { connection.sentBytes = n.getNumberValue(); },
        "sourceIp": n => { connection.sourceIp = n.getStringValue(); },
        "sourcePort": n => { connection.sourcePort = n.getNumberValue(); },
        "status": n => { connection.status = n.getEnumValue<ConnectionStatus>(ConnectionStatusObject); },
        "tenantId": n => { connection.tenantId = n.getStringValue(); },
        "trafficType": n => { connection.trafficType = n.getEnumValue<TrafficType>(TrafficTypeObject); },
        "transactionBlockCount": n => { connection.transactionBlockCount = n.getNumberValue(); },
        "transactionCount": n => { connection.transactionCount = n.getNumberValue(); },
        "transportProtocol": n => { connection.transportProtocol = n.getEnumValue<NetworkingProtocol>(NetworkingProtocolObject); },
        "userId": n => { connection.userId = n.getStringValue(); },
        "userPrincipalName": n => { connection.userPrincipalName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ConnectionCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoConnectionCollectionResponse(connectionCollectionResponse: Partial<ConnectionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(connectionCollectionResponse),
        "value": n => { connectionCollectionResponse.value = n.getCollectionOfObjectValues<Connection>(createConnectionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ConnectionSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoConnectionSummary(connectionSummary: Partial<ConnectionSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { connectionSummary.backingStoreEnabled = true; },
        "@odata.type": n => { connectionSummary.odataType = n.getStringValue(); },
        "totalCount": n => { connectionSummary.totalCount = n.getNumberValue(); },
        "trafficType": n => { connectionSummary.trafficType = n.getEnumValue<TrafficType>(TrafficTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param Connectivity The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoConnectivity(connectivity: Partial<Connectivity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(connectivity),
        "branches": n => { connectivity.branches = n.getCollectionOfObjectValues<BranchSite>(createBranchSiteFromDiscriminatorValue); },
        "remoteNetworks": n => { connectivity.remoteNetworks = n.getCollectionOfObjectValues<RemoteNetwork>(createRemoteNetworkFromDiscriminatorValue); },
        "webCategories": n => { connectivity.webCategories = n.getCollectionOfObjectValues<WebCategory>(createWebCategoryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ConnectivityConfigurationLink The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoConnectivityConfigurationLink(connectivityConfigurationLink: Partial<ConnectivityConfigurationLink> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(connectivityConfigurationLink),
        "displayName": n => { connectivityConfigurationLink.displayName = n.getStringValue(); },
        "localConfigurations": n => { connectivityConfigurationLink.localConfigurations = n.getCollectionOfObjectValues<LocalConnectivityConfiguration>(createLocalConnectivityConfigurationFromDiscriminatorValue); },
        "peerConfiguration": n => { connectivityConfigurationLink.peerConfiguration = n.getObjectValue<PeerConnectivityConfiguration>(createPeerConnectivityConfigurationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ConnectivityConfigurationLinkCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoConnectivityConfigurationLinkCollectionResponse(connectivityConfigurationLinkCollectionResponse: Partial<ConnectivityConfigurationLinkCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(connectivityConfigurationLinkCollectionResponse),
        "value": n => { connectivityConfigurationLinkCollectionResponse.value = n.getCollectionOfObjectValues<ConnectivityConfigurationLink>(createConnectivityConfigurationLinkFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param CrossTenantAccess The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCrossTenantAccess(crossTenantAccess: Partial<CrossTenantAccess> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { crossTenantAccess.backingStoreEnabled = true; },
        "deviceCount": n => { crossTenantAccess.deviceCount = n.getNumberValue(); },
        "lastAccessDateTime": n => { crossTenantAccess.lastAccessDateTime = n.getDateValue(); },
        "@odata.type": n => { crossTenantAccess.odataType = n.getStringValue(); },
        "resourceTenantId": n => { crossTenantAccess.resourceTenantId = n.getStringValue(); },
        "resourceTenantName": n => { crossTenantAccess.resourceTenantName = n.getStringValue(); },
        "resourceTenantPrimaryDomain": n => { crossTenantAccess.resourceTenantPrimaryDomain = n.getStringValue(); },
        "usageStatus": n => { crossTenantAccess.usageStatus = n.getEnumValue<UsageStatus>(UsageStatusObject); },
        "userCount": n => { crossTenantAccess.userCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param CrossTenantAccessSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCrossTenantAccessSettings(crossTenantAccessSettings: Partial<CrossTenantAccessSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(crossTenantAccessSettings),
        "networkPacketTaggingStatus": n => { crossTenantAccessSettings.networkPacketTaggingStatus = n.getEnumValue<Status>(StatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param CrossTenantSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCrossTenantSummary(crossTenantSummary: Partial<CrossTenantSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "authTransactionCount": n => { crossTenantSummary.authTransactionCount = n.getNumberValue(); },
        "backingStoreEnabled": n => { crossTenantSummary.backingStoreEnabled = true; },
        "deviceCount": n => { crossTenantSummary.deviceCount = n.getNumberValue(); },
        "newTenantCount": n => { crossTenantSummary.newTenantCount = n.getNumberValue(); },
        "@odata.type": n => { crossTenantSummary.odataType = n.getStringValue(); },
        "rarelyUsedTenantCount": n => { crossTenantSummary.rarelyUsedTenantCount = n.getNumberValue(); },
        "tenantCount": n => { crossTenantSummary.tenantCount = n.getNumberValue(); },
        "userCount": n => { crossTenantSummary.userCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Destination The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDestination(destination: Partial<Destination> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { destination.backingStoreEnabled = true; },
        "deviceCount": n => { destination.deviceCount = n.getNumberValue(); },
        "firstAccessDateTime": n => { destination.firstAccessDateTime = n.getDateValue(); },
        "fqdn": n => { destination.fqdn = n.getStringValue(); },
        "ip": n => { destination.ip = n.getStringValue(); },
        "lastAccessDateTime": n => { destination.lastAccessDateTime = n.getDateValue(); },
        "networkingProtocol": n => { destination.networkingProtocol = n.getEnumValue<NetworkingProtocol>(NetworkingProtocolObject); },
        "@odata.type": n => { destination.odataType = n.getStringValue(); },
        "port": n => { destination.port = n.getNumberValue(); },
        "threatCount": n => { destination.threatCount = n.getNumberValue(); },
        "totalBytesReceived": n => { destination.totalBytesReceived = n.getNumberValue(); },
        "totalBytesSent": n => { destination.totalBytesSent = n.getNumberValue(); },
        "trafficType": n => { destination.trafficType = n.getEnumValue<TrafficType>(TrafficTypeObject); },
        "transactionCount": n => { destination.transactionCount = n.getNumberValue(); },
        "userCount": n => { destination.userCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DestinationSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDestinationSummary(destinationSummary: Partial<DestinationSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { destinationSummary.backingStoreEnabled = true; },
        "count": n => { destinationSummary.count = n.getNumberValue(); },
        "destination": n => { destinationSummary.destination = n.getStringValue(); },
        "@odata.type": n => { destinationSummary.odataType = n.getStringValue(); },
        "trafficType": n => { destinationSummary.trafficType = n.getEnumValue<TrafficType>(TrafficTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param Device The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDevice(device: Partial<Device> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { device.backingStoreEnabled = true; },
        "deviceId": n => { device.deviceId = n.getStringValue(); },
        "displayName": n => { device.displayName = n.getStringValue(); },
        "isCompliant": n => { device.isCompliant = n.getBooleanValue(); },
        "lastAccessDateTime": n => { device.lastAccessDateTime = n.getDateValue(); },
        "@odata.type": n => { device.odataType = n.getStringValue(); },
        "operatingSystem": n => { device.operatingSystem = n.getStringValue(); },
        "trafficType": n => { device.trafficType = n.getEnumValue<TrafficType>(TrafficTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param DeviceLink The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeviceLink(deviceLink: Partial<DeviceLink> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(deviceLink),
        "bandwidthCapacityInMbps": n => { deviceLink.bandwidthCapacityInMbps = n.getEnumValue<BandwidthCapacityInMbps>(BandwidthCapacityInMbpsObject); },
        "bgpConfiguration": n => { deviceLink.bgpConfiguration = n.getObjectValue<BgpConfiguration>(createBgpConfigurationFromDiscriminatorValue); },
        "deviceVendor": n => { deviceLink.deviceVendor = n.getEnumValue<DeviceVendor>(DeviceVendorObject); },
        "ipAddress": n => { deviceLink.ipAddress = n.getStringValue(); },
        "lastModifiedDateTime": n => { deviceLink.lastModifiedDateTime = n.getDateValue(); },
        "name": n => { deviceLink.name = n.getStringValue(); },
        "redundancyConfiguration": n => { deviceLink.redundancyConfiguration = n.getObjectValue<RedundancyConfiguration>(createRedundancyConfigurationFromDiscriminatorValue); },
        "tunnelConfiguration": n => { deviceLink.tunnelConfiguration = n.getObjectValue<TunnelConfiguration>(createTunnelConfigurationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param DeviceLinkCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeviceLinkCollectionResponse(deviceLinkCollectionResponse: Partial<DeviceLinkCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(deviceLinkCollectionResponse),
        "value": n => { deviceLinkCollectionResponse.value = n.getCollectionOfObjectValues<DeviceLink>(createDeviceLinkFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param DeviceUsageSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeviceUsageSummary(deviceUsageSummary: Partial<DeviceUsageSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "activeDeviceCount": n => { deviceUsageSummary.activeDeviceCount = n.getNumberValue(); },
        "backingStoreEnabled": n => { deviceUsageSummary.backingStoreEnabled = true; },
        "inactiveDeviceCount": n => { deviceUsageSummary.inactiveDeviceCount = n.getNumberValue(); },
        "@odata.type": n => { deviceUsageSummary.odataType = n.getStringValue(); },
        "totalDeviceCount": n => { deviceUsageSummary.totalDeviceCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DiscoveredApplicationSegmentReport The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDiscoveredApplicationSegmentReport(discoveredApplicationSegmentReport: Partial<DiscoveredApplicationSegmentReport> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "accessType": n => { discoveredApplicationSegmentReport.accessType = n.getEnumValue<AccessType>(AccessTypeObject); },
        "backingStoreEnabled": n => { discoveredApplicationSegmentReport.backingStoreEnabled = true; },
        "deviceCount": n => { discoveredApplicationSegmentReport.deviceCount = n.getNumberValue(); },
        "discoveredApplicationSegmentId": n => { discoveredApplicationSegmentReport.discoveredApplicationSegmentId = n.getStringValue(); },
        "firstAccessDateTime": n => { discoveredApplicationSegmentReport.firstAccessDateTime = n.getDateValue(); },
        "fqdn": n => { discoveredApplicationSegmentReport.fqdn = n.getStringValue(); },
        "ip": n => { discoveredApplicationSegmentReport.ip = n.getStringValue(); },
        "lastAccessDateTime": n => { discoveredApplicationSegmentReport.lastAccessDateTime = n.getDateValue(); },
        "@odata.type": n => { discoveredApplicationSegmentReport.odataType = n.getStringValue(); },
        "port": n => { discoveredApplicationSegmentReport.port = n.getNumberValue(); },
        "totalBytesReceived": n => { discoveredApplicationSegmentReport.totalBytesReceived = n.getNumberValue(); },
        "totalBytesSent": n => { discoveredApplicationSegmentReport.totalBytesSent = n.getNumberValue(); },
        "transactionCount": n => { discoveredApplicationSegmentReport.transactionCount = n.getNumberValue(); },
        "transportProtocol": n => { discoveredApplicationSegmentReport.transportProtocol = n.getEnumValue<NetworkingProtocol>(NetworkingProtocolObject); },
        "userCount": n => { discoveredApplicationSegmentReport.userCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param EntitiesSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEntitiesSummary(entitiesSummary: Partial<EntitiesSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { entitiesSummary.backingStoreEnabled = true; },
        "deviceCount": n => { entitiesSummary.deviceCount = n.getNumberValue(); },
        "@odata.type": n => { entitiesSummary.odataType = n.getStringValue(); },
        "trafficType": n => { entitiesSummary.trafficType = n.getEnumValue<TrafficType>(TrafficTypeObject); },
        "userCount": n => { entitiesSummary.userCount = n.getNumberValue(); },
        "workloadCount": n => { entitiesSummary.workloadCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ExtendedProperties The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExtendedProperties(extendedProperties: Partial<ExtendedProperties> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDictionary(extendedProperties),
    }
}
/**
 * The deserialization information for the current model
 * @param ExternalCertificateAuthorityCertificate The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExternalCertificateAuthorityCertificate(externalCertificateAuthorityCertificate: Partial<ExternalCertificateAuthorityCertificate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(externalCertificateAuthorityCertificate),
        "certificate": n => { externalCertificateAuthorityCertificate.certificate = n.getStringValue(); },
        "certificateSigningRequest": n => { externalCertificateAuthorityCertificate.certificateSigningRequest = n.getStringValue(); },
        "chain": n => { externalCertificateAuthorityCertificate.chain = n.getStringValue(); },
        "commonName": n => { externalCertificateAuthorityCertificate.commonName = n.getStringValue(); },
        "name": n => { externalCertificateAuthorityCertificate.name = n.getStringValue(); },
        "organizationName": n => { externalCertificateAuthorityCertificate.organizationName = n.getStringValue(); },
        "status": n => { externalCertificateAuthorityCertificate.status = n.getEnumValue<TlsCertificateStatus>(TlsCertificateStatusObject); },
        "validity": n => { externalCertificateAuthorityCertificate.validity = n.getObjectValue<ValidityDate>(createValidityDateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ExternalCertificateAuthorityCertificateCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExternalCertificateAuthorityCertificateCollectionResponse(externalCertificateAuthorityCertificateCollectionResponse: Partial<ExternalCertificateAuthorityCertificateCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(externalCertificateAuthorityCertificateCollectionResponse),
        "value": n => { externalCertificateAuthorityCertificateCollectionResponse.value = n.getCollectionOfObjectValues<ExternalCertificateAuthorityCertificate>(createExternalCertificateAuthorityCertificateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param FilteringPolicy The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFilteringPolicy(filteringPolicy: Partial<FilteringPolicy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicy(filteringPolicy),
        "action": n => { filteringPolicy.action = n.getEnumValue<FilteringPolicyAction>(FilteringPolicyActionObject); },
        "createdDateTime": n => { filteringPolicy.createdDateTime = n.getDateValue(); },
        "lastModifiedDateTime": n => { filteringPolicy.lastModifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param FilteringPolicyCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFilteringPolicyCollectionResponse(filteringPolicyCollectionResponse: Partial<FilteringPolicyCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(filteringPolicyCollectionResponse),
        "value": n => { filteringPolicyCollectionResponse.value = n.getCollectionOfObjectValues<FilteringPolicy>(createFilteringPolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param FilteringPolicyLink The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFilteringPolicyLink(filteringPolicyLink: Partial<FilteringPolicyLink> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicyLink(filteringPolicyLink),
        "createdDateTime": n => { filteringPolicyLink.createdDateTime = n.getDateValue(); },
        "lastModifiedDateTime": n => { filteringPolicyLink.lastModifiedDateTime = n.getDateValue(); },
        "loggingState": n => { filteringPolicyLink.loggingState = n.getEnumValue<Status>(StatusObject); },
        "priority": n => { filteringPolicyLink.priority = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param FilteringProfile The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFilteringProfile(filteringProfile: Partial<FilteringProfile> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoProfile(filteringProfile),
        "conditionalAccessPolicies": n => { filteringProfile.conditionalAccessPolicies = n.getCollectionOfObjectValues<ConditionalAccessPolicy>(createConditionalAccessPolicyFromDiscriminatorValue); },
        "createdDateTime": n => { filteringProfile.createdDateTime = n.getDateValue(); },
        "priority": n => { filteringProfile.priority = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param FilteringProfileCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFilteringProfileCollectionResponse(filteringProfileCollectionResponse: Partial<FilteringProfileCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(filteringProfileCollectionResponse),
        "value": n => { filteringProfileCollectionResponse.value = n.getCollectionOfObjectValues<FilteringProfile>(createFilteringProfileFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param FilteringRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFilteringRule(filteringRule: Partial<FilteringRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicyRule(filteringRule),
        "destinations": n => { filteringRule.destinations = n.getCollectionOfObjectValues<RuleDestination>(createRuleDestinationFromDiscriminatorValue); },
        "ruleType": n => { filteringRule.ruleType = n.getEnumValue<NetworkDestinationType>(NetworkDestinationTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param ForwardingOptions The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoForwardingOptions(forwardingOptions: Partial<ForwardingOptions> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(forwardingOptions),
        "skipDnsLookupState": n => { forwardingOptions.skipDnsLookupState = n.getEnumValue<Status>(StatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param ForwardingPolicy The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoForwardingPolicy(forwardingPolicy: Partial<ForwardingPolicy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicy(forwardingPolicy),
        "trafficForwardingType": n => { forwardingPolicy.trafficForwardingType = n.getEnumValue<TrafficForwardingType>(TrafficForwardingTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param ForwardingPolicyCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoForwardingPolicyCollectionResponse(forwardingPolicyCollectionResponse: Partial<ForwardingPolicyCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(forwardingPolicyCollectionResponse),
        "value": n => { forwardingPolicyCollectionResponse.value = n.getCollectionOfObjectValues<ForwardingPolicy>(createForwardingPolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ForwardingPolicyLink The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoForwardingPolicyLink(forwardingPolicyLink: Partial<ForwardingPolicyLink> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicyLink(forwardingPolicyLink),
    }
}
/**
 * The deserialization information for the current model
 * @param ForwardingProfile The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoForwardingProfile(forwardingProfile: Partial<ForwardingProfile> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoProfile(forwardingProfile),
        "associations": n => { forwardingProfile.associations = n.getCollectionOfObjectValues<Association>(createAssociationFromDiscriminatorValue); },
        "priority": n => { forwardingProfile.priority = n.getNumberValue(); },
        "servicePrincipal": n => { forwardingProfile.servicePrincipal = n.getObjectValue<ServicePrincipal>(createServicePrincipalFromDiscriminatorValue); },
        "trafficForwardingType": n => { forwardingProfile.trafficForwardingType = n.getEnumValue<TrafficForwardingType>(TrafficForwardingTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param ForwardingProfileCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoForwardingProfileCollectionResponse(forwardingProfileCollectionResponse: Partial<ForwardingProfileCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(forwardingProfileCollectionResponse),
        "value": n => { forwardingProfileCollectionResponse.value = n.getCollectionOfObjectValues<ForwardingProfile>(createForwardingProfileFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ForwardingRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoForwardingRule(forwardingRule: Partial<ForwardingRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicyRule(forwardingRule),
        "action": n => { forwardingRule.action = n.getEnumValue<ForwardingRuleAction>(ForwardingRuleActionObject); },
        "clientFallbackAction": n => { forwardingRule.clientFallbackAction = n.getEnumValue<ClientFallbackAction>(ClientFallbackActionObject); },
        "destinations": n => { forwardingRule.destinations = n.getCollectionOfObjectValues<RuleDestination>(createRuleDestinationFromDiscriminatorValue); },
        "ruleType": n => { forwardingRule.ruleType = n.getEnumValue<NetworkDestinationType>(NetworkDestinationTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param Fqdn The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFqdn(fqdn: Partial<Fqdn> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRuleDestination(fqdn),
        "value": n => { fqdn.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param FqdnFilteringRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFqdnFilteringRule(fqdnFilteringRule: Partial<FqdnFilteringRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilteringRule(fqdnFilteringRule),
    }
}
/**
 * The deserialization information for the current model
 * @param Headers The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoHeaders(headers: Partial<Headers> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { headers.backingStoreEnabled = true; },
        "@odata.type": n => { headers.odataType = n.getStringValue(); },
        "origin": n => { headers.origin = n.getStringValue(); },
        "referrer": n => { headers.referrer = n.getStringValue(); },
        "xForwardedFor": n => { headers.xForwardedFor = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param InternetAccessForwardingRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoInternetAccessForwardingRule(internetAccessForwardingRule: Partial<InternetAccessForwardingRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoForwardingRule(internetAccessForwardingRule),
        "ports": n => { internetAccessForwardingRule.ports = n.getCollectionOfPrimitiveValues<string>(); },
        "protocol": n => { internetAccessForwardingRule.protocol = n.getEnumValue<NetworkingProtocol>(NetworkingProtocolObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param IpAddress The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIpAddress(ipAddress: Partial<IpAddress> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRuleDestination(ipAddress),
        "value": n => { ipAddress.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param IpRange The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIpRange(ipRange: Partial<IpRange> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRuleDestination(ipRange),
        "beginAddress": n => { ipRange.beginAddress = n.getStringValue(); },
        "endAddress": n => { ipRange.endAddress = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param IpSubnet The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIpSubnet(ipSubnet: Partial<IpSubnet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRuleDestination(ipSubnet),
        "value": n => { ipSubnet.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param LocalConnectivityConfiguration The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoLocalConnectivityConfiguration(localConnectivityConfiguration: Partial<LocalConnectivityConfiguration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "asn": n => { localConnectivityConfiguration.asn = n.getNumberValue(); },
        "backingStoreEnabled": n => { localConnectivityConfiguration.backingStoreEnabled = true; },
        "bgpAddress": n => { localConnectivityConfiguration.bgpAddress = n.getStringValue(); },
        "endpoint": n => { localConnectivityConfiguration.endpoint = n.getStringValue(); },
        "@odata.type": n => { localConnectivityConfiguration.odataType = n.getStringValue(); },
        "region": n => { localConnectivityConfiguration.region = n.getEnumValue<Region>(RegionObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param Logs The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoLogs(logs: Partial<Logs> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(logs),
        "connections": n => { logs.connections = n.getCollectionOfObjectValues<Connection>(createConnectionFromDiscriminatorValue); },
        "remoteNetworks": n => { logs.remoteNetworks = n.getCollectionOfObjectValues<RemoteNetworkHealthEvent>(createRemoteNetworkHealthEventFromDiscriminatorValue); },
        "traffic": n => { logs.traffic = n.getCollectionOfObjectValues<NetworkAccessTraffic>(createNetworkAccessTrafficFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param M365ForwardingRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoM365ForwardingRule(m365ForwardingRule: Partial<M365ForwardingRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoForwardingRule(m365ForwardingRule),
        "category": n => { m365ForwardingRule.category = n.getEnumValue<ForwardingCategory>(ForwardingCategoryObject); },
        "ports": n => { m365ForwardingRule.ports = n.getCollectionOfPrimitiveValues<string>(); },
        "protocol": n => { m365ForwardingRule.protocol = n.getEnumValue<NetworkingProtocol>(NetworkingProtocolObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param NetworkAccessRoot The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoNetworkAccessRoot(networkAccessRoot: Partial<NetworkAccessRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(networkAccessRoot),
        "alerts": n => { networkAccessRoot.alerts = n.getCollectionOfObjectValues<Alert>(createAlertFromDiscriminatorValue); },
        "connectivity": n => { networkAccessRoot.connectivity = n.getObjectValue<Connectivity>(createConnectivityFromDiscriminatorValue); },
        "filteringPolicies": n => { networkAccessRoot.filteringPolicies = n.getCollectionOfObjectValues<FilteringPolicy>(createFilteringPolicyFromDiscriminatorValue); },
        "filteringProfiles": n => { networkAccessRoot.filteringProfiles = n.getCollectionOfObjectValues<FilteringProfile>(createFilteringProfileFromDiscriminatorValue); },
        "forwardingPolicies": n => { networkAccessRoot.forwardingPolicies = n.getCollectionOfObjectValues<ForwardingPolicy>(createForwardingPolicyFromDiscriminatorValue); },
        "forwardingProfiles": n => { networkAccessRoot.forwardingProfiles = n.getCollectionOfObjectValues<ForwardingProfile>(createForwardingProfileFromDiscriminatorValue); },
        "logs": n => { networkAccessRoot.logs = n.getObjectValue<Logs>(createLogsFromDiscriminatorValue); },
        "reports": n => { networkAccessRoot.reports = n.getObjectValue<Reports>(createReportsFromDiscriminatorValue); },
        "settings": n => { networkAccessRoot.settings = n.getObjectValue<Settings>(createSettingsFromDiscriminatorValue); },
        "tenantStatus": n => { networkAccessRoot.tenantStatus = n.getObjectValue<TenantStatus>(createTenantStatusFromDiscriminatorValue); },
        "threatIntelligencePolicies": n => { networkAccessRoot.threatIntelligencePolicies = n.getCollectionOfObjectValues<ThreatIntelligencePolicy>(createThreatIntelligencePolicyFromDiscriminatorValue); },
        "tls": n => { networkAccessRoot.tls = n.getObjectValue<TlsTermination>(createTlsTerminationFromDiscriminatorValue); },
        "tlsInspectionPolicies": n => { networkAccessRoot.tlsInspectionPolicies = n.getCollectionOfObjectValues<TlsInspectionPolicy>(createTlsInspectionPolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param NetworkAccessTraffic The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoNetworkAccessTraffic(networkAccessTraffic: Partial<NetworkAccessTraffic> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "action": n => { networkAccessTraffic.action = n.getEnumValue<FilteringPolicyAction>(FilteringPolicyActionObject); },
        "agentVersion": n => { networkAccessTraffic.agentVersion = n.getStringValue(); },
        "applicationSnapshot": n => { networkAccessTraffic.applicationSnapshot = n.getObjectValue<ApplicationSnapshot>(createApplicationSnapshotFromDiscriminatorValue); },
        "backingStoreEnabled": n => { networkAccessTraffic.backingStoreEnabled = true; },
        "connectionId": n => { networkAccessTraffic.connectionId = n.getStringValue(); },
        "createdDateTime": n => { networkAccessTraffic.createdDateTime = n.getDateValue(); },
        "description": n => { networkAccessTraffic.description = n.getStringValue(); },
        "destinationFQDN": n => { networkAccessTraffic.destinationFQDN = n.getStringValue(); },
        "destinationIp": n => { networkAccessTraffic.destinationIp = n.getStringValue(); },
        "destinationPort": n => { networkAccessTraffic.destinationPort = n.getNumberValue(); },
        "destinationUrl": n => { networkAccessTraffic.destinationUrl = n.getStringValue(); },
        "destinationWebCategory": n => { networkAccessTraffic.destinationWebCategory = n.getObjectValue<WebCategory>(createWebCategoryFromDiscriminatorValue); },
        "device": n => { networkAccessTraffic.device = n.getObjectValue<I353170b9ab043a51be0a29bf9ffeadaa40f51ff6511c066ae82d223c77decf60>(I35341c37cb1156f9816804144a0da7ca28a5bc5a466a4a6c4dd18a73c9fef2f1); },
        "deviceCategory": n => { networkAccessTraffic.deviceCategory = n.getEnumValue<DeviceCategory>(DeviceCategoryObject); },
        "deviceId": n => { networkAccessTraffic.deviceId = n.getStringValue(); },
        "deviceOperatingSystem": n => { networkAccessTraffic.deviceOperatingSystem = n.getStringValue(); },
        "deviceOperatingSystemVersion": n => { networkAccessTraffic.deviceOperatingSystemVersion = n.getStringValue(); },
        "filteringProfileId": n => { networkAccessTraffic.filteringProfileId = n.getStringValue(); },
        "filteringProfileName": n => { networkAccessTraffic.filteringProfileName = n.getStringValue(); },
        "headers": n => { networkAccessTraffic.headers = n.getObjectValue<Headers>(createHeadersFromDiscriminatorValue); },
        "httpMethod": n => { networkAccessTraffic.httpMethod = n.getEnumValue<HttpMethod>(HttpMethodObject); },
        "initiatingProcessName": n => { networkAccessTraffic.initiatingProcessName = n.getStringValue(); },
        "networkProtocol": n => { networkAccessTraffic.networkProtocol = n.getEnumValue<NetworkingProtocol>(NetworkingProtocolObject); },
        "@odata.type": n => { networkAccessTraffic.odataType = n.getStringValue(); },
        "operationStatus": n => { networkAccessTraffic.operationStatus = n.getEnumValue<NetworkTrafficOperationStatus>(NetworkTrafficOperationStatusObject); },
        "policyId": n => { networkAccessTraffic.policyId = n.getStringValue(); },
        "policyName": n => { networkAccessTraffic.policyName = n.getStringValue(); },
        "policyRuleId": n => { networkAccessTraffic.policyRuleId = n.getStringValue(); },
        "policyRuleName": n => { networkAccessTraffic.policyRuleName = n.getStringValue(); },
        "popProcessingRegion": n => { networkAccessTraffic.popProcessingRegion = n.getStringValue(); },
        "privateAccessDetails": n => { networkAccessTraffic.privateAccessDetails = n.getObjectValue<PrivateAccessDetails>(createPrivateAccessDetailsFromDiscriminatorValue); },
        "receivedBytes": n => { networkAccessTraffic.receivedBytes = n.getNumberValue(); },
        "remoteNetworkId": n => { networkAccessTraffic.remoteNetworkId = n.getStringValue(); },
        "resourceTenantId": n => { networkAccessTraffic.resourceTenantId = n.getStringValue(); },
        "responseCode": n => { networkAccessTraffic.responseCode = n.getNumberValue(); },
        "sentBytes": n => { networkAccessTraffic.sentBytes = n.getNumberValue(); },
        "sessionId": n => { networkAccessTraffic.sessionId = n.getStringValue(); },
        "sourceIp": n => { networkAccessTraffic.sourceIp = n.getStringValue(); },
        "sourcePort": n => { networkAccessTraffic.sourcePort = n.getNumberValue(); },
        "tenantId": n => { networkAccessTraffic.tenantId = n.getStringValue(); },
        "threatType": n => { networkAccessTraffic.threatType = n.getStringValue(); },
        "trafficType": n => { networkAccessTraffic.trafficType = n.getEnumValue<TrafficType>(TrafficTypeObject); },
        "transactionId": n => { networkAccessTraffic.transactionId = n.getStringValue(); },
        "transportProtocol": n => { networkAccessTraffic.transportProtocol = n.getEnumValue<NetworkingProtocol>(NetworkingProtocolObject); },
        "user": n => { networkAccessTraffic.user = n.getObjectValue<I4bfcbb20fa90605575bab96c7572912b314f024f9b0899d027a654508ef72465>(I76468935476edf00ba62610ba93d13d7194a94fc3b9375d1eacaf60b72b6323e); },
        "userId": n => { networkAccessTraffic.userId = n.getStringValue(); },
        "userPrincipalName": n => { networkAccessTraffic.userPrincipalName = n.getStringValue(); },
        "vendorNames": n => { networkAccessTraffic.vendorNames = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @param NetworkAccessTrafficCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoNetworkAccessTrafficCollectionResponse(networkAccessTrafficCollectionResponse: Partial<NetworkAccessTrafficCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(networkAccessTrafficCollectionResponse),
        "value": n => { networkAccessTrafficCollectionResponse.value = n.getCollectionOfObjectValues<NetworkAccessTraffic>(createNetworkAccessTrafficFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param PeerConnectivityConfiguration The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPeerConnectivityConfiguration(peerConnectivityConfiguration: Partial<PeerConnectivityConfiguration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "asn": n => { peerConnectivityConfiguration.asn = n.getNumberValue(); },
        "backingStoreEnabled": n => { peerConnectivityConfiguration.backingStoreEnabled = true; },
        "bgpAddress": n => { peerConnectivityConfiguration.bgpAddress = n.getStringValue(); },
        "endpoint": n => { peerConnectivityConfiguration.endpoint = n.getStringValue(); },
        "@odata.type": n => { peerConnectivityConfiguration.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Policy The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPolicy(policy: Partial<Policy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(policy),
        "description": n => { policy.description = n.getStringValue(); },
        "name": n => { policy.name = n.getStringValue(); },
        "policyRules": n => { policy.policyRules = n.getCollectionOfObjectValues<PolicyRule>(createPolicyRuleFromDiscriminatorValue); },
        "version": n => { policy.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param PolicyLink The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPolicyLink(policyLink: Partial<PolicyLink> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(policyLink),
        "policy": n => { policyLink.policy = n.getObjectValue<Policy>(createPolicyFromDiscriminatorValue); },
        "state": n => { policyLink.state = n.getEnumValue<Status>(StatusObject); },
        "version": n => { policyLink.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param PolicyLinkCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPolicyLinkCollectionResponse(policyLinkCollectionResponse: Partial<PolicyLinkCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(policyLinkCollectionResponse),
        "value": n => { policyLinkCollectionResponse.value = n.getCollectionOfObjectValues<PolicyLink>(createPolicyLinkFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param PolicyRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPolicyRule(policyRule: Partial<PolicyRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(policyRule),
        "name": n => { policyRule.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param PolicyRuleCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPolicyRuleCollectionResponse(policyRuleCollectionResponse: Partial<PolicyRuleCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(policyRuleCollectionResponse),
        "value": n => { policyRuleCollectionResponse.value = n.getCollectionOfObjectValues<PolicyRule>(createPolicyRuleFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param PolicyRuleDelta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPolicyRuleDelta(policyRuleDelta: Partial<PolicyRuleDelta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "action": n => { policyRuleDelta.action = n.getEnumValue<ForwardingRuleAction>(ForwardingRuleActionObject); },
        "backingStoreEnabled": n => { policyRuleDelta.backingStoreEnabled = true; },
        "@odata.type": n => { policyRuleDelta.odataType = n.getStringValue(); },
        "ruleId": n => { policyRuleDelta.ruleId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param PrivateAccessDetails The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPrivateAccessDetails(privateAccessDetails: Partial<PrivateAccessDetails> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "accessType": n => { privateAccessDetails.accessType = n.getEnumValue<AccessType>(AccessTypeObject); },
        "appSegmentId": n => { privateAccessDetails.appSegmentId = n.getStringValue(); },
        "backingStoreEnabled": n => { privateAccessDetails.backingStoreEnabled = true; },
        "connectionStatus": n => { privateAccessDetails.connectionStatus = n.getEnumValue<ConnectionStatus>(ConnectionStatusObject); },
        "connectorId": n => { privateAccessDetails.connectorId = n.getStringValue(); },
        "connectorIp": n => { privateAccessDetails.connectorIp = n.getStringValue(); },
        "connectorName": n => { privateAccessDetails.connectorName = n.getStringValue(); },
        "@odata.type": n => { privateAccessDetails.odataType = n.getStringValue(); },
        "processingRegion": n => { privateAccessDetails.processingRegion = n.getStringValue(); },
        "thirdPartyTokenDetails": n => { privateAccessDetails.thirdPartyTokenDetails = n.getObjectValue<ThirdPartyTokenDetails>(createThirdPartyTokenDetailsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param PrivateAccessForwardingRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPrivateAccessForwardingRule(privateAccessForwardingRule: Partial<PrivateAccessForwardingRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoForwardingRule(privateAccessForwardingRule),
    }
}
/**
 * The deserialization information for the current model
 * @param Profile The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoProfile(profile: Partial<Profile> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(profile),
        "description": n => { profile.description = n.getStringValue(); },
        "lastModifiedDateTime": n => { profile.lastModifiedDateTime = n.getDateValue(); },
        "name": n => { profile.name = n.getStringValue(); },
        "policies": n => { profile.policies = n.getCollectionOfObjectValues<PolicyLink>(createPolicyLinkFromDiscriminatorValue); },
        "state": n => { profile.state = n.getEnumValue<Status>(StatusObject); },
        "version": n => { profile.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RedundancyConfiguration The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRedundancyConfiguration(redundancyConfiguration: Partial<RedundancyConfiguration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { redundancyConfiguration.backingStoreEnabled = true; },
        "@odata.type": n => { redundancyConfiguration.odataType = n.getStringValue(); },
        "redundancyTier": n => { redundancyConfiguration.redundancyTier = n.getEnumValue<RedundancyTier>(RedundancyTierObject); },
        "zoneLocalIpAddress": n => { redundancyConfiguration.zoneLocalIpAddress = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedDestination The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedDestination(relatedDestination: Partial<RelatedDestination> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedDestination),
        "fqdn": n => { relatedDestination.fqdn = n.getStringValue(); },
        "ip": n => { relatedDestination.ip = n.getStringValue(); },
        "networkingProtocol": n => { relatedDestination.networkingProtocol = n.getEnumValue<NetworkingProtocol>(NetworkingProtocolObject); },
        "port": n => { relatedDestination.port = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedDevice The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedDevice(relatedDevice: Partial<RelatedDevice> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedDevice),
        "deviceId": n => { relatedDevice.deviceId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedFile The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedFile(relatedFile: Partial<RelatedFile> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedFile),
        "directory": n => { relatedFile.directory = n.getStringValue(); },
        "name": n => { relatedFile.name = n.getStringValue(); },
        "sizeInBytes": n => { relatedFile.sizeInBytes = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedFileHash The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedFileHash(relatedFileHash: Partial<RelatedFileHash> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedFileHash),
        "algorithm": n => { relatedFileHash.algorithm = n.getEnumValue<Algorithm>(AlgorithmObject); },
        "value": n => { relatedFileHash.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedMalware The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedMalware(relatedMalware: Partial<RelatedMalware> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedMalware),
        "category": n => { relatedMalware.category = n.getEnumValue<MalwareCategory>(MalwareCategoryObject); },
        "name": n => { relatedMalware.name = n.getStringValue(); },
        "severity": n => { relatedMalware.severity = n.getEnumValue<ThreatSeverity>(ThreatSeverityObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedRemoteNetwork The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedRemoteNetwork(relatedRemoteNetwork: Partial<RelatedRemoteNetwork> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedRemoteNetwork),
        "remoteNetworkId": n => { relatedRemoteNetwork.remoteNetworkId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedResource The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedResource(relatedResource: Partial<RelatedResource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { relatedResource.backingStoreEnabled = true; },
        "@odata.type": n => { relatedResource.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedTenant The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedTenant(relatedTenant: Partial<RelatedTenant> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedTenant),
        "tenantId": n => { relatedTenant.tenantId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedThreatIntelligence The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedThreatIntelligence(relatedThreatIntelligence: Partial<RelatedThreatIntelligence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedThreatIntelligence),
        "threatCount": n => { relatedThreatIntelligence.threatCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedToken The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedToken(relatedToken: Partial<RelatedToken> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedToken),
        "uniqueTokenIdentifier": n => { relatedToken.uniqueTokenIdentifier = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedTransaction The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedTransaction(relatedTransaction: Partial<RelatedTransaction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedTransaction),
        "transactionId": n => { relatedTransaction.transactionId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedUrl The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedUrl(relatedUrl: Partial<RelatedUrl> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedUrl),
        "url": n => { relatedUrl.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedUser The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedUser(relatedUser: Partial<RelatedUser> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedUser),
        "userId": n => { relatedUser.userId = n.getStringValue(); },
        "userPrincipalName": n => { relatedUser.userPrincipalName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelatedWebCategory The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelatedWebCategory(relatedWebCategory: Partial<RelatedWebCategory> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRelatedResource(relatedWebCategory),
        "webCategoryName": n => { relatedWebCategory.webCategoryName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RemoteNetwork The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRemoteNetwork(remoteNetwork: Partial<RemoteNetwork> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(remoteNetwork),
        "connectivityConfiguration": n => { remoteNetwork.connectivityConfiguration = n.getObjectValue<RemoteNetworkConnectivityConfiguration>(createRemoteNetworkConnectivityConfigurationFromDiscriminatorValue); },
        "deviceLinks": n => { remoteNetwork.deviceLinks = n.getCollectionOfObjectValues<DeviceLink>(createDeviceLinkFromDiscriminatorValue); },
        "forwardingProfiles": n => { remoteNetwork.forwardingProfiles = n.getCollectionOfObjectValues<ForwardingProfile>(createForwardingProfileFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { remoteNetwork.lastModifiedDateTime = n.getDateValue(); },
        "name": n => { remoteNetwork.name = n.getStringValue(); },
        "region": n => { remoteNetwork.region = n.getEnumValue<Region>(RegionObject); },
        "version": n => { remoteNetwork.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RemoteNetworkCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRemoteNetworkCollectionResponse(remoteNetworkCollectionResponse: Partial<RemoteNetworkCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(remoteNetworkCollectionResponse),
        "value": n => { remoteNetworkCollectionResponse.value = n.getCollectionOfObjectValues<RemoteNetwork>(createRemoteNetworkFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param RemoteNetworkConnectivityConfiguration The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRemoteNetworkConnectivityConfiguration(remoteNetworkConnectivityConfiguration: Partial<RemoteNetworkConnectivityConfiguration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { remoteNetworkConnectivityConfiguration.backingStoreEnabled = true; },
        "links": n => { remoteNetworkConnectivityConfiguration.links = n.getCollectionOfObjectValues<ConnectivityConfigurationLink>(createConnectivityConfigurationLinkFromDiscriminatorValue); },
        "@odata.type": n => { remoteNetworkConnectivityConfiguration.odataType = n.getStringValue(); },
        "remoteNetworkId": n => { remoteNetworkConnectivityConfiguration.remoteNetworkId = n.getStringValue(); },
        "remoteNetworkName": n => { remoteNetworkConnectivityConfiguration.remoteNetworkName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RemoteNetworkHealthEvent The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRemoteNetworkHealthEvent(remoteNetworkHealthEvent: Partial<RemoteNetworkHealthEvent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(remoteNetworkHealthEvent),
        "bgpRoutesAdvertisedCount": n => { remoteNetworkHealthEvent.bgpRoutesAdvertisedCount = n.getNumberValue(); },
        "createdDateTime": n => { remoteNetworkHealthEvent.createdDateTime = n.getDateValue(); },
        "description": n => { remoteNetworkHealthEvent.description = n.getStringValue(); },
        "destinationIp": n => { remoteNetworkHealthEvent.destinationIp = n.getStringValue(); },
        "receivedBytes": n => { remoteNetworkHealthEvent.receivedBytes = n.getNumberValue(); },
        "remoteNetworkId": n => { remoteNetworkHealthEvent.remoteNetworkId = n.getStringValue(); },
        "sentBytes": n => { remoteNetworkHealthEvent.sentBytes = n.getNumberValue(); },
        "sourceIp": n => { remoteNetworkHealthEvent.sourceIp = n.getStringValue(); },
        "status": n => { remoteNetworkHealthEvent.status = n.getEnumValue<RemoteNetworkStatus>(RemoteNetworkStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param RemoteNetworkHealthEventCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRemoteNetworkHealthEventCollectionResponse(remoteNetworkHealthEventCollectionResponse: Partial<RemoteNetworkHealthEventCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(remoteNetworkHealthEventCollectionResponse),
        "value": n => { remoteNetworkHealthEventCollectionResponse.value = n.getCollectionOfObjectValues<RemoteNetworkHealthEvent>(createRemoteNetworkHealthEventFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Reports The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoReports(reports: Partial<Reports> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(reports),
    }
}
/**
 * The deserialization information for the current model
 * @param RuleDestination The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRuleDestination(ruleDestination: Partial<RuleDestination> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { ruleDestination.backingStoreEnabled = true; },
        "@odata.type": n => { ruleDestination.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Settings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSettings(settings: Partial<Settings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(settings),
        "conditionalAccess": n => { settings.conditionalAccess = n.getObjectValue<ConditionalAccessSettings>(createConditionalAccessSettingsFromDiscriminatorValue); },
        "crossTenantAccess": n => { settings.crossTenantAccess = n.getObjectValue<CrossTenantAccessSettings>(createCrossTenantAccessSettingsFromDiscriminatorValue); },
        "forwardingOptions": n => { settings.forwardingOptions = n.getObjectValue<ForwardingOptions>(createForwardingOptionsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TenantStatus The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTenantStatus(tenantStatus: Partial<TenantStatus> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(tenantStatus),
        "onboardingErrorMessage": n => { tenantStatus.onboardingErrorMessage = n.getStringValue(); },
        "onboardingStatus": n => { tenantStatus.onboardingStatus = n.getEnumValue<OnboardingStatus>(OnboardingStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param ThirdPartyTokenDetails The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoThirdPartyTokenDetails(thirdPartyTokenDetails: Partial<ThirdPartyTokenDetails> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { thirdPartyTokenDetails.backingStoreEnabled = true; },
        "expirationDateTime": n => { thirdPartyTokenDetails.expirationDateTime = n.getDateValue(); },
        "issuedAtDateTime": n => { thirdPartyTokenDetails.issuedAtDateTime = n.getDateValue(); },
        "@odata.type": n => { thirdPartyTokenDetails.odataType = n.getStringValue(); },
        "uniqueTokenIdentifier": n => { thirdPartyTokenDetails.uniqueTokenIdentifier = n.getStringValue(); },
        "validFromDateTime": n => { thirdPartyTokenDetails.validFromDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ThreatIntelligenceDestination The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoThreatIntelligenceDestination(threatIntelligenceDestination: Partial<ThreatIntelligenceDestination> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { threatIntelligenceDestination.backingStoreEnabled = true; },
        "@odata.type": n => { threatIntelligenceDestination.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ThreatIntelligenceFqdnDestination The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoThreatIntelligenceFqdnDestination(threatIntelligenceFqdnDestination: Partial<ThreatIntelligenceFqdnDestination> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoThreatIntelligenceDestination(threatIntelligenceFqdnDestination),
        "values": n => { threatIntelligenceFqdnDestination.values = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ThreatIntelligenceMatchingConditions The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoThreatIntelligenceMatchingConditions(threatIntelligenceMatchingConditions: Partial<ThreatIntelligenceMatchingConditions> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { threatIntelligenceMatchingConditions.backingStoreEnabled = true; },
        "destinations": n => { threatIntelligenceMatchingConditions.destinations = n.getCollectionOfObjectValues<ThreatIntelligenceDestination>(createThreatIntelligenceDestinationFromDiscriminatorValue); },
        "@odata.type": n => { threatIntelligenceMatchingConditions.odataType = n.getStringValue(); },
        "severity": n => { threatIntelligenceMatchingConditions.severity = n.getEnumValue<ThreatIntelligenceSeverity>(ThreatIntelligenceSeverityObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param ThreatIntelligencePolicy The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoThreatIntelligencePolicy(threatIntelligencePolicy: Partial<ThreatIntelligencePolicy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicy(threatIntelligencePolicy),
        "lastModifiedDateTime": n => { threatIntelligencePolicy.lastModifiedDateTime = n.getDateValue(); },
        "settings": n => { threatIntelligencePolicy.settings = n.getObjectValue<ThreatIntelligencePolicySettings>(createThreatIntelligencePolicySettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ThreatIntelligencePolicyCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoThreatIntelligencePolicyCollectionResponse(threatIntelligencePolicyCollectionResponse: Partial<ThreatIntelligencePolicyCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(threatIntelligencePolicyCollectionResponse),
        "value": n => { threatIntelligencePolicyCollectionResponse.value = n.getCollectionOfObjectValues<ThreatIntelligencePolicy>(createThreatIntelligencePolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ThreatIntelligencePolicyLink The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoThreatIntelligencePolicyLink(threatIntelligencePolicyLink: Partial<ThreatIntelligencePolicyLink> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicyLink(threatIntelligencePolicyLink),
    }
}
/**
 * The deserialization information for the current model
 * @param ThreatIntelligencePolicySettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoThreatIntelligencePolicySettings(threatIntelligencePolicySettings: Partial<ThreatIntelligencePolicySettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { threatIntelligencePolicySettings.backingStoreEnabled = true; },
        "defaultAction": n => { threatIntelligencePolicySettings.defaultAction = n.getEnumValue<ThreatIntelligenceAction>(ThreatIntelligenceActionObject); },
        "@odata.type": n => { threatIntelligencePolicySettings.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ThreatIntelligenceRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoThreatIntelligenceRule(threatIntelligenceRule: Partial<ThreatIntelligenceRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicyRule(threatIntelligenceRule),
        "action": n => { threatIntelligenceRule.action = n.getEnumValue<ThreatIntelligenceAction>(ThreatIntelligenceActionObject); },
        "description": n => { threatIntelligenceRule.description = n.getStringValue(); },
        "matchingConditions": n => { threatIntelligenceRule.matchingConditions = n.getObjectValue<ThreatIntelligenceMatchingConditions>(createThreatIntelligenceMatchingConditionsFromDiscriminatorValue); },
        "priority": n => { threatIntelligenceRule.priority = n.getNumberValue(); },
        "settings": n => { threatIntelligenceRule.settings = n.getObjectValue<ThreatIntelligenceRuleSettings>(createThreatIntelligenceRuleSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ThreatIntelligenceRuleSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoThreatIntelligenceRuleSettings(threatIntelligenceRuleSettings: Partial<ThreatIntelligenceRuleSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { threatIntelligenceRuleSettings.backingStoreEnabled = true; },
        "@odata.type": n => { threatIntelligenceRuleSettings.odataType = n.getStringValue(); },
        "status": n => { threatIntelligenceRuleSettings.status = n.getEnumValue<SecurityRuleStatus>(SecurityRuleStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param TlsInspectionDestination The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTlsInspectionDestination(tlsInspectionDestination: Partial<TlsInspectionDestination> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { tlsInspectionDestination.backingStoreEnabled = true; },
        "@odata.type": n => { tlsInspectionDestination.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TlsInspectionFqdnDestination The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTlsInspectionFqdnDestination(tlsInspectionFqdnDestination: Partial<TlsInspectionFqdnDestination> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoTlsInspectionDestination(tlsInspectionFqdnDestination),
        "values": n => { tlsInspectionFqdnDestination.values = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TlsInspectionMatchingConditions The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTlsInspectionMatchingConditions(tlsInspectionMatchingConditions: Partial<TlsInspectionMatchingConditions> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { tlsInspectionMatchingConditions.backingStoreEnabled = true; },
        "destinations": n => { tlsInspectionMatchingConditions.destinations = n.getCollectionOfObjectValues<TlsInspectionDestination>(createTlsInspectionDestinationFromDiscriminatorValue); },
        "@odata.type": n => { tlsInspectionMatchingConditions.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TlsInspectionPolicy The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTlsInspectionPolicy(tlsInspectionPolicy: Partial<TlsInspectionPolicy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicy(tlsInspectionPolicy),
        "lastModifiedDateTime": n => { tlsInspectionPolicy.lastModifiedDateTime = n.getDateValue(); },
        "settings": n => { tlsInspectionPolicy.settings = n.getObjectValue<TlsInspectionPolicySettings>(createTlsInspectionPolicySettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TlsInspectionPolicyCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTlsInspectionPolicyCollectionResponse(tlsInspectionPolicyCollectionResponse: Partial<TlsInspectionPolicyCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(tlsInspectionPolicyCollectionResponse),
        "value": n => { tlsInspectionPolicyCollectionResponse.value = n.getCollectionOfObjectValues<TlsInspectionPolicy>(createTlsInspectionPolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TlsInspectionPolicyLink The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTlsInspectionPolicyLink(tlsInspectionPolicyLink: Partial<TlsInspectionPolicyLink> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicyLink(tlsInspectionPolicyLink),
    }
}
/**
 * The deserialization information for the current model
 * @param TlsInspectionPolicySettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTlsInspectionPolicySettings(tlsInspectionPolicySettings: Partial<TlsInspectionPolicySettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { tlsInspectionPolicySettings.backingStoreEnabled = true; },
        "@odata.type": n => { tlsInspectionPolicySettings.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TlsInspectionRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTlsInspectionRule(tlsInspectionRule: Partial<TlsInspectionRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicyRule(tlsInspectionRule),
        "description": n => { tlsInspectionRule.description = n.getStringValue(); },
        "matchingConditions": n => { tlsInspectionRule.matchingConditions = n.getObjectValue<TlsInspectionMatchingConditions>(createTlsInspectionMatchingConditionsFromDiscriminatorValue); },
        "priority": n => { tlsInspectionRule.priority = n.getNumberValue(); },
        "settings": n => { tlsInspectionRule.settings = n.getObjectValue<TlsInspectionRuleSettings>(createTlsInspectionRuleSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TlsInspectionRuleSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTlsInspectionRuleSettings(tlsInspectionRuleSettings: Partial<TlsInspectionRuleSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { tlsInspectionRuleSettings.backingStoreEnabled = true; },
        "@odata.type": n => { tlsInspectionRuleSettings.odataType = n.getStringValue(); },
        "status": n => { tlsInspectionRuleSettings.status = n.getEnumValue<SecurityRuleStatus>(SecurityRuleStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param TlsInspectionWebCategoryDestination The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTlsInspectionWebCategoryDestination(tlsInspectionWebCategoryDestination: Partial<TlsInspectionWebCategoryDestination> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoTlsInspectionDestination(tlsInspectionWebCategoryDestination),
        "values": n => { tlsInspectionWebCategoryDestination.values = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TlsTermination The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTlsTermination(tlsTermination: Partial<TlsTermination> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(tlsTermination),
        "externalCertificateAuthorityCertificates": n => { tlsTermination.externalCertificateAuthorityCertificates = n.getCollectionOfObjectValues<ExternalCertificateAuthorityCertificate>(createExternalCertificateAuthorityCertificateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TransactionSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTransactionSummary(transactionSummary: Partial<TransactionSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { transactionSummary.backingStoreEnabled = true; },
        "blockedCount": n => { transactionSummary.blockedCount = n.getNumberValue(); },
        "@odata.type": n => { transactionSummary.odataType = n.getStringValue(); },
        "totalCount": n => { transactionSummary.totalCount = n.getNumberValue(); },
        "trafficType": n => { transactionSummary.trafficType = n.getEnumValue<TrafficType>(TrafficTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param TunnelConfiguration The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTunnelConfiguration(tunnelConfiguration: Partial<TunnelConfiguration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { tunnelConfiguration.backingStoreEnabled = true; },
        "@odata.type": n => { tunnelConfiguration.odataType = n.getStringValue(); },
        "preSharedKey": n => { tunnelConfiguration.preSharedKey = n.getStringValue(); },
        "zoneRedundancyPreSharedKey": n => { tunnelConfiguration.zoneRedundancyPreSharedKey = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TunnelConfigurationIKEv2Custom The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTunnelConfigurationIKEv2Custom(tunnelConfigurationIKEv2Custom: Partial<TunnelConfigurationIKEv2Custom> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoTunnelConfiguration(tunnelConfigurationIKEv2Custom),
        "dhGroup": n => { tunnelConfigurationIKEv2Custom.dhGroup = n.getEnumValue<DhGroup>(DhGroupObject); },
        "ikeEncryption": n => { tunnelConfigurationIKEv2Custom.ikeEncryption = n.getEnumValue<IkeEncryption>(IkeEncryptionObject); },
        "ikeIntegrity": n => { tunnelConfigurationIKEv2Custom.ikeIntegrity = n.getEnumValue<IkeIntegrity>(IkeIntegrityObject); },
        "ipSecEncryption": n => { tunnelConfigurationIKEv2Custom.ipSecEncryption = n.getEnumValue<IpSecEncryption>(IpSecEncryptionObject); },
        "ipSecIntegrity": n => { tunnelConfigurationIKEv2Custom.ipSecIntegrity = n.getEnumValue<IpSecIntegrity>(IpSecIntegrityObject); },
        "pfsGroup": n => { tunnelConfigurationIKEv2Custom.pfsGroup = n.getEnumValue<PfsGroup>(PfsGroupObject); },
        "saLifeTimeSeconds": n => { tunnelConfigurationIKEv2Custom.saLifeTimeSeconds = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TunnelConfigurationIKEv2Default The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTunnelConfigurationIKEv2Default(tunnelConfigurationIKEv2Default: Partial<TunnelConfigurationIKEv2Default> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoTunnelConfiguration(tunnelConfigurationIKEv2Default),
    }
}
/**
 * The deserialization information for the current model
 * @param Url The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUrl(url: Partial<Url> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRuleDestination(url),
        "value": n => { url.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UsageProfilingPoint The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUsageProfilingPoint(usageProfilingPoint: Partial<UsageProfilingPoint> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { usageProfilingPoint.backingStoreEnabled = true; },
        "internetAccessTrafficCount": n => { usageProfilingPoint.internetAccessTrafficCount = n.getNumberValue(); },
        "microsoft365AccessTrafficCount": n => { usageProfilingPoint.microsoft365AccessTrafficCount = n.getNumberValue(); },
        "@odata.type": n => { usageProfilingPoint.odataType = n.getStringValue(); },
        "privateAccessTrafficCount": n => { usageProfilingPoint.privateAccessTrafficCount = n.getNumberValue(); },
        "timeStampDateTime": n => { usageProfilingPoint.timeStampDateTime = n.getDateValue(); },
        "totalTrafficCount": n => { usageProfilingPoint.totalTrafficCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param User The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUser(user: Partial<User> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { user.backingStoreEnabled = true; },
        "displayName": n => { user.displayName = n.getStringValue(); },
        "firstAccessDateTime": n => { user.firstAccessDateTime = n.getDateValue(); },
        "lastAccessDateTime": n => { user.lastAccessDateTime = n.getDateValue(); },
        "@odata.type": n => { user.odataType = n.getStringValue(); },
        "totalBytesReceived": n => { user.totalBytesReceived = n.getNumberValue(); },
        "totalBytesSent": n => { user.totalBytesSent = n.getNumberValue(); },
        "trafficType": n => { user.trafficType = n.getEnumValue<TrafficType>(TrafficTypeObject); },
        "transactionCount": n => { user.transactionCount = n.getNumberValue(); },
        "userId": n => { user.userId = n.getStringValue(); },
        "userPrincipalName": n => { user.userPrincipalName = n.getStringValue(); },
        "userType": n => { user.userType = n.getEnumValue<UserType>(UserTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param ValidityDate The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoValidityDate(validityDate: Partial<ValidityDate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { validityDate.backingStoreEnabled = true; },
        "endDateTime": n => { validityDate.endDateTime = n.getDateValue(); },
        "@odata.type": n => { validityDate.odataType = n.getStringValue(); },
        "startDateTime": n => { validityDate.startDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param WebCategoriesSummary The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWebCategoriesSummary(webCategoriesSummary: Partial<WebCategoriesSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "action": n => { webCategoriesSummary.action = n.getEnumValue<FilteringPolicyAction>(FilteringPolicyActionObject); },
        "backingStoreEnabled": n => { webCategoriesSummary.backingStoreEnabled = true; },
        "deviceCount": n => { webCategoriesSummary.deviceCount = n.getNumberValue(); },
        "@odata.type": n => { webCategoriesSummary.odataType = n.getStringValue(); },
        "transactionCount": n => { webCategoriesSummary.transactionCount = n.getNumberValue(); },
        "userCount": n => { webCategoriesSummary.userCount = n.getNumberValue(); },
        "webCategory": n => { webCategoriesSummary.webCategory = n.getObjectValue<WebCategory>(createWebCategoryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param WebCategory The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWebCategory(webCategory: Partial<WebCategory> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRuleDestination(webCategory),
        "displayName": n => { webCategory.displayName = n.getStringValue(); },
        "group": n => { webCategory.group = n.getStringValue(); },
        "name": n => { webCategory.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param WebCategoryFilteringRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWebCategoryFilteringRule(webCategoryFilteringRule: Partial<WebCategoryFilteringRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFilteringRule(webCategoryFilteringRule),
    }
}
export interface Destination extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The number of unique devices that were seen.
     */
    deviceCount?: number | null;
    /**
     * The firstAccessDateTime property
     */
    firstAccessDateTime?: Date | null;
    /**
     * The fully qualified domain name (FQDN) of the destination.
     */
    fqdn?: string | null;
    /**
     * The internet protocol (IP) used to access the destination.
     */
    ip?: string | null;
    /**
     * The most recent access DateTime.
     */
    lastAccessDateTime?: Date | null;
    /**
     * The networkingProtocol property
     */
    networkingProtocol?: NetworkingProtocol | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The numeric identifier that is associated with a specific endpoint in a network.
     */
    port?: number | null;
    /**
     * The threatCount property
     */
    threatCount?: number | null;
    /**
     * The totalBytesReceived property
     */
    totalBytesReceived?: number | null;
    /**
     * The totalBytesSent property
     */
    totalBytesSent?: number | null;
    /**
     * The trafficType property
     */
    trafficType?: TrafficType | null;
    /**
     * The number of transactions.
     */
    transactionCount?: number | null;
    /**
     * The number of unique Microsoft Entra ID users that were seen.
     */
    userCount?: number | null;
}
export interface DestinationSummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The number of the destinationSummary objects, aggregated by Global Secure Access service.
     */
    count?: number | null;
    /**
     * The IP address or FQDN of the destination.
     */
    destination?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The traffic classification. The allowed values are internet, private, microsoft365, all, and unknownFutureValue.
     */
    trafficType?: TrafficType | null;
}
export interface Device extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * A unique device ID.
     */
    deviceId?: string | null;
    /**
     * The display name for the device.
     */
    displayName?: string | null;
    /**
     * A value that indicates whether or not the device is compliant.
     */
    isCompliant?: boolean | null;
    /**
     * The most recent access time for the device.
     */
    lastAccessDateTime?: Date | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The operating system on the device.
     */
    operatingSystem?: string | null;
    /**
     * The trafficType property
     */
    trafficType?: TrafficType | null;
}
export type DeviceCategory = (typeof DeviceCategoryObject)[keyof typeof DeviceCategoryObject];
export interface DeviceLink extends Entity, Parsable {
    /**
     * Determines the maximum allowed Mbps (megabits per second) bandwidth from a device link. The possible values are:250,500,750,1000.
     */
    bandwidthCapacityInMbps?: BandwidthCapacityInMbps | null;
    /**
     * The bgpConfiguration property
     */
    bgpConfiguration?: BgpConfiguration | null;
    /**
     * The deviceVendor property
     */
    deviceVendor?: DeviceVendor | null;
    /**
     * The public IP address of your CPE (customer premise equipment) device.
     */
    ipAddress?: string | null;
    /**
     * last modified time.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * Name.
     */
    name?: string | null;
    /**
     * The redundancyConfiguration property
     */
    redundancyConfiguration?: RedundancyConfiguration | null;
    /**
     * The tunnelConfiguration property
     */
    tunnelConfiguration?: TunnelConfiguration | null;
}
export interface DeviceLinkCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: DeviceLink[] | null;
}
export interface DeviceUsageSummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The number of distinct device IDs between the discovery pivot time and the end of the reporting period.
     */
    activeDeviceCount?: number | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The discovery pivot time and the end of the reporting period, but were seen between the start of the reporting period and the discovery pivot time.
     */
    inactiveDeviceCount?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The total number of distinct device IDs that were seen during the reporting period.
     */
    totalDeviceCount?: number | null;
}
export type DeviceVendor = (typeof DeviceVendorObject)[keyof typeof DeviceVendorObject];
export type DhGroup = (typeof DhGroupObject)[keyof typeof DhGroupObject];
export interface DiscoveredApplicationSegmentReport extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The type of access used to connect to this application segment. The possible values are: quickAccess, privateAccess, unknownFutureValue, appAccess. Use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: appAccess.
     */
    accessType?: AccessType | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The number of unique devices that have accessed this application segment.
     */
    deviceCount?: number | null;
    /**
     * The unique identifier for this discovered application segment.
     */
    discoveredApplicationSegmentId?: string | null;
    /**
     * The date and time when this application segment was first accessed.
     */
    firstAccessDateTime?: Date | null;
    /**
     * The fully qualified domain name associated with this application segment.
     */
    fqdn?: string | null;
    /**
     * The IP address associated with this application segment.
     */
    ip?: string | null;
    /**
     * The date and time when this application segment was last accessed.
     */
    lastAccessDateTime?: Date | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The port number used to access this application segment.
     */
    port?: number | null;
    /**
     * The total number of bytes received from this application segment.
     */
    totalBytesReceived?: number | null;
    /**
     * The total number of bytes sent to this application segment.
     */
    totalBytesSent?: number | null;
    /**
     * The number of transactions recorded for this application segment.
     */
    transactionCount?: number | null;
    /**
     * The transportProtocol property
     */
    transportProtocol?: NetworkingProtocol | null;
    /**
     * The number of unique users who have accessed this application segment.
     */
    userCount?: number | null;
}
export interface EntitiesSummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The number of devices in the summary. Required.
     */
    deviceCount?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The trafficType property
     */
    trafficType?: TrafficType | null;
    /**
     * The number of users in the summary. Required.
     */
    userCount?: number | null;
    /**
     * The number of workloads in the summary. Required.
     */
    workloadCount?: number | null;
}
export interface ExtendedProperties extends Dictionary, Parsable {
}
export interface ExternalCertificateAuthorityCertificate extends Entity, Parsable {
    /**
     * The signed X.509 certificate in PEM format.
     */
    certificate?: string | null;
    /**
     * The Certificate Signing Request (CSR) generated when creating the CA. This CSR should be signed using the customer's PKI infrastructure. Read-only.
     */
    certificateSigningRequest?: string | null;
    /**
     * The certificate chain in PEM format, containing all intermediate certificates up to the root CA.
     */
    chain?: string | null;
    /**
     * The common name (CN) field of the certificate. Supports $filter (eq, ne, startsWith)
     */
    commonName?: string | null;
    /**
     * The display name of the CA. Supports $filter (eq, ne, startsWith)
     */
    name?: string | null;
    /**
     * The organization name (OU) field of the certificate. Supports $filter (eq, ne, startsWith)
     */
    organizationName?: string | null;
    /**
     * The status property
     */
    status?: TlsCertificateStatus | null;
    /**
     * The validity property
     */
    validity?: ValidityDate | null;
}
export interface ExternalCertificateAuthorityCertificateCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ExternalCertificateAuthorityCertificate[] | null;
}
export interface FilteringPolicy extends Parsable, Policy {
    /**
     * The action property
     */
    action?: FilteringPolicyAction | null;
    /**
     * The date and time when the filtering Policy was originally created.
     */
    createdDateTime?: Date | null;
    /**
     * The date and time when a particular profile was last modified or updated.
     */
    lastModifiedDateTime?: Date | null;
}
export type FilteringPolicyAction = (typeof FilteringPolicyActionObject)[keyof typeof FilteringPolicyActionObject];
export interface FilteringPolicyCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: FilteringPolicy[] | null;
}
export interface FilteringPolicyLink extends Parsable, PolicyLink {
    /**
     * The date and time when the filtering Policy link was created.
     */
    createdDateTime?: Date | null;
    /**
     * The date and time when the policy was most recently modified.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * The loggingState property
     */
    loggingState?: Status | null;
    /**
     * Provides an integer priority level for each instance of a URL filtering policy linked to a profile. Required.
     */
    priority?: number | null;
}
export interface FilteringProfile extends Parsable, Profile {
    /**
     * A set of associated policies defined to regulate access to resources or systems based on specific conditions. Automatically expanded.
     */
    conditionalAccessPolicies?: ConditionalAccessPolicy[] | null;
    /**
     * The date and time when the filteringProfile was created.
     */
    createdDateTime?: Date | null;
    /**
     * The priority used to order the profile for processing within a list.
     */
    priority?: number | null;
}
export interface FilteringProfileCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: FilteringProfile[] | null;
}
export interface FilteringRule extends Parsable, PolicyRule {
    /**
     * Possible destinations and types of destinations accessed by the user in accordance with the network filtering policy, such as IP addresses and FQDNs/URLs.
     */
    destinations?: RuleDestination[] | null;
    /**
     * The ruleType property
     */
    ruleType?: NetworkDestinationType | null;
}
export type ForwardingCategory = (typeof ForwardingCategoryObject)[keyof typeof ForwardingCategoryObject];
export interface ForwardingOptions extends Entity, Parsable {
    /**
     * The skipDnsLookupState property
     */
    skipDnsLookupState?: Status | null;
}
export interface ForwardingPolicy extends Parsable, Policy {
    /**
     * The trafficForwardingType property
     */
    trafficForwardingType?: TrafficForwardingType | null;
}
export interface ForwardingPolicyCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ForwardingPolicy[] | null;
}
export interface ForwardingPolicyLink extends Parsable, PolicyLink {
}
export interface ForwardingProfile extends Parsable, Profile {
    /**
     * Specifies the users, groups, devices, and remote networks whose traffic is associated with the given traffic forwarding profile.
     */
    associations?: Association[] | null;
    /**
     * Profile priority.
     */
    priority?: number | null;
    /**
     * The servicePrincipal property
     */
    servicePrincipal?: ServicePrincipal | null;
    /**
     * The trafficForwardingType property
     */
    trafficForwardingType?: TrafficForwardingType | null;
}
export interface ForwardingProfileCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ForwardingProfile[] | null;
}
export interface ForwardingRule extends Parsable, PolicyRule {
    /**
     * The action property
     */
    action?: ForwardingRuleAction | null;
    /**
     * The clientFallbackAction property
     */
    clientFallbackAction?: ClientFallbackAction | null;
    /**
     * Destinations maintain a list of potential destinations and destination types that the user may access within the context of a network filtering policy. This includes IP addresses and fully qualified domain names (FQDNs)/URLs.
     */
    destinations?: RuleDestination[] | null;
    /**
     * The ruleType property
     */
    ruleType?: NetworkDestinationType | null;
}
export type ForwardingRuleAction = (typeof ForwardingRuleActionObject)[keyof typeof ForwardingRuleActionObject];
export interface Fqdn extends Parsable, RuleDestination {
    /**
     * Defines the FQDN used in a destination for a rule.
     */
    value?: string | null;
}
export interface FqdnFilteringRule extends FilteringRule, Parsable {
}
export interface Headers extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Represents the origin or source from which the request is being made.
     */
    origin?: string | null;
    /**
     * Represents the referring URL or the URL of the web page that the current request originates from.
     */
    referrer?: string | null;
    /**
     * Represents the information about the client original IP address when the request passes through one or more proxy servers or load balancers.
     */
    xForwardedFor?: string | null;
}
export type HttpMethod = (typeof HttpMethodObject)[keyof typeof HttpMethodObject];
export type IkeEncryption = (typeof IkeEncryptionObject)[keyof typeof IkeEncryptionObject];
export type IkeIntegrity = (typeof IkeIntegrityObject)[keyof typeof IkeIntegrityObject];
export type IntentCategory = (typeof IntentCategoryObject)[keyof typeof IntentCategoryObject];
export interface InternetAccessForwardingRule extends ForwardingRule, Parsable {
    /**
     * The ports property
     */
    ports?: string[] | null;
    /**
     * The protocol property
     */
    protocol?: NetworkingProtocol | null;
}
export interface IpAddress extends Parsable, RuleDestination {
    /**
     * Defines the IP address used in a destination for a rule.
     */
    value?: string | null;
}
export interface IpRange extends Parsable, RuleDestination {
    /**
     * Specifies the starting IP address of the IP range.
     */
    beginAddress?: string | null;
    /**
     * Specifies the ending IP address of the IP range.
     */
    endAddress?: string | null;
}
export type IpSecEncryption = (typeof IpSecEncryptionObject)[keyof typeof IpSecEncryptionObject];
export type IpSecIntegrity = (typeof IpSecIntegrityObject)[keyof typeof IpSecIntegrityObject];
export interface IpSubnet extends Parsable, RuleDestination {
    /**
     * Defines the IP address of the subset used in a destination for a rule.
     */
    value?: string | null;
}
export interface LocalConnectivityConfiguration extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Specifies ASN of one end of IPSec tunnel (local or peer).
     */
    asn?: number | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Specifies BGP IPv4 address of one end of IPSec tunnel (local or peer).
     */
    bgpAddress?: string | null;
    /**
     * Specifies public IPv4 address of one end of IPSec tunnel (local or peer).
     */
    endpoint?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The region property
     */
    region?: Region | null;
}
export interface Logs extends Entity, Parsable {
    /**
     * An aggregated log entry that contains comprehensive information about network traffic events.
     */
    connections?: Connection[] | null;
    /**
     * A collection of remote network health events.
     */
    remoteNetworks?: RemoteNetworkHealthEvent[] | null;
    /**
     * A network access traffic log entry that contains comprehensive information about network traffic events.
     */
    traffic?: NetworkAccessTraffic[] | null;
}
export interface M365ForwardingRule extends ForwardingRule, Parsable {
    /**
     * The category property
     */
    category?: ForwardingCategory | null;
    /**
     * The port(s) used by a forwarding rule for Microsoft 365 traffic are specified to determine the specific network port(s) through which the Microsoft 365 traffic is directed and forwarded.
     */
    ports?: string[] | null;
    /**
     * The protocol property
     */
    protocol?: NetworkingProtocol | null;
}
export type MalwareCategory = (typeof MalwareCategoryObject)[keyof typeof MalwareCategoryObject];
export interface NetworkAccessRoot extends Entity, Parsable {
    /**
     * The alerts property
     */
    alerts?: Alert[] | null;
    /**
     * Connectivity represents all the connectivity components in Global Secure Access.
     */
    connectivity?: Connectivity | null;
    /**
     * A filtering policy defines the specific traffic that is allowed or blocked through the Global Secure Access services for a filtering profile.
     */
    filteringPolicies?: FilteringPolicy[] | null;
    /**
     * A filtering profile associates network access policies with Microsoft Entra ID Conditional Access policies, so that access policies can be applied to users and groups.
     */
    filteringProfiles?: FilteringProfile[] | null;
    /**
     * The forwardingPolicies property
     */
    forwardingPolicies?: ForwardingPolicy[] | null;
    /**
     * The forwardingProfiles property
     */
    forwardingProfiles?: ForwardingProfile[] | null;
    /**
     * Represents network connections that are routed through Global Secure Access.
     */
    logs?: Logs | null;
    /**
     * Represents the status of the Global Secure Access services for the tenant.
     */
    reports?: Reports | null;
    /**
     * Global Secure Access settings.
     */
    settings?: Settings | null;
    /**
     * Represents the status of the Global Secure Access services for the tenant.
     */
    tenantStatus?: TenantStatus | null;
    /**
     * The threatIntelligencePolicies property
     */
    threatIntelligencePolicies?: ThreatIntelligencePolicy[] | null;
    /**
     * A container for tenant-level TLS inspection settings for Global Secure Access.
     */
    tls?: TlsTermination | null;
    /**
     * Allows you to configure TLS termination for your organization's network traffic through Global Secure Access.
     */
    tlsInspectionPolicies?: TlsInspectionPolicy[] | null;
}
export interface NetworkAccessTraffic extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Indicates the action taken based on filtering policies. The possible values are: block, allow, unknownFutureValue, bypass, alert. Use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: bypass , alert.
     */
    action?: FilteringPolicyAction | null;
    /**
     * Represents the version of the Global Secure Access (GSA) client agent software. Supports $filter (eq) and $orderby.
     */
    agentVersion?: string | null;
    /**
     * Destination Application ID accessed in Azure AD during the transaction. Supports $filter (eq) and $orderby.
     */
    applicationSnapshot?: ApplicationSnapshot | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Represents a unique identifier assigned to a connection. Supports $filter (eq) and $orderby.
     */
    connectionId?: string | null;
    /**
     * Represents the date and time when a network access traffic log entry was created. Supports $filter (eq) and $orderby.
     */
    createdDateTime?: Date | null;
    /**
     * Informational error message. For example: 'Threat intelligence detected a transaction and triggered an alert.' or 'The Global Secure Access (GSA) policy blocked the destination and triggered an alert.' Supports $filter (eq) and $orderby.
     */
    description?: string | null;
    /**
     * Represents the Fully Qualified Domain Name (FQDN) of the destination host or server in a network communication. Supports $filter (eq) and $orderby.
     */
    destinationFQDN?: string | null;
    /**
     * Represents the IP address of the destination host or server in a network communication. Supports $filter (eq) and $orderby.
     */
    destinationIp?: string | null;
    /**
     * Represents the network port number on the destination host or server in a network communication. Supports $filter (eq) and $orderby.
     */
    destinationPort?: number | null;
    /**
     * Represents the URL of the destination in a network communication. Supports $filter (eq) and $orderby.
     */
    destinationUrl?: string | null;
    /**
     * The destination FQDN's Web Category (e.g., Gambling). Supports $filter (eq) and $orderby.
     */
    destinationWebCategory?: WebCategory | null;
    /**
     * Represents the device associated with the network traffic, providing details about the hardware or virtual machine involved in the transaction.
     */
    device?: I353170b9ab043a51be0a29bf9ffeadaa40f51ff6511c066ae82d223c77decf60 | null;
    /**
     * Represents the category classification of a device within a network infrastructure. The possible values are: client, branch, unknownFutureValue. Supports $filter (eq) and $orderby.
     */
    deviceCategory?: DeviceCategory | null;
    /**
     * Represents a unique identifier assigned to a device within a network infrastructure. Supports $filter (eq) and $orderby.
     */
    deviceId?: string | null;
    /**
     * Represents the operating system installed on a device within a network infrastructure. Supports $filter (eq) and $orderby.
     */
    deviceOperatingSystem?: string | null;
    /**
     * Represents the version or release number of the operating system installed on a device within a network infrastructure. Supports $filter (eq) and $orderby.
     */
    deviceOperatingSystemVersion?: string | null;
    /**
     * The ID of the Filtering Profile associated with the action performed on traffic. Supports $filter (eq) and $orderby.
     */
    filteringProfileId?: string | null;
    /**
     * The name of the Filtering Profile associated with the action performed on traffic. Supports $filter (eq) and $orderby.
     */
    filteringProfileName?: string | null;
    /**
     * Represents the headers included in a network request or response. Supports $filter (eq) and $orderby.
     */
    headers?: Headers | null;
    /**
     * The HTTP method inspected in the intercepted HTTP traffic. Supports $filter (eq) and $orderby.
     */
    httpMethod?: HttpMethod | null;
    /**
     * The process initiating the traffic transaction. Supports $filter (eq) and $orderby.
     */
    initiatingProcessName?: string | null;
    /**
     * Represents the networking protocol used for communication. The possible values are: ip, icmp, igmp, ggp, ipv4, tcp, pup, udp, idp, ipv6, ipv6RoutingHeader, ipv6FragmentHeader, ipSecEncapsulatingSecurityPayload, ipSecAuthenticationHeader, icmpV6, ipv6NoNextHeader, ipv6DestinationOptions, nd, raw, ipx, spx, spxII, unknownFutureValue. Supports $filter (eq) and $orderby.
     */
    networkProtocol?: NetworkingProtocol | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Indication if traffic was successfully processed. The possible values are: success, failure, unknownFutureValue. Supports $filter (eq) and $orderby.
     */
    operationStatus?: NetworkTrafficOperationStatus | null;
    /**
     * Represents a unique identifier assigned to a policy. Supports $filter (eq) and $orderby.
     */
    policyId?: string | null;
    /**
     * The name of the filtering policy associated with the action performed on traffic. Supports $filter (eq) and $orderby.
     */
    policyName?: string | null;
    /**
     * Represents a unique identifier assigned to a policy rule. Supports $filter (eq) and $orderby.
     */
    policyRuleId?: string | null;
    /**
     * The name of the rule associated with the action performed on traffic. Supports $filter (eq) and $orderby.
     */
    policyRuleName?: string | null;
    /**
     * The Point-of-Presence processing region of the traffic. Supports $filter (eq) and $orderby.
     */
    popProcessingRegion?: string | null;
    /**
     * Details about private access traffic. Supports $filter (eq) and $orderby.
     */
    privateAccessDetails?: PrivateAccessDetails | null;
    /**
     * Represents the total number of bytes received in a network communication or data transfer. Supports $filter (eq) and $orderby.
     */
    receivedBytes?: number | null;
    /**
     * The ID from which traffic was sent or received, providing visibility into the origin of the traffic. Supports $filter (eq) and $orderby.
     */
    remoteNetworkId?: string | null;
    /**
     * Tenant ID that owns the resource. Supports $filter (eq) and $orderby.
     */
    resourceTenantId?: string | null;
    /**
     * The HTTP response code inspected in the intercepted HTTP traffic. Supports $filter (eq) and $orderby.
     */
    responseCode?: number | null;
    /**
     * Represents the total number of bytes sent in a network communication or data transfer. Supports $filter (eq) and $orderby.
     */
    sentBytes?: number | null;
    /**
     * Represents a unique identifier assigned to a session or connection within a network infrastructure. Supports $filter (eq) and $orderby.
     */
    sessionId?: string | null;
    /**
     * Represents the source IP address in a network communication. Supports $filter (eq) and $orderby.
     */
    sourceIp?: string | null;
    /**
     * Represents the network port number on the source host or device in a network communication. Supports $filter (eq) and $orderby.
     */
    sourcePort?: number | null;
    /**
     * Represents a unique identifier assigned to a tenant within a network infrastructure. Supports $filter (eq) and $orderby.
     */
    tenantId?: string | null;
    /**
     * The type of threat detected in the traffic. Supports $filter (eq) and $orderby.
     */
    threatType?: string | null;
    /**
     * The trafficType property
     */
    trafficType?: TrafficType | null;
    /**
     * Represents a unique identifier assigned to a specific transaction or operation. Key. Supports $filter (eq) and $orderby.
     */
    transactionId?: string | null;
    /**
     * Represents the transport protocol used for communication. The possible values are: ip, icmp, igmp, ggp, ipv4, tcp, pup, udp, idp, ipv6, ipv6RoutingHeader, ipv6FragmentHeader, ipSecEncapsulatingSecurityPayload, ipSecAuthenticationHeader, icmpV6, ipv6NoNextHeader, ipv6DestinationOptions, nd, raw, ipx, spx, spxII, unknownFutureValue. Supports $filter (eq) and $orderby.
     */
    transportProtocol?: NetworkingProtocol | null;
    /**
     * Represents the user associated with the network traffic, providing details about the individual or account initiating the transaction.
     */
    user?: I4bfcbb20fa90605575bab96c7572912b314f024f9b0899d027a654508ef72465 | null;
    /**
     * Represents a unique identifier assigned to a user. Supports $filter (eq) and $orderby.
     */
    userId?: string | null;
    /**
     * Represents the user principal name (UPN) associated with a user. Supports $filter (eq) and $orderby.
     */
    userPrincipalName?: string | null;
    /**
     * The name of the vendors who detected the threat. Supports $filter (eq) and $orderby.
     */
    vendorNames?: string[] | null;
}
export interface NetworkAccessTrafficCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: NetworkAccessTraffic[] | null;
}
export type NetworkDestinationType = (typeof NetworkDestinationTypeObject)[keyof typeof NetworkDestinationTypeObject];
export type NetworkingProtocol = (typeof NetworkingProtocolObject)[keyof typeof NetworkingProtocolObject];
export type NetworkTrafficOperationStatus = (typeof NetworkTrafficOperationStatusObject)[keyof typeof NetworkTrafficOperationStatusObject];
export type OnboardingStatus = (typeof OnboardingStatusObject)[keyof typeof OnboardingStatusObject];
export interface PeerConnectivityConfiguration extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Specifies ASN of one end of IPSec tunnel (local or peer).
     */
    asn?: number | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Specifies BGP IPv4 address of one end of IPSec tunnel (local or peer).
     */
    bgpAddress?: string | null;
    /**
     * Specifies public IPv4 address of one end of IPSec tunnel (local or peer).
     */
    endpoint?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export type PfsGroup = (typeof PfsGroupObject)[keyof typeof PfsGroupObject];
export interface Policy extends Entity, Parsable {
    /**
     * Description.
     */
    description?: string | null;
    /**
     * Policy name.
     */
    name?: string | null;
    /**
     * Represents the definition of the policy ruleset that makes up the core definition of a policy.
     */
    policyRules?: PolicyRule[] | null;
    /**
     * Version.
     */
    version?: string | null;
}
export interface PolicyLink extends Entity, Parsable {
    /**
     * The policy property
     */
    policy?: Policy | null;
    /**
     * The state property
     */
    state?: Status | null;
    /**
     * Version.
     */
    version?: string | null;
}
export interface PolicyLinkCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: PolicyLink[] | null;
}
export interface PolicyRule extends Entity, Parsable {
    /**
     * Name.
     */
    name?: string | null;
}
export interface PolicyRuleCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: PolicyRule[] | null;
}
export interface PolicyRuleDelta extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The action property
     */
    action?: ForwardingRuleAction | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The identifier of the policy rule to update.
     */
    ruleId?: string | null;
}
export interface PrivateAccessDetails extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Type of accessed application. Access type options: QuickAccess, PrivateAccess.
     */
    accessType?: AccessType | null;
    /**
     * The unique identifier for Application segment ID from Azure AD.
     */
    appSegmentId?: string | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Status of a connection. Status options: Open, Active, Closed.
     */
    connectionStatus?: ConnectionStatus | null;
    /**
     * Private access connector ID.
     */
    connectorId?: string | null;
    /**
     * Private access connector IP address.
     */
    connectorIp?: string | null;
    /**
     * Private access connector name.
     */
    connectorName?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Region where the request was processed by the backend service.
     */
    processingRegion?: string | null;
    /**
     * Details about third-party tokens used in the transaction.
     */
    thirdPartyTokenDetails?: ThirdPartyTokenDetails | null;
}
export interface PrivateAccessForwardingRule extends ForwardingRule, Parsable {
}
export interface Profile extends Entity, Parsable {
    /**
     * Description.
     */
    description?: string | null;
    /**
     * The date and time when the profile was last modified.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * The name of the profile.
     */
    name?: string | null;
    /**
     * The traffic forwarding policies associated with this profile.
     */
    policies?: PolicyLink[] | null;
    /**
     * The state property
     */
    state?: Status | null;
    /**
     * Profile version.
     */
    version?: string | null;
}
export interface RedundancyConfiguration extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The redundancyTier property
     */
    redundancyTier?: RedundancyTier | null;
    /**
     * Indicate the specific IP address used for establishing the Border Gateway Protocol (BGP) connection with Microsoft's network.
     */
    zoneLocalIpAddress?: string | null;
}
export type RedundancyTier = (typeof RedundancyTierObject)[keyof typeof RedundancyTierObject];
export type Region = (typeof RegionObject)[keyof typeof RegionObject];
export interface RelatedDestination extends Parsable, RelatedResource {
    /**
     * Fully qualified domain name of the destination. Required.
     */
    fqdn?: string | null;
    /**
     * IP address of the destination. Required.
     */
    ip?: string | null;
    /**
     * The networkingProtocol property
     */
    networkingProtocol?: NetworkingProtocol | null;
    /**
     * Port number used to access the destination. Required.
     */
    port?: number | null;
}
export interface RelatedDevice extends Parsable, RelatedResource {
    /**
     * Unique identifier of the device involved in the alert. Required.
     */
    deviceId?: string | null;
}
export interface RelatedFile extends Parsable, RelatedResource {
    /**
     * Directory path of the file. Required.
     */
    directory?: string | null;
    /**
     * Name of the file. Required.
     */
    name?: string | null;
    /**
     * Size of the file in bytes. Required.
     */
    sizeInBytes?: number | null;
}
export interface RelatedFileHash extends Parsable, RelatedResource {
    /**
     * The algorithm property
     */
    algorithm?: Algorithm | null;
    /**
     * The hash value. Required.
     */
    value?: string | null;
}
export interface RelatedMalware extends Parsable, RelatedResource {
    /**
     * Category of the malware. Required. The possible values are: adware, backdoor, behavior, bot, browserModifier, constructor, cryptojacking, ddos, dropper, dropperMalware, exploit, filelessMalware, hackTool, hybridMalware, joke, keylogger, misleading, monitoringTool, polymorphicMalware, passwordStealer, program, ransomware, remoteAccess, rogue, rootkit, settingsModifier, softwareBundler, spammer, spoofer, spyware, tool, trojan, trojanClicker, trojanDownloader, trojanNotifier, trojanProxy, trojanSpy, virus, wiperMalware, worm, unknownFutureValue, potentiallyUnwantedApplication, infostealer, unknown, phishing, obfuscatedMalware, coinMiner, dialer, grayware. Use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: potentiallyUnwantedApplication , infostealer , unknown , phishing , obfuscatedMalware , coinMiner , dialer , grayware.
     */
    category?: MalwareCategory | null;
    /**
     * Name of the malware. Required.
     */
    name?: string | null;
    /**
     * Severity of the malware. Required. The possible values are: low, medium, high, critical, unknownFutureValue.
     */
    severity?: ThreatSeverity | null;
}
export interface RelatedRemoteNetwork extends Parsable, RelatedResource {
    /**
     * Unique identifier of the remote network. Required.
     */
    remoteNetworkId?: string | null;
}
export interface RelatedResource extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface RelatedTenant extends Parsable, RelatedResource {
    /**
     * Unique identifier of the tenant. Required.
     */
    tenantId?: string | null;
}
export interface RelatedThreatIntelligence extends Parsable, RelatedResource {
    /**
     * Number of threats detected by threat intelligence. Required.
     */
    threatCount?: number | null;
}
export interface RelatedToken extends Parsable, RelatedResource {
    /**
     * Unique identifier of the token. Required.
     */
    uniqueTokenIdentifier?: string | null;
}
export interface RelatedTransaction extends Parsable, RelatedResource {
    /**
     * Unique identifier of the transaction. Required.
     */
    transactionId?: string | null;
}
export interface RelatedUrl extends Parsable, RelatedResource {
    /**
     * The destination URL. Required.
     */
    url?: string | null;
}
export interface RelatedUser extends Parsable, RelatedResource {
    /**
     * Unique identifier of the user. Required.
     */
    userId?: string | null;
    /**
     * Principal name of the user. Required.
     */
    userPrincipalName?: string | null;
}
export interface RelatedWebCategory extends Parsable, RelatedResource {
    /**
     * Name of the web category. Required.
     */
    webCategoryName?: string | null;
}
export interface RemoteNetwork extends Entity, Parsable {
    /**
     * Specifies the connectivity details of all device links associated with a remote network.
     */
    connectivityConfiguration?: RemoteNetworkConnectivityConfiguration | null;
    /**
     * Each unique CPE device associated with a remote network is specified. Supports $expand.
     */
    deviceLinks?: DeviceLink[] | null;
    /**
     * Each forwarding profile associated with a remote network is specified. Supports $expand and $select.
     */
    forwardingProfiles?: ForwardingProfile[] | null;
    /**
     * last modified time.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * Name.
     */
    name?: string | null;
    /**
     * The region property
     */
    region?: Region | null;
    /**
     * Remote network version.
     */
    version?: string | null;
}
export interface RemoteNetworkCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: RemoteNetwork[] | null;
}
export interface RemoteNetworkConnectivityConfiguration extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * List of connectivity configurations for deviceLink objects.
     */
    links?: ConnectivityConfigurationLink[] | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Unique identifier or a specific reference assigned to a branchSite. Key.
     */
    remoteNetworkId?: string | null;
    /**
     * Display name assigned to a branchSite.
     */
    remoteNetworkName?: string | null;
}
export interface RemoteNetworkHealthEvent extends Entity, Parsable {
    /**
     * The number of BGP routes advertised through tunnel.
     */
    bgpRoutesAdvertisedCount?: number | null;
    /**
     * The time of the original event generation in UTC. Supports $filter (ge, le) and $orderby.
     */
    createdDateTime?: Date | null;
    /**
     * The description of the event.
     */
    description?: string | null;
    /**
     * The IP address of the destination.
     */
    destinationIp?: string | null;
    /**
     * The number of bytes sent from the destination to the source.
     */
    receivedBytes?: number | null;
    /**
     * A unique identifier for each remoteNetwork site. Supports $filter (eq).
     */
    remoteNetworkId?: string | null;
    /**
     * The number of bytes sent from the source to the destination for the connection or session.
     */
    sentBytes?: number | null;
    /**
     * The public IP address.
     */
    sourceIp?: string | null;
    /**
     * The status property
     */
    status?: RemoteNetworkStatus | null;
}
export interface RemoteNetworkHealthEventCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: RemoteNetworkHealthEvent[] | null;
}
export type RemoteNetworkStatus = (typeof RemoteNetworkStatusObject)[keyof typeof RemoteNetworkStatusObject];
export interface Reports extends Entity, Parsable {
}
export interface RuleDestination extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export type SecurityRuleStatus = (typeof SecurityRuleStatusObject)[keyof typeof SecurityRuleStatusObject];
/**
 * Serializes information the current object
 * @param Alert The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlert(writer: SerializationWriter, alert: Partial<Alert> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alert || isSerializingDerivedType) { return; }
    serializeEntity(writer, alert, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<AlertAction>("actions", alert.actions, serializeAlertAction);
    writer.writeEnumValue<AlertType>("alertType", alert.alertType);
    if(alert.categories)
    writer.writeCollectionOfEnumValues<IntentCategory>("categories", alert.categories);
    writer.writeStringValue("componentName", alert.componentName);
    writer.writeDateValue("creationDateTime", alert.creationDateTime);
    writer.writeStringValue("description", alert.description);
    writer.writeStringValue("detectionTechnology", alert.detectionTechnology);
    writer.writeStringValue("displayName", alert.displayName);
    writer.writeObjectValue<ExtendedProperties>("extendedProperties", alert.extendedProperties, serializeExtendedProperties);
    writer.writeDateValue("firstActivityDateTime", alert.firstActivityDateTime);
    writer.writeBooleanValue("isPreview", alert.isPreview);
    writer.writeDateValue("lastActivityDateTime", alert.lastActivityDateTime);
    writer.writeObjectValue<FilteringPolicy>("policy", alert.policy, serializeFilteringPolicy);
    writer.writeStringValue("productName", alert.productName);
    writer.writeCollectionOfObjectValues<RelatedResource>("relatedResources", alert.relatedResources, serializeRelatedResource);
    writer.writeEnumValue<AlertSeverity>("severity", alert.severity);
    writer.writeCollectionOfPrimitiveValues<string>("subTechniques", alert.subTechniques);
    writer.writeCollectionOfPrimitiveValues<string>("techniques", alert.techniques);
    writer.writeStringValue("vendorName", alert.vendorName);
}
/**
 * Serializes information the current object
 * @param AlertAction The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertAction(writer: SerializationWriter, alertAction: Partial<AlertAction> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertAction || isSerializingDerivedType) { return; }
    writer.writeStringValue("actionLink", alertAction.actionLink);
    writer.writeStringValue("actionText", alertAction.actionText);
    writer.writeStringValue("@odata.type", alertAction.odataType);
    writer.writeAdditionalData(alertAction.additionalData);
}
/**
 * Serializes information the current object
 * @param AlertCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertCollectionResponse(writer: SerializationWriter, alertCollectionResponse: Partial<AlertCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, alertCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Alert>("value", alertCollectionResponse.value, serializeAlert);
}
/**
 * Serializes information the current object
 * @param AlertFrequencyPoint The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertFrequencyPoint(writer: SerializationWriter, alertFrequencyPoint: Partial<AlertFrequencyPoint> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertFrequencyPoint || isSerializingDerivedType) { return; }
    writer.writeNumberValue("highSeverityCount", alertFrequencyPoint.highSeverityCount);
    writer.writeNumberValue("informationalSeverityCount", alertFrequencyPoint.informationalSeverityCount);
    writer.writeNumberValue("lowSeverityCount", alertFrequencyPoint.lowSeverityCount);
    writer.writeNumberValue("mediumSeverityCount", alertFrequencyPoint.mediumSeverityCount);
    writer.writeStringValue("@odata.type", alertFrequencyPoint.odataType);
    writer.writeDateValue("timeStampDateTime", alertFrequencyPoint.timeStampDateTime);
    writer.writeAdditionalData(alertFrequencyPoint.additionalData);
}
/**
 * Serializes information the current object
 * @param AlertSeveritySummary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertSeveritySummary(writer: SerializationWriter, alertSeveritySummary: Partial<AlertSeveritySummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertSeveritySummary || isSerializingDerivedType) { return; }
    writer.writeNumberValue("count", alertSeveritySummary.count);
    writer.writeStringValue("@odata.type", alertSeveritySummary.odataType);
    writer.writeEnumValue<AlertSeverity>("severity", alertSeveritySummary.severity);
    writer.writeAdditionalData(alertSeveritySummary.additionalData);
}
/**
 * Serializes information the current object
 * @param AlertSummary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertSummary(writer: SerializationWriter, alertSummary: Partial<AlertSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertSummary || isSerializingDerivedType) { return; }
    writer.writeEnumValue<AlertType>("alertType", alertSummary.alertType);
    writer.writeNumberValue("count", alertSummary.count);
    writer.writeStringValue("@odata.type", alertSummary.odataType);
    writer.writeEnumValue<AlertSeverity>("severity", alertSummary.severity);
    writer.writeAdditionalData(alertSummary.additionalData);
}
/**
 * Serializes information the current object
 * @param ApplicationSnapshot The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeApplicationSnapshot(writer: SerializationWriter, applicationSnapshot: Partial<ApplicationSnapshot> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!applicationSnapshot || isSerializingDerivedType) { return; }
    writer.writeStringValue("appId", applicationSnapshot.appId);
    writer.writeStringValue("@odata.type", applicationSnapshot.odataType);
    writer.writeAdditionalData(applicationSnapshot.additionalData);
}
/**
 * Serializes information the current object
 * @param AssociatedBranch The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAssociatedBranch(writer: SerializationWriter, associatedBranch: Partial<AssociatedBranch> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!associatedBranch || isSerializingDerivedType) { return; }
    serializeAssociation(writer, associatedBranch, isSerializingDerivedType)
    writer.writeStringValue("branchId", associatedBranch.branchId);
}
/**
 * Serializes information the current object
 * @param Association The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAssociation(writer: SerializationWriter, association: Partial<Association> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!association || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", association.odataType);
    writer.writeAdditionalData(association.additionalData);
    switch (association.odataType) {
        case "#microsoft.graph.networkaccess.associatedBranch":
            serializeAssociatedBranch(writer, association, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param BgpConfiguration The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeBgpConfiguration(writer: SerializationWriter, bgpConfiguration: Partial<BgpConfiguration> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!bgpConfiguration || isSerializingDerivedType) { return; }
    writer.writeNumberValue("asn", bgpConfiguration.asn);
    writer.writeStringValue("ipAddress", bgpConfiguration.ipAddress);
    writer.writeStringValue("localIpAddress", bgpConfiguration.localIpAddress);
    writer.writeStringValue("@odata.type", bgpConfiguration.odataType);
    writer.writeStringValue("peerIpAddress", bgpConfiguration.peerIpAddress);
    writer.writeAdditionalData(bgpConfiguration.additionalData);
}
/**
 * Serializes information the current object
 * @param BranchConnectivityConfiguration The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeBranchConnectivityConfiguration(writer: SerializationWriter, branchConnectivityConfiguration: Partial<BranchConnectivityConfiguration> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!branchConnectivityConfiguration || isSerializingDerivedType) { return; }
    writer.writeStringValue("branchId", branchConnectivityConfiguration.branchId);
    writer.writeStringValue("branchName", branchConnectivityConfiguration.branchName);
    writer.writeCollectionOfObjectValues<ConnectivityConfigurationLink>("links", branchConnectivityConfiguration.links, serializeConnectivityConfigurationLink);
    writer.writeStringValue("@odata.type", branchConnectivityConfiguration.odataType);
    writer.writeAdditionalData(branchConnectivityConfiguration.additionalData);
}
/**
 * Serializes information the current object
 * @param BranchSite The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeBranchSite(writer: SerializationWriter, branchSite: Partial<BranchSite> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!branchSite || isSerializingDerivedType) { return; }
    serializeEntity(writer, branchSite, isSerializingDerivedType)
    writer.writeNumberValue("bandwidthCapacity", branchSite.bandwidthCapacity);
    writer.writeObjectValue<BranchConnectivityConfiguration>("connectivityConfiguration", branchSite.connectivityConfiguration, serializeBranchConnectivityConfiguration);
    writer.writeEnumValue<ConnectivityState>("connectivityState", branchSite.connectivityState);
    writer.writeStringValue("country", branchSite.country);
    writer.writeCollectionOfObjectValues<DeviceLink>("deviceLinks", branchSite.deviceLinks, serializeDeviceLink);
    writer.writeCollectionOfObjectValues<ForwardingProfile>("forwardingProfiles", branchSite.forwardingProfiles, serializeForwardingProfile);
    writer.writeDateValue("lastModifiedDateTime", branchSite.lastModifiedDateTime);
    writer.writeStringValue("name", branchSite.name);
    writer.writeEnumValue<Region>("region", branchSite.region);
    writer.writeStringValue("version", branchSite.version);
}
/**
 * Serializes information the current object
 * @param BranchSiteCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeBranchSiteCollectionResponse(writer: SerializationWriter, branchSiteCollectionResponse: Partial<BranchSiteCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!branchSiteCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, branchSiteCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<BranchSite>("value", branchSiteCollectionResponse.value, serializeBranchSite);
}
/**
 * Serializes information the current object
 * @param ConditionalAccessPolicy The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeConditionalAccessPolicy(writer: SerializationWriter, conditionalAccessPolicy: Partial<ConditionalAccessPolicy> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!conditionalAccessPolicy || isSerializingDerivedType) { return; }
    serializeEntity(writer, conditionalAccessPolicy, isSerializingDerivedType)
    writer.writeDateValue("createdDateTime", conditionalAccessPolicy.createdDateTime);
    writer.writeStringValue("description", conditionalAccessPolicy.description);
    writer.writeStringValue("displayName", conditionalAccessPolicy.displayName);
    writer.writeDateValue("modifiedDateTime", conditionalAccessPolicy.modifiedDateTime);
}
/**
 * Serializes information the current object
 * @param ConditionalAccessPolicyCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeConditionalAccessPolicyCollectionResponse(writer: SerializationWriter, conditionalAccessPolicyCollectionResponse: Partial<ConditionalAccessPolicyCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!conditionalAccessPolicyCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, conditionalAccessPolicyCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ConditionalAccessPolicy>("value", conditionalAccessPolicyCollectionResponse.value, serializeConditionalAccessPolicy);
}
/**
 * Serializes information the current object
 * @param ConditionalAccessSettings The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeConditionalAccessSettings(writer: SerializationWriter, conditionalAccessSettings: Partial<ConditionalAccessSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!conditionalAccessSettings || isSerializingDerivedType) { return; }
    serializeEntity(writer, conditionalAccessSettings, isSerializingDerivedType)
    writer.writeEnumValue<Status>("signalingStatus", conditionalAccessSettings.signalingStatus);
}
/**
 * Serializes information the current object
 * @param Connection The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeConnection(writer: SerializationWriter, connection: Partial<Connection> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!connection || isSerializingDerivedType) { return; }
    serializeEntity(writer, connection, isSerializingDerivedType)
    writer.writeStringValue("agentVersion", connection.agentVersion);
    writer.writeObjectValue<ApplicationSnapshot>("applicationSnapshot", connection.applicationSnapshot, serializeApplicationSnapshot);
    writer.writeDateValue("createdDateTime", connection.createdDateTime);
    writer.writeStringValue("destinationFqdn", connection.destinationFqdn);
    writer.writeStringValue("destinationIp", connection.destinationIp);
    writer.writeNumberValue("destinationPort", connection.destinationPort);
    writer.writeEnumValue<DeviceCategory>("deviceCategory", connection.deviceCategory);
    writer.writeStringValue("deviceId", connection.deviceId);
    writer.writeStringValue("deviceOperatingSystem", connection.deviceOperatingSystem);
    writer.writeStringValue("deviceOperatingSystemVersion", connection.deviceOperatingSystemVersion);
    writer.writeDateValue("endDateTime", connection.endDateTime);
    writer.writeStringValue("initiatingProcessName", connection.initiatingProcessName);
    writer.writeDateValue("lastUpdateDateTime", connection.lastUpdateDateTime);
    writer.writeEnumValue<NetworkingProtocol>("networkProtocol", connection.networkProtocol);
    writer.writeStringValue("popProcessingRegion", connection.popProcessingRegion);
    writer.writeObjectValue<PrivateAccessDetails>("privateAccessDetails", connection.privateAccessDetails, serializePrivateAccessDetails);
    writer.writeNumberValue("receivedBytes", connection.receivedBytes);
    writer.writeNumberValue("sentBytes", connection.sentBytes);
    writer.writeStringValue("sourceIp", connection.sourceIp);
    writer.writeNumberValue("sourcePort", connection.sourcePort);
    writer.writeEnumValue<ConnectionStatus>("status", connection.status);
    writer.writeStringValue("tenantId", connection.tenantId);
    writer.writeEnumValue<TrafficType>("trafficType", connection.trafficType);
    writer.writeNumberValue("transactionBlockCount", connection.transactionBlockCount);
    writer.writeNumberValue("transactionCount", connection.transactionCount);
    writer.writeEnumValue<NetworkingProtocol>("transportProtocol", connection.transportProtocol);
    writer.writeStringValue("userId", connection.userId);
    writer.writeStringValue("userPrincipalName", connection.userPrincipalName);
}
/**
 * Serializes information the current object
 * @param ConnectionCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeConnectionCollectionResponse(writer: SerializationWriter, connectionCollectionResponse: Partial<ConnectionCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!connectionCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, connectionCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Connection>("value", connectionCollectionResponse.value, serializeConnection);
}
/**
 * Serializes information the current object
 * @param ConnectionSummary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeConnectionSummary(writer: SerializationWriter, connectionSummary: Partial<ConnectionSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!connectionSummary || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", connectionSummary.odataType);
    writer.writeNumberValue("totalCount", connectionSummary.totalCount);
    writer.writeEnumValue<TrafficType>("trafficType", connectionSummary.trafficType);
    writer.writeAdditionalData(connectionSummary.additionalData);
}
/**
 * Serializes information the current object
 * @param Connectivity The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeConnectivity(writer: SerializationWriter, connectivity: Partial<Connectivity> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!connectivity || isSerializingDerivedType) { return; }
    serializeEntity(writer, connectivity, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<BranchSite>("branches", connectivity.branches, serializeBranchSite);
    writer.writeCollectionOfObjectValues<RemoteNetwork>("remoteNetworks", connectivity.remoteNetworks, serializeRemoteNetwork);
    writer.writeCollectionOfObjectValues<WebCategory>("webCategories", connectivity.webCategories, serializeWebCategory);
}
/**
 * Serializes information the current object
 * @param ConnectivityConfigurationLink The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeConnectivityConfigurationLink(writer: SerializationWriter, connectivityConfigurationLink: Partial<ConnectivityConfigurationLink> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!connectivityConfigurationLink || isSerializingDerivedType) { return; }
    serializeEntity(writer, connectivityConfigurationLink, isSerializingDerivedType)
    writer.writeStringValue("displayName", connectivityConfigurationLink.displayName);
    writer.writeCollectionOfObjectValues<LocalConnectivityConfiguration>("localConfigurations", connectivityConfigurationLink.localConfigurations, serializeLocalConnectivityConfiguration);
    writer.writeObjectValue<PeerConnectivityConfiguration>("peerConfiguration", connectivityConfigurationLink.peerConfiguration, serializePeerConnectivityConfiguration);
}
/**
 * Serializes information the current object
 * @param ConnectivityConfigurationLinkCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeConnectivityConfigurationLinkCollectionResponse(writer: SerializationWriter, connectivityConfigurationLinkCollectionResponse: Partial<ConnectivityConfigurationLinkCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!connectivityConfigurationLinkCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, connectivityConfigurationLinkCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ConnectivityConfigurationLink>("value", connectivityConfigurationLinkCollectionResponse.value, serializeConnectivityConfigurationLink);
}
/**
 * Serializes information the current object
 * @param CrossTenantAccess The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCrossTenantAccess(writer: SerializationWriter, crossTenantAccess: Partial<CrossTenantAccess> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!crossTenantAccess || isSerializingDerivedType) { return; }
    writer.writeNumberValue("deviceCount", crossTenantAccess.deviceCount);
    writer.writeDateValue("lastAccessDateTime", crossTenantAccess.lastAccessDateTime);
    writer.writeStringValue("@odata.type", crossTenantAccess.odataType);
    writer.writeStringValue("resourceTenantId", crossTenantAccess.resourceTenantId);
    writer.writeStringValue("resourceTenantName", crossTenantAccess.resourceTenantName);
    writer.writeStringValue("resourceTenantPrimaryDomain", crossTenantAccess.resourceTenantPrimaryDomain);
    writer.writeEnumValue<UsageStatus>("usageStatus", crossTenantAccess.usageStatus);
    writer.writeNumberValue("userCount", crossTenantAccess.userCount);
    writer.writeAdditionalData(crossTenantAccess.additionalData);
}
/**
 * Serializes information the current object
 * @param CrossTenantAccessSettings The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCrossTenantAccessSettings(writer: SerializationWriter, crossTenantAccessSettings: Partial<CrossTenantAccessSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!crossTenantAccessSettings || isSerializingDerivedType) { return; }
    serializeEntity(writer, crossTenantAccessSettings, isSerializingDerivedType)
    writer.writeEnumValue<Status>("networkPacketTaggingStatus", crossTenantAccessSettings.networkPacketTaggingStatus);
}
/**
 * Serializes information the current object
 * @param CrossTenantSummary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCrossTenantSummary(writer: SerializationWriter, crossTenantSummary: Partial<CrossTenantSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!crossTenantSummary || isSerializingDerivedType) { return; }
    writer.writeNumberValue("authTransactionCount", crossTenantSummary.authTransactionCount);
    writer.writeNumberValue("deviceCount", crossTenantSummary.deviceCount);
    writer.writeNumberValue("newTenantCount", crossTenantSummary.newTenantCount);
    writer.writeStringValue("@odata.type", crossTenantSummary.odataType);
    writer.writeNumberValue("rarelyUsedTenantCount", crossTenantSummary.rarelyUsedTenantCount);
    writer.writeNumberValue("tenantCount", crossTenantSummary.tenantCount);
    writer.writeNumberValue("userCount", crossTenantSummary.userCount);
    writer.writeAdditionalData(crossTenantSummary.additionalData);
}
/**
 * Serializes information the current object
 * @param Destination The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDestination(writer: SerializationWriter, destination: Partial<Destination> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!destination || isSerializingDerivedType) { return; }
    writer.writeNumberValue("deviceCount", destination.deviceCount);
    writer.writeDateValue("firstAccessDateTime", destination.firstAccessDateTime);
    writer.writeStringValue("fqdn", destination.fqdn);
    writer.writeStringValue("ip", destination.ip);
    writer.writeDateValue("lastAccessDateTime", destination.lastAccessDateTime);
    writer.writeEnumValue<NetworkingProtocol>("networkingProtocol", destination.networkingProtocol);
    writer.writeStringValue("@odata.type", destination.odataType);
    writer.writeNumberValue("port", destination.port);
    writer.writeNumberValue("threatCount", destination.threatCount);
    writer.writeNumberValue("totalBytesReceived", destination.totalBytesReceived);
    writer.writeNumberValue("totalBytesSent", destination.totalBytesSent);
    writer.writeEnumValue<TrafficType>("trafficType", destination.trafficType);
    writer.writeNumberValue("transactionCount", destination.transactionCount);
    writer.writeNumberValue("userCount", destination.userCount);
    writer.writeAdditionalData(destination.additionalData);
}
/**
 * Serializes information the current object
 * @param DestinationSummary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDestinationSummary(writer: SerializationWriter, destinationSummary: Partial<DestinationSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!destinationSummary || isSerializingDerivedType) { return; }
    writer.writeNumberValue("count", destinationSummary.count);
    writer.writeStringValue("destination", destinationSummary.destination);
    writer.writeStringValue("@odata.type", destinationSummary.odataType);
    writer.writeEnumValue<TrafficType>("trafficType", destinationSummary.trafficType);
    writer.writeAdditionalData(destinationSummary.additionalData);
}
/**
 * Serializes information the current object
 * @param Device The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDevice(writer: SerializationWriter, device: Partial<Device> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!device || isSerializingDerivedType) { return; }
    writer.writeStringValue("deviceId", device.deviceId);
    writer.writeStringValue("displayName", device.displayName);
    writer.writeBooleanValue("isCompliant", device.isCompliant);
    writer.writeDateValue("lastAccessDateTime", device.lastAccessDateTime);
    writer.writeStringValue("@odata.type", device.odataType);
    writer.writeStringValue("operatingSystem", device.operatingSystem);
    writer.writeEnumValue<TrafficType>("trafficType", device.trafficType);
    writer.writeAdditionalData(device.additionalData);
}
/**
 * Serializes information the current object
 * @param DeviceLink The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeviceLink(writer: SerializationWriter, deviceLink: Partial<DeviceLink> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deviceLink || isSerializingDerivedType) { return; }
    serializeEntity(writer, deviceLink, isSerializingDerivedType)
    writer.writeEnumValue<BandwidthCapacityInMbps>("bandwidthCapacityInMbps", deviceLink.bandwidthCapacityInMbps);
    writer.writeObjectValue<BgpConfiguration>("bgpConfiguration", deviceLink.bgpConfiguration, serializeBgpConfiguration);
    writer.writeEnumValue<DeviceVendor>("deviceVendor", deviceLink.deviceVendor);
    writer.writeStringValue("ipAddress", deviceLink.ipAddress);
    writer.writeDateValue("lastModifiedDateTime", deviceLink.lastModifiedDateTime);
    writer.writeStringValue("name", deviceLink.name);
    writer.writeObjectValue<RedundancyConfiguration>("redundancyConfiguration", deviceLink.redundancyConfiguration, serializeRedundancyConfiguration);
    writer.writeObjectValue<TunnelConfiguration>("tunnelConfiguration", deviceLink.tunnelConfiguration, serializeTunnelConfiguration);
}
/**
 * Serializes information the current object
 * @param DeviceLinkCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeviceLinkCollectionResponse(writer: SerializationWriter, deviceLinkCollectionResponse: Partial<DeviceLinkCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deviceLinkCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, deviceLinkCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<DeviceLink>("value", deviceLinkCollectionResponse.value, serializeDeviceLink);
}
/**
 * Serializes information the current object
 * @param DeviceUsageSummary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeviceUsageSummary(writer: SerializationWriter, deviceUsageSummary: Partial<DeviceUsageSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deviceUsageSummary || isSerializingDerivedType) { return; }
    writer.writeNumberValue("activeDeviceCount", deviceUsageSummary.activeDeviceCount);
    writer.writeNumberValue("inactiveDeviceCount", deviceUsageSummary.inactiveDeviceCount);
    writer.writeStringValue("@odata.type", deviceUsageSummary.odataType);
    writer.writeNumberValue("totalDeviceCount", deviceUsageSummary.totalDeviceCount);
    writer.writeAdditionalData(deviceUsageSummary.additionalData);
}
/**
 * Serializes information the current object
 * @param DiscoveredApplicationSegmentReport The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDiscoveredApplicationSegmentReport(writer: SerializationWriter, discoveredApplicationSegmentReport: Partial<DiscoveredApplicationSegmentReport> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!discoveredApplicationSegmentReport || isSerializingDerivedType) { return; }
    writer.writeEnumValue<AccessType>("accessType", discoveredApplicationSegmentReport.accessType);
    writer.writeNumberValue("deviceCount", discoveredApplicationSegmentReport.deviceCount);
    writer.writeStringValue("discoveredApplicationSegmentId", discoveredApplicationSegmentReport.discoveredApplicationSegmentId);
    writer.writeDateValue("firstAccessDateTime", discoveredApplicationSegmentReport.firstAccessDateTime);
    writer.writeStringValue("fqdn", discoveredApplicationSegmentReport.fqdn);
    writer.writeStringValue("ip", discoveredApplicationSegmentReport.ip);
    writer.writeDateValue("lastAccessDateTime", discoveredApplicationSegmentReport.lastAccessDateTime);
    writer.writeStringValue("@odata.type", discoveredApplicationSegmentReport.odataType);
    writer.writeNumberValue("port", discoveredApplicationSegmentReport.port);
    writer.writeNumberValue("totalBytesReceived", discoveredApplicationSegmentReport.totalBytesReceived);
    writer.writeNumberValue("totalBytesSent", discoveredApplicationSegmentReport.totalBytesSent);
    writer.writeNumberValue("transactionCount", discoveredApplicationSegmentReport.transactionCount);
    writer.writeEnumValue<NetworkingProtocol>("transportProtocol", discoveredApplicationSegmentReport.transportProtocol);
    writer.writeNumberValue("userCount", discoveredApplicationSegmentReport.userCount);
    writer.writeAdditionalData(discoveredApplicationSegmentReport.additionalData);
}
/**
 * Serializes information the current object
 * @param EntitiesSummary The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEntitiesSummary(writer: SerializationWriter, entitiesSummary: Partial<EntitiesSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!entitiesSummary || isSerializingDerivedType) { return; }
    writer.writeNumberValue("deviceCount", entitiesSummary.deviceCount);
    writer.writeStringValue("@odata.type", entitiesSummary.odataType);
    writer.writeEnumValue<TrafficType>("trafficType", entitiesSummary.trafficType);
    writer.writeNumberValue("userCount", entitiesSummary.userCount);
    writer.writeNumberValue("workloadCount", entitiesSummary.workloadCount);
    writer.writeAdditionalData(entitiesSummary.additionalData);
}
/**
 * Serializes information the current object
 * @param ExtendedProperties The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExtendedProperties(writer: SerializationWriter, extendedProperties: Partial<ExtendedProperties> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!extendedProperties || isSerializingDerivedType) { return; }
    serializeDictionary(writer, extendedProperties, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param ExternalCertificateAuthorityCertificate The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExternalCertificateAuthorityCertificate(writer: SerializationWriter, externalCertificateAuthorityCertificate: Partial<ExternalCertificateAuthorityCertificate> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!externalCertificateAuthorityCertificate || isSerializingDerivedType) { return; }
    serializeEntity(writer, externalCertificateAuthorityCertificate, isSerializingDerivedType)
    writer.writeStringValue("certificate", externalCertificateAuthorityCertificate.certificate);
    writer.writeStringValue("certificateSigningRequest", externalCertificateAuthorityCertificate.certificateSigningRequest);
    writer.writeStringValue("chain", externalCertificateAuthorityCertificate.chain);
    writer.writeStringValue("commonName", externalCertificateAuthorityCertificate.commonName);
    writer.writeStringValue("name", externalCertificateAuthorityCertificate.name);
    writer.writeStringValue("organizationName", externalCertificateAuthorityCertificate.organizationName);
    writer.writeEnumValue<TlsCertificateStatus>("status", externalCertificateAuthorityCertificate.status);
    writer.writeObjectValue<ValidityDate>("validity", externalCertificateAuthorityCertificate.validity, serializeValidityDate);
}
/**
 * Serializes information the current object
 * @param ExternalCertificateAuthorityCertificateCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExternalCertificateAuthorityCertificateCollectionResponse(writer: SerializationWriter, externalCertificateAuthorityCertificateCollectionResponse: Partial<ExternalCertificateAuthorityCertificateCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!externalCertificateAuthorityCertificateCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, externalCertificateAuthorityCertificateCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ExternalCertificateAuthorityCertificate>("value", externalCertificateAuthorityCertificateCollectionResponse.value, serializeExternalCertificateAuthorityCertificate);
}
/**
 * Serializes information the current object
 * @param FilteringPolicy The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFilteringPolicy(writer: SerializationWriter, filteringPolicy: Partial<FilteringPolicy> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!filteringPolicy || isSerializingDerivedType) { return; }
    serializePolicy(writer, filteringPolicy, isSerializingDerivedType)
    writer.writeEnumValue<FilteringPolicyAction>("action", filteringPolicy.action);
    writer.writeDateValue("createdDateTime", filteringPolicy.createdDateTime);
    writer.writeDateValue("lastModifiedDateTime", filteringPolicy.lastModifiedDateTime);
}
/**
 * Serializes information the current object
 * @param FilteringPolicyCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFilteringPolicyCollectionResponse(writer: SerializationWriter, filteringPolicyCollectionResponse: Partial<FilteringPolicyCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!filteringPolicyCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, filteringPolicyCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<FilteringPolicy>("value", filteringPolicyCollectionResponse.value, serializeFilteringPolicy);
}
/**
 * Serializes information the current object
 * @param FilteringPolicyLink The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFilteringPolicyLink(writer: SerializationWriter, filteringPolicyLink: Partial<FilteringPolicyLink> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!filteringPolicyLink || isSerializingDerivedType) { return; }
    serializePolicyLink(writer, filteringPolicyLink, isSerializingDerivedType)
    writer.writeDateValue("createdDateTime", filteringPolicyLink.createdDateTime);
    writer.writeDateValue("lastModifiedDateTime", filteringPolicyLink.lastModifiedDateTime);
    writer.writeEnumValue<Status>("loggingState", filteringPolicyLink.loggingState);
    writer.writeNumberValue("priority", filteringPolicyLink.priority);
}
/**
 * Serializes information the current object
 * @param FilteringProfile The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFilteringProfile(writer: SerializationWriter, filteringProfile: Partial<FilteringProfile> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!filteringProfile || isSerializingDerivedType) { return; }
    serializeProfile(writer, filteringProfile, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ConditionalAccessPolicy>("conditionalAccessPolicies", filteringProfile.conditionalAccessPolicies, serializeConditionalAccessPolicy);
    writer.writeDateValue("createdDateTime", filteringProfile.createdDateTime);
    writer.writeNumberValue("priority", filteringProfile.priority);
}
/**
 * Serializes information the current object
 * @param FilteringProfileCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFilteringProfileCollectionResponse(writer: SerializationWriter, filteringProfileCollectionResponse: Partial<FilteringProfileCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!filteringProfileCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, filteringProfileCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<FilteringProfile>("value", filteringProfileCollectionResponse.value, serializeFilteringProfile);
}
/**
 * Serializes information the current object
 * @param FilteringRule The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFilteringRule(writer: SerializationWriter, filteringRule: Partial<FilteringRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!filteringRule || isSerializingDerivedType) { return; }
    serializePolicyRule(writer, filteringRule, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<RuleDestination>("destinations", filteringRule.destinations, serializeRuleDestination);
    writer.writeEnumValue<NetworkDestinationType>("ruleType", filteringRule.ruleType);
    switch (filteringRule.odataType) {
        case "#microsoft.graph.networkaccess.fqdnFilteringRule":
            serializeFqdnFilteringRule(writer, filteringRule, true);
        break;
        case "#microsoft.graph.networkaccess.webCategoryFilteringRule":
            serializeWebCategoryFilteringRule(writer, filteringRule, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param ForwardingOptions The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeForwardingOptions(writer: SerializationWriter, forwardingOptions: Partial<ForwardingOptions> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!forwardingOptions || isSerializingDerivedType) { return; }
    serializeEntity(writer, forwardingOptions, isSerializingDerivedType)
    writer.writeEnumValue<Status>("skipDnsLookupState", forwardingOptions.skipDnsLookupState);
}
/**
 * Serializes information the current object
 * @param ForwardingPolicy The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeForwardingPolicy(writer: SerializationWriter, forwardingPolicy: Partial<ForwardingPolicy> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!forwardingPolicy || isSerializingDerivedType) { return; }
    serializePolicy(writer, forwardingPolicy, isSerializingDerivedType)
    writer.writeEnumValue<TrafficForwardingType>("trafficForwardingType", forwardingPolicy.trafficForwardingType);
}
/**
 * Serializes information the current object
 * @param ForwardingPolicyCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeForwardingPolicyCollectionResponse(writer: SerializationWriter, forwardingPolicyCollectionResponse: Partial<ForwardingPolicyCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!forwardingPolicyCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, forwardingPolicyCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ForwardingPolicy>("value", forwardingPolicyCollectionResponse.value, serializeForwardingPolicy);
}
/**
 * Serializes information the current object
 * @param ForwardingPolicyLink The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeForwardingPolicyLink(writer: SerializationWriter, forwardingPolicyLink: Partial<ForwardingPolicyLink> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!forwardingPolicyLink || isSerializingDerivedType) { return; }
    serializePolicyLink(writer, forwardingPolicyLink, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param ForwardingProfile The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeForwardingProfile(writer: SerializationWriter, forwardingProfile: Partial<ForwardingProfile> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!forwardingProfile || isSerializingDerivedType) { return; }
    serializeProfile(writer, forwardingProfile, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Association>("associations", forwardingProfile.associations, serializeAssociation);
    writer.writeNumberValue("priority", forwardingProfile.priority);
    writer.writeObjectValue<ServicePrincipal>("servicePrincipal", forwardingProfile.servicePrincipal, serializeServicePrincipal);
    writer.writeEnumValue<TrafficForwardingType>("trafficForwardingType", forwardingProfile.trafficForwardingType);
}
/**
 * Serializes information the current object
 * @param ForwardingProfileCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeForwardingProfileCollectionResponse(writer: SerializationWriter, forwardingProfileCollectionResponse: Partial<ForwardingProfileCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!forwardingProfileCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, forwardingProfileCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ForwardingProfile>("value", forwardingProfileCollectionResponse.value, serializeForwardingProfile);
}
/**
 * Serializes information the current object
 * @param ForwardingRule The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeForwardingRule(writer: SerializationWriter, forwardingRule: Partial<ForwardingRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!forwardingRule || isSerializingDerivedType) { return; }
    serializePolicyRule(writer, forwardingRule, isSerializingDerivedType)
    writer.writeEnumValue<ForwardingRuleAction>("action", forwardingRule.action);
    writer.writeEnumValue<ClientFallbackAction>("clientFallbackAction", forwardingRule.clientFallbackAction);
    writer.writeCollectionOfObjectValues<RuleDestination>("destinations", forwardingRule.destinations, serializeRuleDestination);
    writer.writeEnumValue<NetworkDestinationType>("ruleType", forwardingRule.ruleType);
    switch (forwardingRule.odataType) {
        case "#microsoft.graph.networkaccess.internetAccessForwardingRule":
            serializeInternetAccessForwardingRule(writer, forwardingRule, true);
        break;
        case "#microsoft.graph.networkaccess.m365ForwardingRule":
            serializeM365ForwardingRule(writer, forwardingRule, true);
        break;
        case "#microsoft.graph.networkaccess.privateAccessForwardingRule":
            serializePrivateAccessForwardingRule(writer, forwardingRule, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param Fqdn The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFqdn(writer: SerializationWriter, fqdn: Partial<Fqdn> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!fqdn || isSerializingDerivedType) { return; }
    serializeRuleDestination(writer, fqdn, isSerializingDerivedType)
    writer.writeStringValue("value", fqdn.value);
}
/**
 * Serializes information the current object
 * @param FqdnFilteringRule The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFqdnFilteringRule(writer: SerializationWriter, fqdnFilteringRule: Partial<FqdnFilteringRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!fqdnFilteringRule || isSerializingDerivedType) { return; }
    serializeFilteringRule(writer, fqdnFilteringRule, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param Headers The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeHeaders(writer: SerializationWriter, headers: Partial<Headers> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!headers || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", headers.odataType);
    writer.writeStringValue("origin", headers.origin);
    writer.writeStringValue("referrer", headers.referrer);
    writer.writeStringValue("xForwardedFor", headers.xForwardedFor);
    writer.writeAdditionalData(headers.additionalData);
}
/**
 * Serializes information the current object
 * @param InternetAccessForwardingRule The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeInternetAccessForwardingRule(writer: SerializationWriter, internetAccessForwardingRule: Partial<InternetAccessForwardingRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!internetAccessForwardingRule || isSerializingDerivedType) { return; }
    serializeForwardingRule(writer, internetAccessForwardingRule, isSerializingDerivedType)
    writer.writeCollectionOfPrimitiveValues<string>("ports", internetAccessForwardingRule.ports);
    writer.writeEnumValue<NetworkingProtocol>("protocol", internetAccessForwardingRule.protocol);
}
/**
 * Serializes information the current object
 * @param IpAddress The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIpAddress(writer: SerializationWriter, ipAddress: Partial<IpAddress> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!ipAddress || isSerializingDerivedType) { return; }
    serializeRuleDestination(writer, ipAddress, isSerializingDerivedType)
    writer.writeStringValue("value", ipAddress.value);
}
/**
 * Serializes information the current object
 * @param IpRange The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIpRange(writer: SerializationWriter, ipRange: Partial<IpRange> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!ipRange || isSerializingDerivedType) { return; }
    serializeRuleDestination(writer, ipRange, isSerializingDerivedType)
    writer.writeStringValue("beginAddress", ipRange.beginAddress);
    writer.writeStringValue("endAddress", ipRange.endAddress);
}
/**
 * Serializes information the current object
 * @param IpSubnet The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIpSubnet(writer: SerializationWriter, ipSubnet: Partial<IpSubnet> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!ipSubnet || isSerializingDerivedType) { return; }
    serializeRuleDestination(writer, ipSubnet, isSerializingDerivedType)
    writer.writeStringValue("value", ipSubnet.value);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param LocalConnectivityConfiguration The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeLocalConnectivityConfiguration(writer: SerializationWriter, localConnectivityConfiguration: Partial<LocalConnectivityConfiguration> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!localConnectivityConfiguration || isSerializingDerivedType) { return; }
    writer.writeNumberValue("asn", localConnectivityConfiguration.asn);
    writer.writeStringValue("bgpAddress", localConnectivityConfiguration.bgpAddress);
    writer.writeStringValue("endpoint", localConnectivityConfiguration.endpoint);
    writer.writeStringValue("@odata.type", localConnectivityConfiguration.odataType);
    writer.writeEnumValue<Region>("region", localConnectivityConfiguration.region);
    writer.writeAdditionalData(localConnectivityConfiguration.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Logs The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeLogs(writer: SerializationWriter, logs: Partial<Logs> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!logs || isSerializingDerivedType) { return; }
    serializeEntity(writer, logs, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Connection>("connections", logs.connections, serializeConnection);
    writer.writeCollectionOfObjectValues<RemoteNetworkHealthEvent>("remoteNetworks", logs.remoteNetworks, serializeRemoteNetworkHealthEvent);
    writer.writeCollectionOfObjectValues<NetworkAccessTraffic>("traffic", logs.traffic, serializeNetworkAccessTraffic);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param M365ForwardingRule The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeM365ForwardingRule(writer: SerializationWriter, m365ForwardingRule: Partial<M365ForwardingRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!m365ForwardingRule || isSerializingDerivedType) { return; }
    serializeForwardingRule(writer, m365ForwardingRule, isSerializingDerivedType)
    writer.writeEnumValue<ForwardingCategory>("category", m365ForwardingRule.category);
    writer.writeCollectionOfPrimitiveValues<string>("ports", m365ForwardingRule.ports);
    writer.writeEnumValue<NetworkingProtocol>("protocol", m365ForwardingRule.protocol);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param NetworkAccessRoot The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeNetworkAccessRoot(writer: SerializationWriter, networkAccessRoot: Partial<NetworkAccessRoot> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!networkAccessRoot || isSerializingDerivedType) { return; }
    serializeEntity(writer, networkAccessRoot, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Alert>("alerts", networkAccessRoot.alerts, serializeAlert);
    writer.writeObjectValue<Connectivity>("connectivity", networkAccessRoot.connectivity, serializeConnectivity);
    writer.writeCollectionOfObjectValues<FilteringPolicy>("filteringPolicies", networkAccessRoot.filteringPolicies, serializeFilteringPolicy);
    writer.writeCollectionOfObjectValues<FilteringProfile>("filteringProfiles", networkAccessRoot.filteringProfiles, serializeFilteringProfile);
    writer.writeCollectionOfObjectValues<ForwardingPolicy>("forwardingPolicies", networkAccessRoot.forwardingPolicies, serializeForwardingPolicy);
    writer.writeCollectionOfObjectValues<ForwardingProfile>("forwardingProfiles", networkAccessRoot.forwardingProfiles, serializeForwardingProfile);
    writer.writeObjectValue<Logs>("logs", networkAccessRoot.logs, serializeLogs);
    writer.writeObjectValue<Reports>("reports", networkAccessRoot.reports, serializeReports);
    writer.writeObjectValue<Settings>("settings", networkAccessRoot.settings, serializeSettings);
    writer.writeObjectValue<TenantStatus>("tenantStatus", networkAccessRoot.tenantStatus, serializeTenantStatus);
    writer.writeCollectionOfObjectValues<ThreatIntelligencePolicy>("threatIntelligencePolicies", networkAccessRoot.threatIntelligencePolicies, serializeThreatIntelligencePolicy);
    writer.writeObjectValue<TlsTermination>("tls", networkAccessRoot.tls, serializeTlsTermination);
    writer.writeCollectionOfObjectValues<TlsInspectionPolicy>("tlsInspectionPolicies", networkAccessRoot.tlsInspectionPolicies, serializeTlsInspectionPolicy);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param NetworkAccessTraffic The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeNetworkAccessTraffic(writer: SerializationWriter, networkAccessTraffic: Partial<NetworkAccessTraffic> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!networkAccessTraffic || isSerializingDerivedType) { return; }
    writer.writeEnumValue<FilteringPolicyAction>("action", networkAccessTraffic.action);
    writer.writeStringValue("agentVersion", networkAccessTraffic.agentVersion);
    writer.writeObjectValue<ApplicationSnapshot>("applicationSnapshot", networkAccessTraffic.applicationSnapshot, serializeApplicationSnapshot);
    writer.writeStringValue("connectionId", networkAccessTraffic.connectionId);
    writer.writeDateValue("createdDateTime", networkAccessTraffic.createdDateTime);
    writer.writeStringValue("description", networkAccessTraffic.description);
    writer.writeStringValue("destinationFQDN", networkAccessTraffic.destinationFQDN);
    writer.writeStringValue("destinationIp", networkAccessTraffic.destinationIp);
    writer.writeNumberValue("destinationPort", networkAccessTraffic.destinationPort);
    writer.writeStringValue("destinationUrl", networkAccessTraffic.destinationUrl);
    writer.writeObjectValue<WebCategory>("destinationWebCategory", networkAccessTraffic.destinationWebCategory, serializeWebCategory);
    writer.writeObjectValue<I353170b9ab043a51be0a29bf9ffeadaa40f51ff6511c066ae82d223c77decf60>("device", networkAccessTraffic.device, I93801fe1d0700e2dfbaabaac8a107eaad07c485b973484cdebd0254423e093c4);
    writer.writeEnumValue<DeviceCategory>("deviceCategory", networkAccessTraffic.deviceCategory);
    writer.writeStringValue("deviceId", networkAccessTraffic.deviceId);
    writer.writeStringValue("deviceOperatingSystem", networkAccessTraffic.deviceOperatingSystem);
    writer.writeStringValue("deviceOperatingSystemVersion", networkAccessTraffic.deviceOperatingSystemVersion);
    writer.writeStringValue("filteringProfileId", networkAccessTraffic.filteringProfileId);
    writer.writeStringValue("filteringProfileName", networkAccessTraffic.filteringProfileName);
    writer.writeObjectValue<Headers>("headers", networkAccessTraffic.headers, serializeHeaders);
    writer.writeEnumValue<HttpMethod>("httpMethod", networkAccessTraffic.httpMethod);
    writer.writeStringValue("initiatingProcessName", networkAccessTraffic.initiatingProcessName);
    writer.writeEnumValue<NetworkingProtocol>("networkProtocol", networkAccessTraffic.networkProtocol);
    writer.writeStringValue("@odata.type", networkAccessTraffic.odataType);
    writer.writeEnumValue<NetworkTrafficOperationStatus>("operationStatus", networkAccessTraffic.operationStatus);
    writer.writeStringValue("policyId", networkAccessTraffic.policyId);
    writer.writeStringValue("policyName", networkAccessTraffic.policyName);
    writer.writeStringValue("policyRuleId", networkAccessTraffic.policyRuleId);
    writer.writeStringValue("policyRuleName", networkAccessTraffic.policyRuleName);
    writer.writeStringValue("popProcessingRegion", networkAccessTraffic.popProcessingRegion);
    writer.writeObjectValue<PrivateAccessDetails>("privateAccessDetails", networkAccessTraffic.privateAccessDetails, serializePrivateAccessDetails);
    writer.writeNumberValue("receivedBytes", networkAccessTraffic.receivedBytes);
    writer.writeStringValue("remoteNetworkId", networkAccessTraffic.remoteNetworkId);
    writer.writeStringValue("resourceTenantId", networkAccessTraffic.resourceTenantId);
    writer.writeNumberValue("responseCode", networkAccessTraffic.responseCode);
    writer.writeNumberValue("sentBytes", networkAccessTraffic.sentBytes);
    writer.writeStringValue("sessionId", networkAccessTraffic.sessionId);
    writer.writeStringValue("sourceIp", networkAccessTraffic.sourceIp);
    writer.writeNumberValue("sourcePort", networkAccessTraffic.sourcePort);
    writer.writeStringValue("tenantId", networkAccessTraffic.tenantId);
    writer.writeStringValue("threatType", networkAccessTraffic.threatType);
    writer.writeEnumValue<TrafficType>("trafficType", networkAccessTraffic.trafficType);
    writer.writeStringValue("transactionId", networkAccessTraffic.transactionId);
    writer.writeEnumValue<NetworkingProtocol>("transportProtocol", networkAccessTraffic.transportProtocol);
    writer.writeObjectValue<I4bfcbb20fa90605575bab96c7572912b314f024f9b0899d027a654508ef72465>("user", networkAccessTraffic.user, I52fb59bcf4aad10419ab5ac07e13466b759ff69b47806ecf063de624d08c4da3);
    writer.writeStringValue("userId", networkAccessTraffic.userId);
    writer.writeStringValue("userPrincipalName", networkAccessTraffic.userPrincipalName);
    writer.writeCollectionOfPrimitiveValues<string>("vendorNames", networkAccessTraffic.vendorNames);
    writer.writeAdditionalData(networkAccessTraffic.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param NetworkAccessTrafficCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeNetworkAccessTrafficCollectionResponse(writer: SerializationWriter, networkAccessTrafficCollectionResponse: Partial<NetworkAccessTrafficCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!networkAccessTrafficCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, networkAccessTrafficCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<NetworkAccessTraffic>("value", networkAccessTrafficCollectionResponse.value, serializeNetworkAccessTraffic);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PeerConnectivityConfiguration The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePeerConnectivityConfiguration(writer: SerializationWriter, peerConnectivityConfiguration: Partial<PeerConnectivityConfiguration> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!peerConnectivityConfiguration || isSerializingDerivedType) { return; }
    writer.writeNumberValue("asn", peerConnectivityConfiguration.asn);
    writer.writeStringValue("bgpAddress", peerConnectivityConfiguration.bgpAddress);
    writer.writeStringValue("endpoint", peerConnectivityConfiguration.endpoint);
    writer.writeStringValue("@odata.type", peerConnectivityConfiguration.odataType);
    writer.writeAdditionalData(peerConnectivityConfiguration.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Policy The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePolicy(writer: SerializationWriter, policy: Partial<Policy> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!policy || isSerializingDerivedType) { return; }
    serializeEntity(writer, policy, isSerializingDerivedType)
    writer.writeStringValue("description", policy.description);
    writer.writeStringValue("name", policy.name);
    writer.writeCollectionOfObjectValues<PolicyRule>("policyRules", policy.policyRules, serializePolicyRule);
    writer.writeStringValue("version", policy.version);
    switch (policy.odataType) {
        case "#microsoft.graph.networkaccess.filteringPolicy":
            serializeFilteringPolicy(writer, policy, true);
        break;
        case "#microsoft.graph.networkaccess.forwardingPolicy":
            serializeForwardingPolicy(writer, policy, true);
        break;
        case "#microsoft.graph.networkaccess.threatIntelligencePolicy":
            serializeThreatIntelligencePolicy(writer, policy, true);
        break;
        case "#microsoft.graph.networkaccess.tlsInspectionPolicy":
            serializeTlsInspectionPolicy(writer, policy, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PolicyLink The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePolicyLink(writer: SerializationWriter, policyLink: Partial<PolicyLink> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!policyLink || isSerializingDerivedType) { return; }
    serializeEntity(writer, policyLink, isSerializingDerivedType)
    writer.writeObjectValue<Policy>("policy", policyLink.policy, serializePolicy);
    writer.writeEnumValue<Status>("state", policyLink.state);
    writer.writeStringValue("version", policyLink.version);
    switch (policyLink.odataType) {
        case "#microsoft.graph.networkaccess.filteringPolicyLink":
            serializeFilteringPolicyLink(writer, policyLink, true);
        break;
        case "#microsoft.graph.networkaccess.forwardingPolicyLink":
            serializeForwardingPolicyLink(writer, policyLink, true);
        break;
        case "#microsoft.graph.networkaccess.threatIntelligencePolicyLink":
            serializeThreatIntelligencePolicyLink(writer, policyLink, true);
        break;
        case "#microsoft.graph.networkaccess.tlsInspectionPolicyLink":
            serializeTlsInspectionPolicyLink(writer, policyLink, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PolicyLinkCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePolicyLinkCollectionResponse(writer: SerializationWriter, policyLinkCollectionResponse: Partial<PolicyLinkCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!policyLinkCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, policyLinkCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<PolicyLink>("value", policyLinkCollectionResponse.value, serializePolicyLink);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PolicyRule The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePolicyRule(writer: SerializationWriter, policyRule: Partial<PolicyRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!policyRule || isSerializingDerivedType) { return; }
    serializeEntity(writer, policyRule, isSerializingDerivedType)
    writer.writeStringValue("name", policyRule.name);
    switch (policyRule.odataType) {
        case "#microsoft.graph.networkaccess.filteringRule":
            serializeFilteringRule(writer, policyRule, true);
        break;
        case "#microsoft.graph.networkaccess.forwardingRule":
            serializeForwardingRule(writer, policyRule, true);
        break;
        case "#microsoft.graph.networkaccess.fqdnFilteringRule":
            serializeFqdnFilteringRule(writer, policyRule, true);
        break;
        case "#microsoft.graph.networkaccess.internetAccessForwardingRule":
            serializeInternetAccessForwardingRule(writer, policyRule, true);
        break;
        case "#microsoft.graph.networkaccess.m365ForwardingRule":
            serializeM365ForwardingRule(writer, policyRule, true);
        break;
        case "#microsoft.graph.networkaccess.privateAccessForwardingRule":
            serializePrivateAccessForwardingRule(writer, policyRule, true);
        break;
        case "#microsoft.graph.networkaccess.threatIntelligenceRule":
            serializeThreatIntelligenceRule(writer, policyRule, true);
        break;
        case "#microsoft.graph.networkaccess.tlsInspectionRule":
            serializeTlsInspectionRule(writer, policyRule, true);
        break;
        case "#microsoft.graph.networkaccess.webCategoryFilteringRule":
            serializeWebCategoryFilteringRule(writer, policyRule, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PolicyRuleCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePolicyRuleCollectionResponse(writer: SerializationWriter, policyRuleCollectionResponse: Partial<PolicyRuleCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!policyRuleCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, policyRuleCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<PolicyRule>("value", policyRuleCollectionResponse.value, serializePolicyRule);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PolicyRuleDelta The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePolicyRuleDelta(writer: SerializationWriter, policyRuleDelta: Partial<PolicyRuleDelta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!policyRuleDelta || isSerializingDerivedType) { return; }
    writer.writeEnumValue<ForwardingRuleAction>("action", policyRuleDelta.action);
    writer.writeStringValue("@odata.type", policyRuleDelta.odataType);
    writer.writeStringValue("ruleId", policyRuleDelta.ruleId);
    writer.writeAdditionalData(policyRuleDelta.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PrivateAccessDetails The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePrivateAccessDetails(writer: SerializationWriter, privateAccessDetails: Partial<PrivateAccessDetails> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!privateAccessDetails || isSerializingDerivedType) { return; }
    writer.writeEnumValue<AccessType>("accessType", privateAccessDetails.accessType);
    writer.writeStringValue("appSegmentId", privateAccessDetails.appSegmentId);
    writer.writeEnumValue<ConnectionStatus>("connectionStatus", privateAccessDetails.connectionStatus);
    writer.writeStringValue("connectorId", privateAccessDetails.connectorId);
    writer.writeStringValue("connectorIp", privateAccessDetails.connectorIp);
    writer.writeStringValue("connectorName", privateAccessDetails.connectorName);
    writer.writeStringValue("@odata.type", privateAccessDetails.odataType);
    writer.writeStringValue("processingRegion", privateAccessDetails.processingRegion);
    writer.writeObjectValue<ThirdPartyTokenDetails>("thirdPartyTokenDetails", privateAccessDetails.thirdPartyTokenDetails, serializeThirdPartyTokenDetails);
    writer.writeAdditionalData(privateAccessDetails.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PrivateAccessForwardingRule The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePrivateAccessForwardingRule(writer: SerializationWriter, privateAccessForwardingRule: Partial<PrivateAccessForwardingRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!privateAccessForwardingRule || isSerializingDerivedType) { return; }
    serializeForwardingRule(writer, privateAccessForwardingRule, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Profile The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeProfile(writer: SerializationWriter, profile: Partial<Profile> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!profile || isSerializingDerivedType) { return; }
    serializeEntity(writer, profile, isSerializingDerivedType)
    writer.writeStringValue("description", profile.description);
    writer.writeDateValue("lastModifiedDateTime", profile.lastModifiedDateTime);
    writer.writeStringValue("name", profile.name);
    writer.writeCollectionOfObjectValues<PolicyLink>("policies", profile.policies, serializePolicyLink);
    writer.writeEnumValue<Status>("state", profile.state);
    writer.writeStringValue("version", profile.version);
    switch (profile.odataType) {
        case "#microsoft.graph.networkaccess.filteringProfile":
            serializeFilteringProfile(writer, profile, true);
        break;
        case "#microsoft.graph.networkaccess.forwardingProfile":
            serializeForwardingProfile(writer, profile, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RedundancyConfiguration The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRedundancyConfiguration(writer: SerializationWriter, redundancyConfiguration: Partial<RedundancyConfiguration> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!redundancyConfiguration || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", redundancyConfiguration.odataType);
    writer.writeEnumValue<RedundancyTier>("redundancyTier", redundancyConfiguration.redundancyTier);
    writer.writeStringValue("zoneLocalIpAddress", redundancyConfiguration.zoneLocalIpAddress);
    writer.writeAdditionalData(redundancyConfiguration.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedDestination The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedDestination(writer: SerializationWriter, relatedDestination: Partial<RelatedDestination> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedDestination || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedDestination, isSerializingDerivedType)
    writer.writeStringValue("fqdn", relatedDestination.fqdn);
    writer.writeStringValue("ip", relatedDestination.ip);
    writer.writeEnumValue<NetworkingProtocol>("networkingProtocol", relatedDestination.networkingProtocol);
    writer.writeNumberValue("port", relatedDestination.port);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedDevice The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedDevice(writer: SerializationWriter, relatedDevice: Partial<RelatedDevice> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedDevice || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedDevice, isSerializingDerivedType)
    writer.writeStringValue("deviceId", relatedDevice.deviceId);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedFile The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedFile(writer: SerializationWriter, relatedFile: Partial<RelatedFile> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedFile || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedFile, isSerializingDerivedType)
    writer.writeStringValue("directory", relatedFile.directory);
    writer.writeStringValue("name", relatedFile.name);
    writer.writeNumberValue("sizeInBytes", relatedFile.sizeInBytes);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedFileHash The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedFileHash(writer: SerializationWriter, relatedFileHash: Partial<RelatedFileHash> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedFileHash || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedFileHash, isSerializingDerivedType)
    writer.writeEnumValue<Algorithm>("algorithm", relatedFileHash.algorithm);
    writer.writeStringValue("value", relatedFileHash.value);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedMalware The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedMalware(writer: SerializationWriter, relatedMalware: Partial<RelatedMalware> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedMalware || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedMalware, isSerializingDerivedType)
    writer.writeEnumValue<MalwareCategory>("category", relatedMalware.category);
    writer.writeStringValue("name", relatedMalware.name);
    writer.writeEnumValue<ThreatSeverity>("severity", relatedMalware.severity);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedRemoteNetwork The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedRemoteNetwork(writer: SerializationWriter, relatedRemoteNetwork: Partial<RelatedRemoteNetwork> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedRemoteNetwork || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedRemoteNetwork, isSerializingDerivedType)
    writer.writeStringValue("remoteNetworkId", relatedRemoteNetwork.remoteNetworkId);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedResource The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedResource(writer: SerializationWriter, relatedResource: Partial<RelatedResource> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedResource || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", relatedResource.odataType);
    writer.writeAdditionalData(relatedResource.additionalData);
    switch (relatedResource.odataType) {
        case "#microsoft.graph.networkaccess.relatedDestination":
            serializeRelatedDestination(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedDevice":
            serializeRelatedDevice(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedFile":
            serializeRelatedFile(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedFileHash":
            serializeRelatedFileHash(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedMalware":
            serializeRelatedMalware(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedRemoteNetwork":
            serializeRelatedRemoteNetwork(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedTenant":
            serializeRelatedTenant(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedThreatIntelligence":
            serializeRelatedThreatIntelligence(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedToken":
            serializeRelatedToken(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedTransaction":
            serializeRelatedTransaction(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedUrl":
            serializeRelatedUrl(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedUser":
            serializeRelatedUser(writer, relatedResource, true);
        break;
        case "#microsoft.graph.networkaccess.relatedWebCategory":
            serializeRelatedWebCategory(writer, relatedResource, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedTenant The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedTenant(writer: SerializationWriter, relatedTenant: Partial<RelatedTenant> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedTenant || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedTenant, isSerializingDerivedType)
    writer.writeStringValue("tenantId", relatedTenant.tenantId);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedThreatIntelligence The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedThreatIntelligence(writer: SerializationWriter, relatedThreatIntelligence: Partial<RelatedThreatIntelligence> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedThreatIntelligence || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedThreatIntelligence, isSerializingDerivedType)
    writer.writeNumberValue("threatCount", relatedThreatIntelligence.threatCount);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedToken The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedToken(writer: SerializationWriter, relatedToken: Partial<RelatedToken> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedToken || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedToken, isSerializingDerivedType)
    writer.writeStringValue("uniqueTokenIdentifier", relatedToken.uniqueTokenIdentifier);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedTransaction The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedTransaction(writer: SerializationWriter, relatedTransaction: Partial<RelatedTransaction> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedTransaction || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedTransaction, isSerializingDerivedType)
    writer.writeStringValue("transactionId", relatedTransaction.transactionId);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedUrl The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedUrl(writer: SerializationWriter, relatedUrl: Partial<RelatedUrl> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedUrl || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedUrl, isSerializingDerivedType)
    writer.writeStringValue("url", relatedUrl.url);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedUser The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedUser(writer: SerializationWriter, relatedUser: Partial<RelatedUser> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedUser || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedUser, isSerializingDerivedType)
    writer.writeStringValue("userId", relatedUser.userId);
    writer.writeStringValue("userPrincipalName", relatedUser.userPrincipalName);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelatedWebCategory The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelatedWebCategory(writer: SerializationWriter, relatedWebCategory: Partial<RelatedWebCategory> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relatedWebCategory || isSerializingDerivedType) { return; }
    serializeRelatedResource(writer, relatedWebCategory, isSerializingDerivedType)
    writer.writeStringValue("webCategoryName", relatedWebCategory.webCategoryName);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RemoteNetwork The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRemoteNetwork(writer: SerializationWriter, remoteNetwork: Partial<RemoteNetwork> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!remoteNetwork || isSerializingDerivedType) { return; }
    serializeEntity(writer, remoteNetwork, isSerializingDerivedType)
    writer.writeObjectValue<RemoteNetworkConnectivityConfiguration>("connectivityConfiguration", remoteNetwork.connectivityConfiguration, serializeRemoteNetworkConnectivityConfiguration);
    writer.writeCollectionOfObjectValues<DeviceLink>("deviceLinks", remoteNetwork.deviceLinks, serializeDeviceLink);
    writer.writeCollectionOfObjectValues<ForwardingProfile>("forwardingProfiles", remoteNetwork.forwardingProfiles, serializeForwardingProfile);
    writer.writeDateValue("lastModifiedDateTime", remoteNetwork.lastModifiedDateTime);
    writer.writeStringValue("name", remoteNetwork.name);
    writer.writeEnumValue<Region>("region", remoteNetwork.region);
    writer.writeStringValue("version", remoteNetwork.version);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RemoteNetworkCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRemoteNetworkCollectionResponse(writer: SerializationWriter, remoteNetworkCollectionResponse: Partial<RemoteNetworkCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!remoteNetworkCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, remoteNetworkCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<RemoteNetwork>("value", remoteNetworkCollectionResponse.value, serializeRemoteNetwork);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RemoteNetworkConnectivityConfiguration The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRemoteNetworkConnectivityConfiguration(writer: SerializationWriter, remoteNetworkConnectivityConfiguration: Partial<RemoteNetworkConnectivityConfiguration> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!remoteNetworkConnectivityConfiguration || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<ConnectivityConfigurationLink>("links", remoteNetworkConnectivityConfiguration.links, serializeConnectivityConfigurationLink);
    writer.writeStringValue("@odata.type", remoteNetworkConnectivityConfiguration.odataType);
    writer.writeStringValue("remoteNetworkId", remoteNetworkConnectivityConfiguration.remoteNetworkId);
    writer.writeStringValue("remoteNetworkName", remoteNetworkConnectivityConfiguration.remoteNetworkName);
    writer.writeAdditionalData(remoteNetworkConnectivityConfiguration.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RemoteNetworkHealthEvent The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRemoteNetworkHealthEvent(writer: SerializationWriter, remoteNetworkHealthEvent: Partial<RemoteNetworkHealthEvent> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!remoteNetworkHealthEvent || isSerializingDerivedType) { return; }
    serializeEntity(writer, remoteNetworkHealthEvent, isSerializingDerivedType)
    writer.writeNumberValue("bgpRoutesAdvertisedCount", remoteNetworkHealthEvent.bgpRoutesAdvertisedCount);
    writer.writeDateValue("createdDateTime", remoteNetworkHealthEvent.createdDateTime);
    writer.writeStringValue("description", remoteNetworkHealthEvent.description);
    writer.writeStringValue("destinationIp", remoteNetworkHealthEvent.destinationIp);
    writer.writeNumberValue("receivedBytes", remoteNetworkHealthEvent.receivedBytes);
    writer.writeStringValue("remoteNetworkId", remoteNetworkHealthEvent.remoteNetworkId);
    writer.writeNumberValue("sentBytes", remoteNetworkHealthEvent.sentBytes);
    writer.writeStringValue("sourceIp", remoteNetworkHealthEvent.sourceIp);
    writer.writeEnumValue<RemoteNetworkStatus>("status", remoteNetworkHealthEvent.status);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RemoteNetworkHealthEventCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRemoteNetworkHealthEventCollectionResponse(writer: SerializationWriter, remoteNetworkHealthEventCollectionResponse: Partial<RemoteNetworkHealthEventCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!remoteNetworkHealthEventCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, remoteNetworkHealthEventCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<RemoteNetworkHealthEvent>("value", remoteNetworkHealthEventCollectionResponse.value, serializeRemoteNetworkHealthEvent);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Reports The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeReports(writer: SerializationWriter, reports: Partial<Reports> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!reports || isSerializingDerivedType) { return; }
    serializeEntity(writer, reports, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RuleDestination The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRuleDestination(writer: SerializationWriter, ruleDestination: Partial<RuleDestination> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!ruleDestination || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", ruleDestination.odataType);
    writer.writeAdditionalData(ruleDestination.additionalData);
    switch (ruleDestination.odataType) {
        case "#microsoft.graph.networkaccess.fqdn":
            serializeFqdn(writer, ruleDestination, true);
        break;
        case "#microsoft.graph.networkaccess.ipAddress":
            serializeIpAddress(writer, ruleDestination, true);
        break;
        case "#microsoft.graph.networkaccess.ipRange":
            serializeIpRange(writer, ruleDestination, true);
        break;
        case "#microsoft.graph.networkaccess.ipSubnet":
            serializeIpSubnet(writer, ruleDestination, true);
        break;
        case "#microsoft.graph.networkaccess.url":
            serializeUrl(writer, ruleDestination, true);
        break;
        case "#microsoft.graph.networkaccess.webCategory":
            serializeWebCategory(writer, ruleDestination, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Settings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSettings(writer: SerializationWriter, settings: Partial<Settings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!settings || isSerializingDerivedType) { return; }
    serializeEntity(writer, settings, isSerializingDerivedType)
    writer.writeObjectValue<ConditionalAccessSettings>("conditionalAccess", settings.conditionalAccess, serializeConditionalAccessSettings);
    writer.writeObjectValue<CrossTenantAccessSettings>("crossTenantAccess", settings.crossTenantAccess, serializeCrossTenantAccessSettings);
    writer.writeObjectValue<ForwardingOptions>("forwardingOptions", settings.forwardingOptions, serializeForwardingOptions);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TenantStatus The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTenantStatus(writer: SerializationWriter, tenantStatus: Partial<TenantStatus> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tenantStatus || isSerializingDerivedType) { return; }
    serializeEntity(writer, tenantStatus, isSerializingDerivedType)
    writer.writeStringValue("onboardingErrorMessage", tenantStatus.onboardingErrorMessage);
    writer.writeEnumValue<OnboardingStatus>("onboardingStatus", tenantStatus.onboardingStatus);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ThirdPartyTokenDetails The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeThirdPartyTokenDetails(writer: SerializationWriter, thirdPartyTokenDetails: Partial<ThirdPartyTokenDetails> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!thirdPartyTokenDetails || isSerializingDerivedType) { return; }
    writer.writeDateValue("expirationDateTime", thirdPartyTokenDetails.expirationDateTime);
    writer.writeDateValue("issuedAtDateTime", thirdPartyTokenDetails.issuedAtDateTime);
    writer.writeStringValue("@odata.type", thirdPartyTokenDetails.odataType);
    writer.writeStringValue("uniqueTokenIdentifier", thirdPartyTokenDetails.uniqueTokenIdentifier);
    writer.writeDateValue("validFromDateTime", thirdPartyTokenDetails.validFromDateTime);
    writer.writeAdditionalData(thirdPartyTokenDetails.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ThreatIntelligenceDestination The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeThreatIntelligenceDestination(writer: SerializationWriter, threatIntelligenceDestination: Partial<ThreatIntelligenceDestination> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!threatIntelligenceDestination || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", threatIntelligenceDestination.odataType);
    writer.writeAdditionalData(threatIntelligenceDestination.additionalData);
    switch (threatIntelligenceDestination.odataType) {
        case "#microsoft.graph.networkaccess.threatIntelligenceFqdnDestination":
            serializeThreatIntelligenceFqdnDestination(writer, threatIntelligenceDestination, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ThreatIntelligenceFqdnDestination The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeThreatIntelligenceFqdnDestination(writer: SerializationWriter, threatIntelligenceFqdnDestination: Partial<ThreatIntelligenceFqdnDestination> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!threatIntelligenceFqdnDestination || isSerializingDerivedType) { return; }
    serializeThreatIntelligenceDestination(writer, threatIntelligenceFqdnDestination, isSerializingDerivedType)
    writer.writeCollectionOfPrimitiveValues<string>("values", threatIntelligenceFqdnDestination.values);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ThreatIntelligenceMatchingConditions The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeThreatIntelligenceMatchingConditions(writer: SerializationWriter, threatIntelligenceMatchingConditions: Partial<ThreatIntelligenceMatchingConditions> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!threatIntelligenceMatchingConditions || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<ThreatIntelligenceDestination>("destinations", threatIntelligenceMatchingConditions.destinations, serializeThreatIntelligenceDestination);
    writer.writeStringValue("@odata.type", threatIntelligenceMatchingConditions.odataType);
    writer.writeEnumValue<ThreatIntelligenceSeverity>("severity", threatIntelligenceMatchingConditions.severity);
    writer.writeAdditionalData(threatIntelligenceMatchingConditions.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ThreatIntelligencePolicy The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeThreatIntelligencePolicy(writer: SerializationWriter, threatIntelligencePolicy: Partial<ThreatIntelligencePolicy> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!threatIntelligencePolicy || isSerializingDerivedType) { return; }
    serializePolicy(writer, threatIntelligencePolicy, isSerializingDerivedType)
    writer.writeDateValue("lastModifiedDateTime", threatIntelligencePolicy.lastModifiedDateTime);
    writer.writeObjectValue<ThreatIntelligencePolicySettings>("settings", threatIntelligencePolicy.settings, serializeThreatIntelligencePolicySettings);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ThreatIntelligencePolicyCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeThreatIntelligencePolicyCollectionResponse(writer: SerializationWriter, threatIntelligencePolicyCollectionResponse: Partial<ThreatIntelligencePolicyCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!threatIntelligencePolicyCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, threatIntelligencePolicyCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ThreatIntelligencePolicy>("value", threatIntelligencePolicyCollectionResponse.value, serializeThreatIntelligencePolicy);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ThreatIntelligencePolicyLink The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeThreatIntelligencePolicyLink(writer: SerializationWriter, threatIntelligencePolicyLink: Partial<ThreatIntelligencePolicyLink> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!threatIntelligencePolicyLink || isSerializingDerivedType) { return; }
    serializePolicyLink(writer, threatIntelligencePolicyLink, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ThreatIntelligencePolicySettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeThreatIntelligencePolicySettings(writer: SerializationWriter, threatIntelligencePolicySettings: Partial<ThreatIntelligencePolicySettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!threatIntelligencePolicySettings || isSerializingDerivedType) { return; }
    writer.writeEnumValue<ThreatIntelligenceAction>("defaultAction", threatIntelligencePolicySettings.defaultAction);
    writer.writeStringValue("@odata.type", threatIntelligencePolicySettings.odataType);
    writer.writeAdditionalData(threatIntelligencePolicySettings.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ThreatIntelligenceRule The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeThreatIntelligenceRule(writer: SerializationWriter, threatIntelligenceRule: Partial<ThreatIntelligenceRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!threatIntelligenceRule || isSerializingDerivedType) { return; }
    serializePolicyRule(writer, threatIntelligenceRule, isSerializingDerivedType)
    writer.writeEnumValue<ThreatIntelligenceAction>("action", threatIntelligenceRule.action);
    writer.writeStringValue("description", threatIntelligenceRule.description);
    writer.writeObjectValue<ThreatIntelligenceMatchingConditions>("matchingConditions", threatIntelligenceRule.matchingConditions, serializeThreatIntelligenceMatchingConditions);
    writer.writeNumberValue("priority", threatIntelligenceRule.priority);
    writer.writeObjectValue<ThreatIntelligenceRuleSettings>("settings", threatIntelligenceRule.settings, serializeThreatIntelligenceRuleSettings);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ThreatIntelligenceRuleSettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeThreatIntelligenceRuleSettings(writer: SerializationWriter, threatIntelligenceRuleSettings: Partial<ThreatIntelligenceRuleSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!threatIntelligenceRuleSettings || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", threatIntelligenceRuleSettings.odataType);
    writer.writeEnumValue<SecurityRuleStatus>("status", threatIntelligenceRuleSettings.status);
    writer.writeAdditionalData(threatIntelligenceRuleSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TlsInspectionDestination The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTlsInspectionDestination(writer: SerializationWriter, tlsInspectionDestination: Partial<TlsInspectionDestination> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tlsInspectionDestination || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", tlsInspectionDestination.odataType);
    writer.writeAdditionalData(tlsInspectionDestination.additionalData);
    switch (tlsInspectionDestination.odataType) {
        case "#microsoft.graph.networkaccess.tlsInspectionFqdnDestination":
            serializeTlsInspectionFqdnDestination(writer, tlsInspectionDestination, true);
        break;
        case "#microsoft.graph.networkaccess.tlsInspectionWebCategoryDestination":
            serializeTlsInspectionWebCategoryDestination(writer, tlsInspectionDestination, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TlsInspectionFqdnDestination The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTlsInspectionFqdnDestination(writer: SerializationWriter, tlsInspectionFqdnDestination: Partial<TlsInspectionFqdnDestination> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tlsInspectionFqdnDestination || isSerializingDerivedType) { return; }
    serializeTlsInspectionDestination(writer, tlsInspectionFqdnDestination, isSerializingDerivedType)
    writer.writeCollectionOfPrimitiveValues<string>("values", tlsInspectionFqdnDestination.values);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TlsInspectionMatchingConditions The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTlsInspectionMatchingConditions(writer: SerializationWriter, tlsInspectionMatchingConditions: Partial<TlsInspectionMatchingConditions> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tlsInspectionMatchingConditions || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<TlsInspectionDestination>("destinations", tlsInspectionMatchingConditions.destinations, serializeTlsInspectionDestination);
    writer.writeStringValue("@odata.type", tlsInspectionMatchingConditions.odataType);
    writer.writeAdditionalData(tlsInspectionMatchingConditions.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TlsInspectionPolicy The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTlsInspectionPolicy(writer: SerializationWriter, tlsInspectionPolicy: Partial<TlsInspectionPolicy> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tlsInspectionPolicy || isSerializingDerivedType) { return; }
    serializePolicy(writer, tlsInspectionPolicy, isSerializingDerivedType)
    writer.writeDateValue("lastModifiedDateTime", tlsInspectionPolicy.lastModifiedDateTime);
    writer.writeObjectValue<TlsInspectionPolicySettings>("settings", tlsInspectionPolicy.settings, serializeTlsInspectionPolicySettings);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TlsInspectionPolicyCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTlsInspectionPolicyCollectionResponse(writer: SerializationWriter, tlsInspectionPolicyCollectionResponse: Partial<TlsInspectionPolicyCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tlsInspectionPolicyCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, tlsInspectionPolicyCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<TlsInspectionPolicy>("value", tlsInspectionPolicyCollectionResponse.value, serializeTlsInspectionPolicy);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TlsInspectionPolicyLink The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTlsInspectionPolicyLink(writer: SerializationWriter, tlsInspectionPolicyLink: Partial<TlsInspectionPolicyLink> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tlsInspectionPolicyLink || isSerializingDerivedType) { return; }
    serializePolicyLink(writer, tlsInspectionPolicyLink, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TlsInspectionPolicySettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTlsInspectionPolicySettings(writer: SerializationWriter, tlsInspectionPolicySettings: Partial<TlsInspectionPolicySettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tlsInspectionPolicySettings || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", tlsInspectionPolicySettings.odataType);
    writer.writeAdditionalData(tlsInspectionPolicySettings.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TlsInspectionRule The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTlsInspectionRule(writer: SerializationWriter, tlsInspectionRule: Partial<TlsInspectionRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tlsInspectionRule || isSerializingDerivedType) { return; }
    serializePolicyRule(writer, tlsInspectionRule, isSerializingDerivedType)
    writer.writeStringValue("description", tlsInspectionRule.description);
    writer.writeObjectValue<TlsInspectionMatchingConditions>("matchingConditions", tlsInspectionRule.matchingConditions, serializeTlsInspectionMatchingConditions);
    writer.writeNumberValue("priority", tlsInspectionRule.priority);
    writer.writeObjectValue<TlsInspectionRuleSettings>("settings", tlsInspectionRule.settings, serializeTlsInspectionRuleSettings);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TlsInspectionRuleSettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTlsInspectionRuleSettings(writer: SerializationWriter, tlsInspectionRuleSettings: Partial<TlsInspectionRuleSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tlsInspectionRuleSettings || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", tlsInspectionRuleSettings.odataType);
    writer.writeEnumValue<SecurityRuleStatus>("status", tlsInspectionRuleSettings.status);
    writer.writeAdditionalData(tlsInspectionRuleSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TlsInspectionWebCategoryDestination The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTlsInspectionWebCategoryDestination(writer: SerializationWriter, tlsInspectionWebCategoryDestination: Partial<TlsInspectionWebCategoryDestination> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tlsInspectionWebCategoryDestination || isSerializingDerivedType) { return; }
    serializeTlsInspectionDestination(writer, tlsInspectionWebCategoryDestination, isSerializingDerivedType)
    writer.writeCollectionOfPrimitiveValues<string>("values", tlsInspectionWebCategoryDestination.values);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TlsTermination The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTlsTermination(writer: SerializationWriter, tlsTermination: Partial<TlsTermination> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tlsTermination || isSerializingDerivedType) { return; }
    serializeEntity(writer, tlsTermination, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ExternalCertificateAuthorityCertificate>("externalCertificateAuthorityCertificates", tlsTermination.externalCertificateAuthorityCertificates, serializeExternalCertificateAuthorityCertificate);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TransactionSummary The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTransactionSummary(writer: SerializationWriter, transactionSummary: Partial<TransactionSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!transactionSummary || isSerializingDerivedType) { return; }
    writer.writeNumberValue("blockedCount", transactionSummary.blockedCount);
    writer.writeStringValue("@odata.type", transactionSummary.odataType);
    writer.writeNumberValue("totalCount", transactionSummary.totalCount);
    writer.writeEnumValue<TrafficType>("trafficType", transactionSummary.trafficType);
    writer.writeAdditionalData(transactionSummary.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TunnelConfiguration The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTunnelConfiguration(writer: SerializationWriter, tunnelConfiguration: Partial<TunnelConfiguration> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tunnelConfiguration || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", tunnelConfiguration.odataType);
    writer.writeStringValue("preSharedKey", tunnelConfiguration.preSharedKey);
    writer.writeStringValue("zoneRedundancyPreSharedKey", tunnelConfiguration.zoneRedundancyPreSharedKey);
    writer.writeAdditionalData(tunnelConfiguration.additionalData);
    switch (tunnelConfiguration.odataType) {
        case "#microsoft.graph.networkaccess.tunnelConfigurationIKEv2Custom":
            serializeTunnelConfigurationIKEv2Custom(writer, tunnelConfiguration, true);
        break;
        case "#microsoft.graph.networkaccess.tunnelConfigurationIKEv2Default":
            serializeTunnelConfigurationIKEv2Default(writer, tunnelConfiguration, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TunnelConfigurationIKEv2Custom The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTunnelConfigurationIKEv2Custom(writer: SerializationWriter, tunnelConfigurationIKEv2Custom: Partial<TunnelConfigurationIKEv2Custom> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tunnelConfigurationIKEv2Custom || isSerializingDerivedType) { return; }
    serializeTunnelConfiguration(writer, tunnelConfigurationIKEv2Custom, isSerializingDerivedType)
    writer.writeEnumValue<DhGroup>("dhGroup", tunnelConfigurationIKEv2Custom.dhGroup);
    writer.writeEnumValue<IkeEncryption>("ikeEncryption", tunnelConfigurationIKEv2Custom.ikeEncryption);
    writer.writeEnumValue<IkeIntegrity>("ikeIntegrity", tunnelConfigurationIKEv2Custom.ikeIntegrity);
    writer.writeEnumValue<IpSecEncryption>("ipSecEncryption", tunnelConfigurationIKEv2Custom.ipSecEncryption);
    writer.writeEnumValue<IpSecIntegrity>("ipSecIntegrity", tunnelConfigurationIKEv2Custom.ipSecIntegrity);
    writer.writeEnumValue<PfsGroup>("pfsGroup", tunnelConfigurationIKEv2Custom.pfsGroup);
    writer.writeNumberValue("saLifeTimeSeconds", tunnelConfigurationIKEv2Custom.saLifeTimeSeconds);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TunnelConfigurationIKEv2Default The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTunnelConfigurationIKEv2Default(writer: SerializationWriter, tunnelConfigurationIKEv2Default: Partial<TunnelConfigurationIKEv2Default> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tunnelConfigurationIKEv2Default || isSerializingDerivedType) { return; }
    serializeTunnelConfiguration(writer, tunnelConfigurationIKEv2Default, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Url The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUrl(writer: SerializationWriter, url: Partial<Url> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!url || isSerializingDerivedType) { return; }
    serializeRuleDestination(writer, url, isSerializingDerivedType)
    writer.writeStringValue("value", url.value);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UsageProfilingPoint The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUsageProfilingPoint(writer: SerializationWriter, usageProfilingPoint: Partial<UsageProfilingPoint> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!usageProfilingPoint || isSerializingDerivedType) { return; }
    writer.writeNumberValue("internetAccessTrafficCount", usageProfilingPoint.internetAccessTrafficCount);
    writer.writeNumberValue("microsoft365AccessTrafficCount", usageProfilingPoint.microsoft365AccessTrafficCount);
    writer.writeStringValue("@odata.type", usageProfilingPoint.odataType);
    writer.writeNumberValue("privateAccessTrafficCount", usageProfilingPoint.privateAccessTrafficCount);
    writer.writeDateValue("timeStampDateTime", usageProfilingPoint.timeStampDateTime);
    writer.writeNumberValue("totalTrafficCount", usageProfilingPoint.totalTrafficCount);
    writer.writeAdditionalData(usageProfilingPoint.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param User The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUser(writer: SerializationWriter, user: Partial<User> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!user || isSerializingDerivedType) { return; }
    writer.writeStringValue("displayName", user.displayName);
    writer.writeDateValue("firstAccessDateTime", user.firstAccessDateTime);
    writer.writeDateValue("lastAccessDateTime", user.lastAccessDateTime);
    writer.writeStringValue("@odata.type", user.odataType);
    writer.writeNumberValue("totalBytesReceived", user.totalBytesReceived);
    writer.writeNumberValue("totalBytesSent", user.totalBytesSent);
    writer.writeEnumValue<TrafficType>("trafficType", user.trafficType);
    writer.writeNumberValue("transactionCount", user.transactionCount);
    writer.writeStringValue("userId", user.userId);
    writer.writeStringValue("userPrincipalName", user.userPrincipalName);
    writer.writeEnumValue<UserType>("userType", user.userType);
    writer.writeAdditionalData(user.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ValidityDate The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeValidityDate(writer: SerializationWriter, validityDate: Partial<ValidityDate> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!validityDate || isSerializingDerivedType) { return; }
    writer.writeDateValue("endDateTime", validityDate.endDateTime);
    writer.writeStringValue("@odata.type", validityDate.odataType);
    writer.writeDateValue("startDateTime", validityDate.startDateTime);
    writer.writeAdditionalData(validityDate.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WebCategoriesSummary The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWebCategoriesSummary(writer: SerializationWriter, webCategoriesSummary: Partial<WebCategoriesSummary> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!webCategoriesSummary || isSerializingDerivedType) { return; }
    writer.writeEnumValue<FilteringPolicyAction>("action", webCategoriesSummary.action);
    writer.writeNumberValue("deviceCount", webCategoriesSummary.deviceCount);
    writer.writeStringValue("@odata.type", webCategoriesSummary.odataType);
    writer.writeNumberValue("transactionCount", webCategoriesSummary.transactionCount);
    writer.writeNumberValue("userCount", webCategoriesSummary.userCount);
    writer.writeObjectValue<WebCategory>("webCategory", webCategoriesSummary.webCategory, serializeWebCategory);
    writer.writeAdditionalData(webCategoriesSummary.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WebCategory The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWebCategory(writer: SerializationWriter, webCategory: Partial<WebCategory> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!webCategory || isSerializingDerivedType) { return; }
    serializeRuleDestination(writer, webCategory, isSerializingDerivedType)
    writer.writeStringValue("displayName", webCategory.displayName);
    writer.writeStringValue("group", webCategory.group);
    writer.writeStringValue("name", webCategory.name);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WebCategoryFilteringRule The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWebCategoryFilteringRule(writer: SerializationWriter, webCategoryFilteringRule: Partial<WebCategoryFilteringRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!webCategoryFilteringRule || isSerializingDerivedType) { return; }
    serializeFilteringRule(writer, webCategoryFilteringRule, isSerializingDerivedType)
}
export interface Settings extends Entity, Parsable {
    /**
     * The conditionalAccess property
     */
    conditionalAccess?: ConditionalAccessSettings | null;
    /**
     * The crossTenantAccess property
     */
    crossTenantAccess?: CrossTenantAccessSettings | null;
    /**
     * The forwardingOptions property
     */
    forwardingOptions?: ForwardingOptions | null;
}
export type Status = (typeof StatusObject)[keyof typeof StatusObject];
export interface TenantStatus extends Entity, Parsable {
    /**
     * Reflects a message to the user if there's an error.
     */
    onboardingErrorMessage?: string | null;
    /**
     * The onboardingStatus property
     */
    onboardingStatus?: OnboardingStatus | null;
}
export interface ThirdPartyTokenDetails extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Time the token will expire.
     */
    expirationDateTime?: Date | null;
    /**
     * Time the token was issued at.
     */
    issuedAtDateTime?: Date | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Unique token identifier.
     */
    uniqueTokenIdentifier?: string | null;
    /**
     * Time the token is valid from.
     */
    validFromDateTime?: Date | null;
}
export type ThreatIntelligenceAction = (typeof ThreatIntelligenceActionObject)[keyof typeof ThreatIntelligenceActionObject];
export interface ThreatIntelligenceDestination extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface ThreatIntelligenceFqdnDestination extends Parsable, ThreatIntelligenceDestination {
    /**
     * A collection of fully qualified domain names (FQDNs) associated with potential security threats.
     */
    values?: string[] | null;
}
export interface ThreatIntelligenceMatchingConditions extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * A collection of destinations that are considered potential threats for network access evaluation.
     */
    destinations?: ThreatIntelligenceDestination[] | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The severity level of the threat associated with the destinations. Higher severity levels typically result in stricter security controls. The possible values are: low, medium, high, unknownFutureValue.
     */
    severity?: ThreatIntelligenceSeverity | null;
}
export interface ThreatIntelligencePolicy extends Parsable, Policy {
    /**
     * The date and time when the policy was last modified.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * The settings property
     */
    settings?: ThreatIntelligencePolicySettings | null;
}
export interface ThreatIntelligencePolicyCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ThreatIntelligencePolicy[] | null;
}
export interface ThreatIntelligencePolicyLink extends Parsable, PolicyLink {
}
export interface ThreatIntelligencePolicySettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The defaultAction property
     */
    defaultAction?: ThreatIntelligenceAction | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface ThreatIntelligenceRule extends Parsable, PolicyRule {
    /**
     * The action property
     */
    action?: ThreatIntelligenceAction | null;
    /**
     * A description of the threat intelligence rule. Supports $filter (eq).
     */
    description?: string | null;
    /**
     * The matchingConditions property
     */
    matchingConditions?: ThreatIntelligenceMatchingConditions | null;
    /**
     * The priority of the rule which determines the order of rule evaluation. Lower values indicate higher priority. Supports $filter (eq).
     */
    priority?: number | null;
    /**
     * The settings property
     */
    settings?: ThreatIntelligenceRuleSettings | null;
}
export interface ThreatIntelligenceRuleSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The status property
     */
    status?: SecurityRuleStatus | null;
}
export type ThreatIntelligenceSeverity = (typeof ThreatIntelligenceSeverityObject)[keyof typeof ThreatIntelligenceSeverityObject];
export type ThreatSeverity = (typeof ThreatSeverityObject)[keyof typeof ThreatSeverityObject];
export type TlsCertificateStatus = (typeof TlsCertificateStatusObject)[keyof typeof TlsCertificateStatusObject];
export interface TlsInspectionDestination extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface TlsInspectionFqdnDestination extends Parsable, TlsInspectionDestination {
    /**
     * A collection of fully qualified domain names to match against. The special value * represents any domain. Wildcard patterns can be used in domain names (for example: *.contoso.com). This collection cannot be empty or null.
     */
    values?: string[] | null;
}
export interface TlsInspectionMatchingConditions extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * A collection of destinations to match against. Can include FQDN destinations or web category destinations. An empty collection means no destination matching is performed. At least one destination must have non-null properties to allow for matching.
     */
    destinations?: TlsInspectionDestination[] | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface TlsInspectionPolicy extends Parsable, Policy {
    /**
     * The timestamp of when the policy was last modified. Supports $filter (eq, ne, not, ge, le, in) and $orderby. Read-only.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * The settings property
     */
    settings?: TlsInspectionPolicySettings | null;
}
export interface TlsInspectionPolicyCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: TlsInspectionPolicy[] | null;
}
export interface TlsInspectionPolicyLink extends Parsable, PolicyLink {
}
export interface TlsInspectionPolicySettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface TlsInspectionRule extends Parsable, PolicyRule {
    /**
     * Optional description explaining the purpose of the rule.
     */
    description?: string | null;
    /**
     * The matchingConditions property
     */
    matchingConditions?: TlsInspectionMatchingConditions | null;
    /**
     * The priority of the rule. Rules are evaluated in ascending order of priority. Lower numbers indicate higher priority. Supports $filter (eq, ne, not, ge, le, in) and $orderby.
     */
    priority?: number | null;
    /**
     * The settings property
     */
    settings?: TlsInspectionRuleSettings | null;
}
export interface TlsInspectionRuleSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The status property
     */
    status?: SecurityRuleStatus | null;
}
export interface TlsInspectionWebCategoryDestination extends Parsable, TlsInspectionDestination {
    /**
     * A collection of web category names to match against. This collection cannot be empty or null.
     */
    values?: string[] | null;
}
export interface TlsTermination extends Entity, Parsable {
    /**
     * List of customer's Certificate Authority (CA) certificates used for TLS inspection in Global Secure Access
     */
    externalCertificateAuthorityCertificates?: ExternalCertificateAuthorityCertificate[] | null;
}
export type TrafficForwardingType = (typeof TrafficForwardingTypeObject)[keyof typeof TrafficForwardingTypeObject];
export type TrafficType = (typeof TrafficTypeObject)[keyof typeof TrafficTypeObject];
export interface TransactionSummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The number of transactions that were blocked.
     */
    blockedCount?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The total number of transactions.
     */
    totalCount?: number | null;
    /**
     * The trafficType property
     */
    trafficType?: TrafficType | null;
}
export interface TunnelConfiguration extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * A key to establish secure connection between the link and VPN tunnel on the edge.
     */
    preSharedKey?: string | null;
    /**
     * Another key for zone redundant tunnel. Required only when you select zoneRedundancy redindancyTier when creating a deviceLink.
     */
    zoneRedundancyPreSharedKey?: string | null;
}
export interface TunnelConfigurationIKEv2Custom extends Parsable, TunnelConfiguration {
    /**
     * The dhGroup property
     */
    dhGroup?: DhGroup | null;
    /**
     * The ikeEncryption property
     */
    ikeEncryption?: IkeEncryption | null;
    /**
     * The ikeIntegrity property
     */
    ikeIntegrity?: IkeIntegrity | null;
    /**
     * The ipSecEncryption property
     */
    ipSecEncryption?: IpSecEncryption | null;
    /**
     * The ipSecIntegrity property
     */
    ipSecIntegrity?: IpSecIntegrity | null;
    /**
     * The pfsGroup property
     */
    pfsGroup?: PfsGroup | null;
    /**
     * a standard specifiying Security Association lifetime with recommended values from an RFC standard.
     */
    saLifeTimeSeconds?: number | null;
}
export interface TunnelConfigurationIKEv2Default extends Parsable, TunnelConfiguration {
}
export interface Url extends Parsable, RuleDestination {
    /**
     * URL Address
     */
    value?: string | null;
}
export interface UsageProfilingPoint extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The count of traffic requests directed to general internet destinations.
     */
    internetAccessTrafficCount?: number | null;
    /**
     * The count of traffic requests directed to Microsoft 365 services.
     */
    microsoft365AccessTrafficCount?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The count of traffic requests directed to internal private network destinations.
     */
    privateAccessTrafficCount?: number | null;
    /**
     * The date and time of this data point.
     */
    timeStampDateTime?: Date | null;
    /**
     * The total count of all traffic requests across all access types.
     */
    totalTrafficCount?: number | null;
}
export type UsageStatus = (typeof UsageStatusObject)[keyof typeof UsageStatusObject];
export interface User extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * User display Name.
     */
    displayName?: string | null;
    /**
     * The firstAccessDateTime property
     */
    firstAccessDateTime?: Date | null;
    /**
     * The date and time of the most recent access.
     */
    lastAccessDateTime?: Date | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The totalBytesReceived property
     */
    totalBytesReceived?: number | null;
    /**
     * The totalBytesSent property
     */
    totalBytesSent?: number | null;
    /**
     * The trafficType property
     */
    trafficType?: TrafficType | null;
    /**
     * The transactionCount property
     */
    transactionCount?: number | null;
    /**
     * The ID for the user.
     */
    userId?: string | null;
    /**
     * A unique identifier that is associated with a user in a system or directory. Typically, this value is an email address that is used for user authentication and identification.
     */
    userPrincipalName?: string | null;
    /**
     * The userType property
     */
    userType?: UserType | null;
}
export type UserType = (typeof UserTypeObject)[keyof typeof UserTypeObject];
export interface ValidityDate extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Date and time when certificate validity expires.
     */
    endDateTime?: Date | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Date and time when certificate validity begins.
     */
    startDateTime?: Date | null;
}
export interface WebCategoriesSummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The action property
     */
    action?: FilteringPolicyAction | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The number of unique devices that were seen.
     */
    deviceCount?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The number of transactions that were seen.
     */
    transactionCount?: number | null;
    /**
     * The number of unique Microsoft Entra ID users that were seen.
     */
    userCount?: number | null;
    /**
     * The webCategory property
     */
    webCategory?: WebCategory | null;
}
export interface WebCategory extends Parsable, RuleDestination {
    /**
     * The display name for the web category.
     */
    displayName?: string | null;
    /**
     * The group or category to which the web category belongs.
     */
    group?: string | null;
    /**
     * The unique name that is associated with the web category.
     */
    name?: string | null;
}
export interface WebCategoryFilteringRule extends FilteringRule, Parsable {
}
export const AccessTypeObject = {
    QuickAccess: "quickAccess",
    PrivateAccess: "privateAccess",
    UnknownFutureValue: "unknownFutureValue",
    AppAccess: "appAccess",
} as const;
export const AlertSeverityObject = {
    Informational: "informational",
    Low: "low",
    Medium: "medium",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AlertTypeObject = {
    UnhealthyRemoteNetworks: "unhealthyRemoteNetworks",
    UnhealthyConnectors: "unhealthyConnectors",
    DeviceTokenInconsistency: "deviceTokenInconsistency",
    CrossTenantAnomaly: "crossTenantAnomaly",
    SuspiciousProcess: "suspiciousProcess",
    ThreatIntelligenceTransactions: "threatIntelligenceTransactions",
    UnknownFutureValue: "unknownFutureValue",
    WebContentBlocked: "webContentBlocked",
    Malware: "malware",
    PatientZero: "patientZero",
    Dlp: "dlp",
} as const;
export const AlgorithmObject = {
    Md5: "md5",
    Sha1: "sha1",
    Sha256: "sha256",
    Sha256ac: "sha256ac",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const BandwidthCapacityInMbpsObject = {
    Mbps250: "mbps250",
    Mbps500: "mbps500",
    Mbps750: "mbps750",
    Mbps1000: "mbps1000",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ClientFallbackActionObject = {
    Bypass: "bypass",
    Block: "block",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ConnectionStatusObject = {
    Open: "open",
    Active: "active",
    Closed: "closed",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ConnectivityStateObject = {
    Pending: "pending",
    Connected: "connected",
    Inactive: "inactive",
    ErrorEscaped: "error",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeviceCategoryObject = {
    Client: "client",
    Branch: "branch",
    UnknownFutureValue: "unknownFutureValue",
    RemoteNetwork: "remoteNetwork",
} as const;
export const DeviceVendorObject = {
    BarracudaNetworks: "barracudaNetworks",
    CheckPoint: "checkPoint",
    CiscoMeraki: "ciscoMeraki",
    Citrix: "citrix",
    Fortinet: "fortinet",
    HpeAruba: "hpeAruba",
    NetFoundry: "netFoundry",
    Nuage: "nuage",
    OpenSystems: "openSystems",
    PaloAltoNetworks: "paloAltoNetworks",
    RiverbedTechnology: "riverbedTechnology",
    SilverPeak: "silverPeak",
    VmWareSdWan: "vmWareSdWan",
    Versa: "versa",
    Other: "other",
    CiscoCatalyst: "ciscoCatalyst",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DhGroupObject = {
    DhGroup14: "dhGroup14",
    DhGroup24: "dhGroup24",
    DhGroup2048: "dhGroup2048",
    Ecp256: "ecp256",
    Ecp384: "ecp384",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const FilteringPolicyActionObject = {
    Block: "block",
    Allow: "allow",
    UnknownFutureValue: "unknownFutureValue",
    Bypass: "bypass",
    Alert: "alert",
} as const;
export const ForwardingCategoryObject = {
    DefaultEscaped: "default",
    Optimized: "optimized",
    Allow: "allow",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ForwardingRuleActionObject = {
    Bypass: "bypass",
    Forward: "forward",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HttpMethodObject = {
    Get: "get",
    Post: "post",
    Put: "put",
    Delete: "delete",
    Head: "head",
    Options: "options",
    Connect: "connect",
    Patch: "patch",
    Trace: "trace",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IkeEncryptionObject = {
    Aes128: "aes128",
    Aes192: "aes192",
    Aes256: "aes256",
    GcmAes128: "gcmAes128",
    GcmAes256: "gcmAes256",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IkeIntegrityObject = {
    Sha256: "sha256",
    Sha384: "sha384",
    GcmAes128: "gcmAes128",
    GcmAes256: "gcmAes256",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IntentCategoryObject = {
    InitialAccess: "initialAccess",
    Persistence: "persistence",
    PrivilegeEscalation: "privilegeEscalation",
    DefenseEvasion: "defenseEvasion",
    CredentialAccess: "credentialAccess",
    Discovery: "discovery",
    LateralMovement: "lateralMovement",
    Execution: "execution",
    Collection: "collection",
    Exfiltration: "exfiltration",
    CommandAndControl: "commandAndControl",
    Impact: "impact",
    ImpairProcessControl: "impairProcessControl",
    InhibitResponseFunction: "inhibitResponseFunction",
    Reconnaissance: "reconnaissance",
    ResourceDevelopment: "resourceDevelopment",
    Evasion: "evasion",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IpSecEncryptionObject = {
    None: "none",
    GcmAes128: "gcmAes128",
    GcmAes192: "gcmAes192",
    GcmAes256: "gcmAes256",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IpSecIntegrityObject = {
    GcmAes128: "gcmAes128",
    GcmAes192: "gcmAes192",
    GcmAes256: "gcmAes256",
    Sha256: "sha256",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const MalwareCategoryObject = {
    Adware: "adware",
    Backdoor: "backdoor",
    Behavior: "behavior",
    Bot: "bot",
    BrowserModifier: "browserModifier",
    Constructor: "constructor",
    Cryptojacking: "cryptojacking",
    Ddos: "ddos",
    Dropper: "dropper",
    DropperMalware: "dropperMalware",
    Exploit: "exploit",
    FilelessMalware: "filelessMalware",
    HackTool: "hackTool",
    HybridMalware: "hybridMalware",
    Joke: "joke",
    Keylogger: "keylogger",
    Misleading: "misleading",
    MonitoringTool: "monitoringTool",
    PolymorphicMalware: "polymorphicMalware",
    PasswordStealer: "passwordStealer",
    Program: "program",
    Ransomware: "ransomware",
    RemoteAccess: "remoteAccess",
    Rogue: "rogue",
    Rootkit: "rootkit",
    SettingsModifier: "settingsModifier",
    SoftwareBundler: "softwareBundler",
    Spammer: "spammer",
    Spoofer: "spoofer",
    Spyware: "spyware",
    Tool: "tool",
    Trojan: "trojan",
    TrojanClicker: "trojanClicker",
    TrojanDownloader: "trojanDownloader",
    TrojanNotifier: "trojanNotifier",
    TrojanProxy: "trojanProxy",
    TrojanSpy: "trojanSpy",
    Virus: "virus",
    WiperMalware: "wiperMalware",
    Worm: "worm",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const NetworkDestinationTypeObject = {
    Url: "url",
    Fqdn: "fqdn",
    IpAddress: "ipAddress",
    IpRange: "ipRange",
    IpSubnet: "ipSubnet",
    WebCategory: "webCategory",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const NetworkingProtocolObject = {
    Ip: "ip",
    Icmp: "icmp",
    Igmp: "igmp",
    Ggp: "ggp",
    Ipv4: "ipv4",
    Tcp: "tcp",
    Pup: "pup",
    Udp: "udp",
    Idp: "idp",
    Ipv6: "ipv6",
    Ipv6RoutingHeader: "ipv6RoutingHeader",
    Ipv6FragmentHeader: "ipv6FragmentHeader",
    IpSecEncapsulatingSecurityPayload: "ipSecEncapsulatingSecurityPayload",
    IpSecAuthenticationHeader: "ipSecAuthenticationHeader",
    IcmpV6: "icmpV6",
    Ipv6NoNextHeader: "ipv6NoNextHeader",
    Ipv6DestinationOptions: "ipv6DestinationOptions",
    Nd: "nd",
    Ipx: "ipx",
    Raw: "raw",
    Spx: "spx",
    SpxII: "spxII",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const NetworkTrafficOperationStatusObject = {
    Success: "success",
    Failure: "failure",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const OnboardingStatusObject = {
    Offboarded: "offboarded",
    OffboardingInProgress: "offboardingInProgress",
    OnboardingInProgress: "onboardingInProgress",
    Onboarded: "onboarded",
    OnboardingErrorOccurred: "onboardingErrorOccurred",
    OffboardingErrorOccurred: "offboardingErrorOccurred",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const PfsGroupObject = {
    None: "none",
    Pfs1: "pfs1",
    Pfs2: "pfs2",
    Pfs14: "pfs14",
    Pfs24: "pfs24",
    Pfs2048: "pfs2048",
    Pfsmm: "pfsmm",
    Ecp256: "ecp256",
    Ecp384: "ecp384",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RedundancyTierObject = {
    NoRedundancy: "noRedundancy",
    ZoneRedundancy: "zoneRedundancy",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RegionObject = {
    EastUS: "eastUS",
    EastUS2: "eastUS2",
    WestUS: "westUS",
    WestUS2: "westUS2",
    WestUS3: "westUS3",
    CentralUS: "centralUS",
    NorthCentralUS: "northCentralUS",
    SouthCentralUS: "southCentralUS",
    NorthEurope: "northEurope",
    WestEurope: "westEurope",
    FranceCentral: "franceCentral",
    GermanyWestCentral: "germanyWestCentral",
    SwitzerlandNorth: "switzerlandNorth",
    UkSouth: "ukSouth",
    CanadaEast: "canadaEast",
    CanadaCentral: "canadaCentral",
    SouthAfricaWest: "southAfricaWest",
    SouthAfricaNorth: "southAfricaNorth",
    UaeNorth: "uaeNorth",
    AustraliaEast: "australiaEast",
    WestCentralUS: "westCentralUS",
    CentralIndia: "centralIndia",
    SouthEastAsia: "southEastAsia",
    SwedenCentral: "swedenCentral",
    SouthIndia: "southIndia",
    AustraliaSouthEast: "australiaSouthEast",
    KoreaCentral: "koreaCentral",
    PolandCentral: "polandCentral",
    BrazilSouth: "brazilSouth",
    JapanEast: "japanEast",
    JapanWest: "japanWest",
    KoreaSouth: "koreaSouth",
    ItalyNorth: "italyNorth",
    FranceSouth: "franceSouth",
    IsraelCentral: "israelCentral",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RemoteNetworkStatusObject = {
    TunnelDisconnected: "tunnelDisconnected",
    TunnelConnected: "tunnelConnected",
    BgpDisconnected: "bgpDisconnected",
    BgpConnected: "bgpConnected",
    RemoteNetworkAlive: "remoteNetworkAlive",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SecurityRuleStatusObject = {
    Enabled: "enabled",
    Disabled: "disabled",
    ReportOnly: "reportOnly",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const StatusObject = {
    Enabled: "enabled",
    Disabled: "disabled",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ThreatIntelligenceActionObject = {
    Allow: "allow",
    Block: "block",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ThreatIntelligenceSeverityObject = {
    Low: "low",
    Medium: "medium",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ThreatSeverityObject = {
    Low: "low",
    Medium: "medium",
    High: "high",
    Critical: "critical",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const TlsCertificateStatusObject = {
    CsrGenerated: "csrGenerated",
    Enrolling: "enrolling",
    Active: "active",
    UnknownFutureValue: "unknownFutureValue",
    Expiring: "expiring",
    Expired: "expired",
} as const;
export const TrafficForwardingTypeObject = {
    M365: "m365",
    Internet: "internet",
    Private: "private",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const TrafficTypeObject = {
    Internet: "internet",
    Private: "private",
    Microsoft365: "microsoft365",
    All: "all",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const UsageStatusObject = {
    FrequentlyUsed: "frequentlyUsed",
    RarelyUsed: "rarelyUsed",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const UserTypeObject = {
    Member: "member",
    Guest: "guest",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
