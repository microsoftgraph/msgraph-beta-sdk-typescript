/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, type BaseCollectionPaginationCountResponse, type Entity } from '../index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Duration, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface ApplicableContent extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Catalog entry for the update or content.
     */
    catalogEntry?: CatalogEntry | null;
    /**
     * ID of the catalog entry for the applicable content.
     */
    catalogEntryId?: string | null;
    /**
     * Collection of devices and recommendations for applicable catalog content.
     */
    matchedDevices?: ApplicableContentDeviceMatch[] | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface ApplicableContentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ApplicableContent[] | null;
}
export interface ApplicableContentDeviceMatch extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Collection of vendors who recommend the content.
     */
    deviceId?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Collection of vendors who recommend the content.
     */
    recommendedBy?: string[] | null;
}
export interface ApplicableContentDeviceMatchCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ApplicableContentDeviceMatch[] | null;
}
export interface AzureADDevice extends Parsable, UpdatableAsset {
    /**
     * The enrollment property
     */
    enrollment?: UpdateManagementEnrollment | null;
    /**
     * Specifies any errors that prevent the device from being enrolled in update management or receving deployed content. Read-only. Returned by default.
     */
    errors?: UpdatableAssetError[] | null;
}
export interface AzureADDeviceRegistrationError extends Parsable, UpdatableAssetError {
    /**
     * The reason property
     */
    reason?: AzureADDeviceRegistrationErrorReason | null;
}
export type AzureADDeviceRegistrationErrorReason = (typeof AzureADDeviceRegistrationErrorReasonObject)[keyof typeof AzureADDeviceRegistrationErrorReasonObject];
export type BodyType = (typeof BodyTypeObject)[keyof typeof BodyTypeObject];
export interface BuildVersionDetails extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The build number of the product release. Read-only.
     */
    buildNumber?: number | null;
    /**
     * The major version of the product release. Read-only.
     */
    majorVersion?: number | null;
    /**
     * The minor version of the product release. Read-only.
     */
    minorVersion?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The update build revision number of the product revision. Read-only.
     */
    updateBuildRevision?: number | null;
}
export interface Catalog extends Entity, Parsable {
    /**
     * Lists the content that you can approve for deployment. Read-only.
     */
    entries?: CatalogEntry[] | null;
}
export interface CatalogContent extends DeployableContent, Parsable {
    /**
     * The catalogEntry property
     */
    catalogEntry?: CatalogEntry | null;
}
export interface CatalogEntry extends Entity, Parsable {
    /**
     * The date on which the content is no longer available to deploy. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    deployableUntilDateTime?: Date | null;
    /**
     * The display name of the content. Read-only.
     */
    displayName?: string | null;
    /**
     * The release date for the content. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    releaseDateTime?: Date | null;
}
export interface CatalogEntryCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CatalogEntry[] | null;
}
export interface ComplianceChange extends Entity, Parsable {
    /**
     * The date and time when a compliance change was created.
     */
    createdDateTime?: Date | null;
    /**
     * True indicates that a compliance change is revoked, preventing further application. Revoking a compliance change is a final action.
     */
    isRevoked?: boolean | null;
    /**
     * The date and time when the compliance change was revoked.
     */
    revokedDateTime?: Date | null;
    /**
     * The policy this compliance change is a member of.
     */
    updatePolicy?: UpdatePolicy | null;
}
export interface ComplianceChangeCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ComplianceChange[] | null;
}
export interface ComplianceChangeRule extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The date and time when the rule was created.
     */
    createdDateTime?: Date | null;
    /**
     * The date and time when the rule was last evaluated.
     */
    lastEvaluatedDateTime?: Date | null;
    /**
     * The date and time when the rule was last modified.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface ContentApplicabilitySettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Offer if the update is recommended by a vendor in the list, otherwise withhold the offer.
     */
    offerWhileRecommendedBy?: string[] | null;
    /**
     * Settings for governing safeguard-holds on offering content.
     */
    safeguard?: SafeguardSettings | null;
}
export interface ContentApproval extends ComplianceChange, Parsable {
    /**
     * The content property
     */
    content?: DeployableContent | null;
    /**
     * Deployments created as a result of applying the approval.
     */
    deployments?: Deployment[] | null;
    /**
     * Settings for governing how to deploy content.
     */
    deploymentSettings?: DeploymentSettings | null;
}
export interface ContentApprovalRule extends ComplianceChangeRule, Parsable {
    /**
     * A filter to determine which content matches the rule on an ongoing basis.
     */
    contentFilter?: ContentFilter | null;
    /**
     * The time before the deployment starts represented in ISO 8601 format for durations.
     */
    durationBeforeDeploymentStart?: Duration | null;
}
export interface ContentFilter extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ApplicableContentCollectionResponse}
 */
// @ts-ignore
export function createApplicableContentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoApplicableContentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ApplicableContentDeviceMatchCollectionResponse}
 */
// @ts-ignore
export function createApplicableContentDeviceMatchCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoApplicableContentDeviceMatchCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ApplicableContentDeviceMatch}
 */
// @ts-ignore
export function createApplicableContentDeviceMatchFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoApplicableContentDeviceMatch;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ApplicableContent}
 */
// @ts-ignore
export function createApplicableContentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoApplicableContent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AzureADDevice}
 */
// @ts-ignore
export function createAzureADDeviceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAzureADDevice;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AzureADDeviceRegistrationError}
 */
// @ts-ignore
export function createAzureADDeviceRegistrationErrorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAzureADDeviceRegistrationError;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BuildVersionDetails}
 */
// @ts-ignore
export function createBuildVersionDetailsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBuildVersionDetails;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CatalogContent}
 */
// @ts-ignore
export function createCatalogContentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCatalogContent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CatalogEntryCollectionResponse}
 */
// @ts-ignore
export function createCatalogEntryCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCatalogEntryCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CatalogEntry}
 */
// @ts-ignore
export function createCatalogEntryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.driverUpdateCatalogEntry":
                    return deserializeIntoDriverUpdateCatalogEntry;
                case "#microsoft.graph.windowsUpdates.featureUpdateCatalogEntry":
                    return deserializeIntoFeatureUpdateCatalogEntry;
                case "#microsoft.graph.windowsUpdates.qualityUpdateCatalogEntry":
                    return deserializeIntoQualityUpdateCatalogEntry;
                case "#microsoft.graph.windowsUpdates.softwareUpdateCatalogEntry":
                    return deserializeIntoSoftwareUpdateCatalogEntry;
            }
        }
    }
    return deserializeIntoCatalogEntry;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Catalog}
 */
// @ts-ignore
export function createCatalogFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCatalog;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ComplianceChangeCollectionResponse}
 */
// @ts-ignore
export function createComplianceChangeCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoComplianceChangeCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ComplianceChange}
 */
// @ts-ignore
export function createComplianceChangeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.contentApproval":
                    return deserializeIntoContentApproval;
            }
        }
    }
    return deserializeIntoComplianceChange;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ComplianceChangeRule}
 */
// @ts-ignore
export function createComplianceChangeRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.contentApprovalRule":
                    return deserializeIntoContentApprovalRule;
            }
        }
    }
    return deserializeIntoComplianceChangeRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContentApplicabilitySettings}
 */
// @ts-ignore
export function createContentApplicabilitySettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContentApplicabilitySettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContentApproval}
 */
// @ts-ignore
export function createContentApprovalFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContentApproval;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContentApprovalRule}
 */
// @ts-ignore
export function createContentApprovalRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContentApprovalRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContentFilter}
 */
// @ts-ignore
export function createContentFilterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.driverUpdateFilter":
                    return deserializeIntoDriverUpdateFilter;
                case "#microsoft.graph.windowsUpdates.qualityUpdateFilter":
                    return deserializeIntoQualityUpdateFilter;
                case "#microsoft.graph.windowsUpdates.remediationUpdateFilter":
                    return deserializeIntoRemediationUpdateFilter;
                case "#microsoft.graph.windowsUpdates.softwareUpdateFilter":
                    return deserializeIntoSoftwareUpdateFilter;
                case "#microsoft.graph.windowsUpdates.windowsUpdateFilter":
                    return deserializeIntoWindowsUpdateFilter;
            }
        }
    }
    return deserializeIntoContentFilter;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CveInformation}
 */
// @ts-ignore
export function createCveInformationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCveInformation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DateDrivenRolloutSettings}
 */
// @ts-ignore
export function createDateDrivenRolloutSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDateDrivenRolloutSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeployableContent}
 */
// @ts-ignore
export function createDeployableContentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.catalogContent":
                    return deserializeIntoCatalogContent;
            }
        }
    }
    return deserializeIntoDeployableContent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentAudienceCollectionResponse}
 */
// @ts-ignore
export function createDeploymentAudienceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentAudienceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentAudience}
 */
// @ts-ignore
export function createDeploymentAudienceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentAudience;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentCollectionResponse}
 */
// @ts-ignore
export function createDeploymentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Deployment}
 */
// @ts-ignore
export function createDeploymentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeployment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentSettings}
 */
// @ts-ignore
export function createDeploymentSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentState}
 */
// @ts-ignore
export function createDeploymentStateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentState;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentStateReason}
 */
// @ts-ignore
export function createDeploymentStateReasonFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentStateReason;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DriverUpdateCatalogEntry}
 */
// @ts-ignore
export function createDriverUpdateCatalogEntryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDriverUpdateCatalogEntry;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DriverUpdateFilter}
 */
// @ts-ignore
export function createDriverUpdateFilterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDriverUpdateFilter;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DurationDrivenRolloutSettings}
 */
// @ts-ignore
export function createDurationDrivenRolloutSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDurationDrivenRolloutSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EditionCollectionResponse}
 */
// @ts-ignore
export function createEditionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEditionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Edition}
 */
// @ts-ignore
export function createEditionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExpediteSettings}
 */
// @ts-ignore
export function createExpediteSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExpediteSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FeatureUpdateCatalogEntry}
 */
// @ts-ignore
export function createFeatureUpdateCatalogEntryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFeatureUpdateCatalogEntry;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GradualRolloutSettings}
 */
// @ts-ignore
export function createGradualRolloutSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.dateDrivenRolloutSettings":
                    return deserializeIntoDateDrivenRolloutSettings;
                case "#microsoft.graph.windowsUpdates.durationDrivenRolloutSettings":
                    return deserializeIntoDurationDrivenRolloutSettings;
                case "#microsoft.graph.windowsUpdates.rateDrivenRolloutSettings":
                    return deserializeIntoRateDrivenRolloutSettings;
            }
        }
    }
    return deserializeIntoGradualRolloutSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ItemBody}
 */
// @ts-ignore
export function createItemBodyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoItemBody;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KnowledgeBaseArticle}
 */
// @ts-ignore
export function createKnowledgeBaseArticleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKnowledgeBaseArticle;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KnownIssueCollectionResponse}
 */
// @ts-ignore
export function createKnownIssueCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKnownIssueCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KnownIssue}
 */
// @ts-ignore
export function createKnownIssueFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKnownIssue;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KnownIssueHistoryItem}
 */
// @ts-ignore
export function createKnownIssueHistoryItemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKnownIssueHistoryItem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MonitoringRule}
 */
// @ts-ignore
export function createMonitoringRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMonitoringRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MonitoringSettings}
 */
// @ts-ignore
export function createMonitoringSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMonitoringSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OperationalInsightsConnection}
 */
// @ts-ignore
export function createOperationalInsightsConnectionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOperationalInsightsConnection;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProductCollectionResponse}
 */
// @ts-ignore
export function createProductCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProductCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Product}
 */
// @ts-ignore
export function createProductFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProduct;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProductRevisionCollectionResponse}
 */
// @ts-ignore
export function createProductRevisionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProductRevisionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProductRevision}
 */
// @ts-ignore
export function createProductRevisionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProductRevision;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {QualityUpdateCatalogEntry}
 */
// @ts-ignore
export function createQualityUpdateCatalogEntryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQualityUpdateCatalogEntry;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {QualityUpdateCveSeverityInformation}
 */
// @ts-ignore
export function createQualityUpdateCveSeverityInformationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQualityUpdateCveSeverityInformation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {QualityUpdateFilter}
 */
// @ts-ignore
export function createQualityUpdateFilterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQualityUpdateFilter;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RateDrivenRolloutSettings}
 */
// @ts-ignore
export function createRateDrivenRolloutSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRateDrivenRolloutSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RemediationUpdateFilter}
 */
// @ts-ignore
export function createRemediationUpdateFilterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRemediationUpdateFilter;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ResourceConnectionCollectionResponse}
 */
// @ts-ignore
export function createResourceConnectionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoResourceConnectionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ResourceConnection}
 */
// @ts-ignore
export function createResourceConnectionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.operationalInsightsConnection":
                    return deserializeIntoOperationalInsightsConnection;
            }
        }
    }
    return deserializeIntoResourceConnection;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SafeguardProfile}
 */
// @ts-ignore
export function createSafeguardProfileFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSafeguardProfile;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SafeguardSettings}
 */
// @ts-ignore
export function createSafeguardSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSafeguardSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ScheduleSettings}
 */
// @ts-ignore
export function createScheduleSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoScheduleSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServicingPeriod}
 */
// @ts-ignore
export function createServicingPeriodFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServicingPeriod;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SoftwareUpdateCatalogEntry}
 */
// @ts-ignore
export function createSoftwareUpdateCatalogEntryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.driverUpdateCatalogEntry":
                    return deserializeIntoDriverUpdateCatalogEntry;
                case "#microsoft.graph.windowsUpdates.featureUpdateCatalogEntry":
                    return deserializeIntoFeatureUpdateCatalogEntry;
                case "#microsoft.graph.windowsUpdates.qualityUpdateCatalogEntry":
                    return deserializeIntoQualityUpdateCatalogEntry;
            }
        }
    }
    return deserializeIntoSoftwareUpdateCatalogEntry;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SoftwareUpdateFilter}
 */
// @ts-ignore
export function createSoftwareUpdateFilterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.driverUpdateFilter":
                    return deserializeIntoDriverUpdateFilter;
                case "#microsoft.graph.windowsUpdates.qualityUpdateFilter":
                    return deserializeIntoQualityUpdateFilter;
                case "#microsoft.graph.windowsUpdates.remediationUpdateFilter":
                    return deserializeIntoRemediationUpdateFilter;
                case "#microsoft.graph.windowsUpdates.windowsUpdateFilter":
                    return deserializeIntoWindowsUpdateFilter;
            }
        }
    }
    return deserializeIntoSoftwareUpdateFilter;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatableAssetCollectionResponse}
 */
// @ts-ignore
export function createUpdatableAssetCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdatableAssetCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatableAssetError}
 */
// @ts-ignore
export function createUpdatableAssetErrorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.azureADDeviceRegistrationError":
                    return deserializeIntoAzureADDeviceRegistrationError;
            }
        }
    }
    return deserializeIntoUpdatableAssetError;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatableAsset}
 */
// @ts-ignore
export function createUpdatableAssetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.azureADDevice":
                    return deserializeIntoAzureADDevice;
                case "#microsoft.graph.windowsUpdates.updatableAssetGroup":
                    return deserializeIntoUpdatableAssetGroup;
            }
        }
    }
    return deserializeIntoUpdatableAsset;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatableAssetGroup}
 */
// @ts-ignore
export function createUpdatableAssetGroupFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdatableAssetGroup;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdateCategoryEnrollmentInformation}
 */
// @ts-ignore
export function createUpdateCategoryEnrollmentInformationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdateCategoryEnrollmentInformation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdateManagementEnrollment}
 */
// @ts-ignore
export function createUpdateManagementEnrollmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdateManagementEnrollment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatePolicyCollectionResponse}
 */
// @ts-ignore
export function createUpdatePolicyCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdatePolicyCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatePolicy}
 */
// @ts-ignore
export function createUpdatePolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdatePolicy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserExperienceSettings}
 */
// @ts-ignore
export function createUserExperienceSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserExperienceSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WindowsUpdateFilter}
 */
// @ts-ignore
export function createWindowsUpdateFilterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.driverUpdateFilter":
                    return deserializeIntoDriverUpdateFilter;
                case "#microsoft.graph.windowsUpdates.qualityUpdateFilter":
                    return deserializeIntoQualityUpdateFilter;
                case "#microsoft.graph.windowsUpdates.remediationUpdateFilter":
                    return deserializeIntoRemediationUpdateFilter;
            }
        }
    }
    return deserializeIntoWindowsUpdateFilter;
}
export interface CveInformation extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Identifies the number of the CVE. Read-only.
     */
    number?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * URL to the full CVE information. Read-only.
     */
    url?: string | null;
}
export type CveSeverityLevel = (typeof CveSeverityLevelObject)[keyof typeof CveSeverityLevelObject];
export interface DateDrivenRolloutSettings extends GradualRolloutSettings, Parsable {
    /**
     * Specifies the date before which all devices currently in the deployment are offered the update. Devices added after this date are offered immediately. When the endDateTime isn't set, all devices in the deployment are offered content at the same time.
     */
    endDateTime?: Date | null;
}
export interface DeployableContent extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface Deployment extends Entity, Parsable {
    /**
     * Specifies the audience to which content is deployed.
     */
    audience?: DeploymentAudience | null;
    /**
     * Specifies what content to deploy. Cannot be changed. Returned by default.
     */
    content?: DeployableContent | null;
    /**
     * The date and time the deployment was created. Returned by default. Read-only.
     */
    createdDateTime?: Date | null;
    /**
     * The date and time the deployment was last modified. Returned by default. Read-only.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * Settings specified on the specific deployment governing how to deploy content. Returned by default.
     */
    settings?: DeploymentSettings | null;
    /**
     * Execution status of the deployment. Returned by default.
     */
    state?: DeploymentState | null;
}
export interface DeploymentAudience extends Entity, Parsable {
}
export interface DeploymentAudienceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: DeploymentAudience[] | null;
}
export interface DeploymentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Deployment[] | null;
}
export interface DeploymentSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Settings for governing whether content is applicable to a device.
     */
    contentApplicability?: ContentApplicabilitySettings | null;
    /**
     * Settings for governing whether updates should be expedited.
     */
    expedite?: ExpediteSettings | null;
    /**
     * Settings for governing conditions to monitor and automated actions to take.
     */
    monitoring?: MonitoringSettings | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Settings for governing how and when the content is rolled out.
     */
    schedule?: ScheduleSettings | null;
    /**
     * Settings for governing end user update experience.
     */
    userExperience?: UserExperienceSettings | null;
}
export interface DeploymentState extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The effectiveValue property
     */
    effectiveValue?: DeploymentStateValue | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Specifies the reasons the deployment has its state value. Read-only.
     */
    reasons?: DeploymentStateReason[] | null;
    /**
     * The requestedValue property
     */
    requestedValue?: RequestedDeploymentStateValue | null;
}
export interface DeploymentStateReason extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The value property
     */
    value?: DeploymentStateReasonValue | null;
}
export type DeploymentStateReasonValue = (typeof DeploymentStateReasonValueObject)[keyof typeof DeploymentStateReasonValueObject];
export type DeploymentStateValue = (typeof DeploymentStateValueObject)[keyof typeof DeploymentStateValueObject];
/**
 * The deserialization information for the current model
 * @param ApplicableContent The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoApplicableContent(applicableContent: Partial<ApplicableContent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { applicableContent.backingStoreEnabled = true; },
        "catalogEntry": n => { applicableContent.catalogEntry = n.getObjectValue<CatalogEntry>(createCatalogEntryFromDiscriminatorValue); },
        "catalogEntryId": n => { applicableContent.catalogEntryId = n.getStringValue(); },
        "matchedDevices": n => { applicableContent.matchedDevices = n.getCollectionOfObjectValues<ApplicableContentDeviceMatch>(createApplicableContentDeviceMatchFromDiscriminatorValue); },
        "@odata.type": n => { applicableContent.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ApplicableContentCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoApplicableContentCollectionResponse(applicableContentCollectionResponse: Partial<ApplicableContentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(applicableContentCollectionResponse),
        "value": n => { applicableContentCollectionResponse.value = n.getCollectionOfObjectValues<ApplicableContent>(createApplicableContentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ApplicableContentDeviceMatch The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoApplicableContentDeviceMatch(applicableContentDeviceMatch: Partial<ApplicableContentDeviceMatch> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { applicableContentDeviceMatch.backingStoreEnabled = true; },
        "deviceId": n => { applicableContentDeviceMatch.deviceId = n.getStringValue(); },
        "@odata.type": n => { applicableContentDeviceMatch.odataType = n.getStringValue(); },
        "recommendedBy": n => { applicableContentDeviceMatch.recommendedBy = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ApplicableContentDeviceMatchCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoApplicableContentDeviceMatchCollectionResponse(applicableContentDeviceMatchCollectionResponse: Partial<ApplicableContentDeviceMatchCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(applicableContentDeviceMatchCollectionResponse),
        "value": n => { applicableContentDeviceMatchCollectionResponse.value = n.getCollectionOfObjectValues<ApplicableContentDeviceMatch>(createApplicableContentDeviceMatchFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param AzureADDevice The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAzureADDevice(azureADDevice: Partial<AzureADDevice> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUpdatableAsset(azureADDevice),
        "enrollment": n => { azureADDevice.enrollment = n.getObjectValue<UpdateManagementEnrollment>(createUpdateManagementEnrollmentFromDiscriminatorValue); },
        "errors": n => { azureADDevice.errors = n.getCollectionOfObjectValues<UpdatableAssetError>(createUpdatableAssetErrorFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param AzureADDeviceRegistrationError The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAzureADDeviceRegistrationError(azureADDeviceRegistrationError: Partial<AzureADDeviceRegistrationError> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUpdatableAssetError(azureADDeviceRegistrationError),
        "reason": n => { azureADDeviceRegistrationError.reason = n.getEnumValue<AzureADDeviceRegistrationErrorReason>(AzureADDeviceRegistrationErrorReasonObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param BuildVersionDetails The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoBuildVersionDetails(buildVersionDetails: Partial<BuildVersionDetails> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { buildVersionDetails.backingStoreEnabled = true; },
        "buildNumber": n => { buildVersionDetails.buildNumber = n.getNumberValue(); },
        "majorVersion": n => { buildVersionDetails.majorVersion = n.getNumberValue(); },
        "minorVersion": n => { buildVersionDetails.minorVersion = n.getNumberValue(); },
        "@odata.type": n => { buildVersionDetails.odataType = n.getStringValue(); },
        "updateBuildRevision": n => { buildVersionDetails.updateBuildRevision = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Catalog The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCatalog(catalog: Partial<Catalog> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(catalog),
        "entries": n => { catalog.entries = n.getCollectionOfObjectValues<CatalogEntry>(createCatalogEntryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param CatalogContent The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCatalogContent(catalogContent: Partial<CatalogContent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDeployableContent(catalogContent),
        "catalogEntry": n => { catalogContent.catalogEntry = n.getObjectValue<CatalogEntry>(createCatalogEntryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param CatalogEntry The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCatalogEntry(catalogEntry: Partial<CatalogEntry> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(catalogEntry),
        "deployableUntilDateTime": n => { catalogEntry.deployableUntilDateTime = n.getDateValue(); },
        "displayName": n => { catalogEntry.displayName = n.getStringValue(); },
        "releaseDateTime": n => { catalogEntry.releaseDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param CatalogEntryCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCatalogEntryCollectionResponse(catalogEntryCollectionResponse: Partial<CatalogEntryCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(catalogEntryCollectionResponse),
        "value": n => { catalogEntryCollectionResponse.value = n.getCollectionOfObjectValues<CatalogEntry>(createCatalogEntryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ComplianceChange The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoComplianceChange(complianceChange: Partial<ComplianceChange> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(complianceChange),
        "createdDateTime": n => { complianceChange.createdDateTime = n.getDateValue(); },
        "isRevoked": n => { complianceChange.isRevoked = n.getBooleanValue(); },
        "revokedDateTime": n => { complianceChange.revokedDateTime = n.getDateValue(); },
        "updatePolicy": n => { complianceChange.updatePolicy = n.getObjectValue<UpdatePolicy>(createUpdatePolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ComplianceChangeCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoComplianceChangeCollectionResponse(complianceChangeCollectionResponse: Partial<ComplianceChangeCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(complianceChangeCollectionResponse),
        "value": n => { complianceChangeCollectionResponse.value = n.getCollectionOfObjectValues<ComplianceChange>(createComplianceChangeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ComplianceChangeRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoComplianceChangeRule(complianceChangeRule: Partial<ComplianceChangeRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { complianceChangeRule.backingStoreEnabled = true; },
        "createdDateTime": n => { complianceChangeRule.createdDateTime = n.getDateValue(); },
        "lastEvaluatedDateTime": n => { complianceChangeRule.lastEvaluatedDateTime = n.getDateValue(); },
        "lastModifiedDateTime": n => { complianceChangeRule.lastModifiedDateTime = n.getDateValue(); },
        "@odata.type": n => { complianceChangeRule.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ContentApplicabilitySettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoContentApplicabilitySettings(contentApplicabilitySettings: Partial<ContentApplicabilitySettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { contentApplicabilitySettings.backingStoreEnabled = true; },
        "@odata.type": n => { contentApplicabilitySettings.odataType = n.getStringValue(); },
        "offerWhileRecommendedBy": n => { contentApplicabilitySettings.offerWhileRecommendedBy = n.getCollectionOfPrimitiveValues<string>(); },
        "safeguard": n => { contentApplicabilitySettings.safeguard = n.getObjectValue<SafeguardSettings>(createSafeguardSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ContentApproval The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoContentApproval(contentApproval: Partial<ContentApproval> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoComplianceChange(contentApproval),
        "content": n => { contentApproval.content = n.getObjectValue<DeployableContent>(createDeployableContentFromDiscriminatorValue); },
        "deployments": n => { contentApproval.deployments = n.getCollectionOfObjectValues<Deployment>(createDeploymentFromDiscriminatorValue); },
        "deploymentSettings": n => { contentApproval.deploymentSettings = n.getObjectValue<DeploymentSettings>(createDeploymentSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ContentApprovalRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoContentApprovalRule(contentApprovalRule: Partial<ContentApprovalRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoComplianceChangeRule(contentApprovalRule),
        "contentFilter": n => { contentApprovalRule.contentFilter = n.getObjectValue<ContentFilter>(createContentFilterFromDiscriminatorValue); },
        "durationBeforeDeploymentStart": n => { contentApprovalRule.durationBeforeDeploymentStart = n.getDurationValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ContentFilter The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoContentFilter(contentFilter: Partial<ContentFilter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { contentFilter.backingStoreEnabled = true; },
        "@odata.type": n => { contentFilter.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param CveInformation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCveInformation(cveInformation: Partial<CveInformation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { cveInformation.backingStoreEnabled = true; },
        "number": n => { cveInformation.number = n.getStringValue(); },
        "@odata.type": n => { cveInformation.odataType = n.getStringValue(); },
        "url": n => { cveInformation.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DateDrivenRolloutSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDateDrivenRolloutSettings(dateDrivenRolloutSettings: Partial<DateDrivenRolloutSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoGradualRolloutSettings(dateDrivenRolloutSettings),
        "endDateTime": n => { dateDrivenRolloutSettings.endDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DeployableContent The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeployableContent(deployableContent: Partial<DeployableContent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { deployableContent.backingStoreEnabled = true; },
        "@odata.type": n => { deployableContent.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Deployment The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeployment(deployment: Partial<Deployment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(deployment),
        "audience": n => { deployment.audience = n.getObjectValue<DeploymentAudience>(createDeploymentAudienceFromDiscriminatorValue); },
        "content": n => { deployment.content = n.getObjectValue<DeployableContent>(createDeployableContentFromDiscriminatorValue); },
        "createdDateTime": n => { deployment.createdDateTime = n.getDateValue(); },
        "lastModifiedDateTime": n => { deployment.lastModifiedDateTime = n.getDateValue(); },
        "settings": n => { deployment.settings = n.getObjectValue<DeploymentSettings>(createDeploymentSettingsFromDiscriminatorValue); },
        "state": n => { deployment.state = n.getObjectValue<DeploymentState>(createDeploymentStateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param DeploymentAudience The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeploymentAudience(deploymentAudience: Partial<DeploymentAudience> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(deploymentAudience),
    }
}
/**
 * The deserialization information for the current model
 * @param DeploymentAudienceCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeploymentAudienceCollectionResponse(deploymentAudienceCollectionResponse: Partial<DeploymentAudienceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(deploymentAudienceCollectionResponse),
        "value": n => { deploymentAudienceCollectionResponse.value = n.getCollectionOfObjectValues<DeploymentAudience>(createDeploymentAudienceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param DeploymentCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeploymentCollectionResponse(deploymentCollectionResponse: Partial<DeploymentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(deploymentCollectionResponse),
        "value": n => { deploymentCollectionResponse.value = n.getCollectionOfObjectValues<Deployment>(createDeploymentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param DeploymentSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeploymentSettings(deploymentSettings: Partial<DeploymentSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { deploymentSettings.backingStoreEnabled = true; },
        "contentApplicability": n => { deploymentSettings.contentApplicability = n.getObjectValue<ContentApplicabilitySettings>(createContentApplicabilitySettingsFromDiscriminatorValue); },
        "expedite": n => { deploymentSettings.expedite = n.getObjectValue<ExpediteSettings>(createExpediteSettingsFromDiscriminatorValue); },
        "monitoring": n => { deploymentSettings.monitoring = n.getObjectValue<MonitoringSettings>(createMonitoringSettingsFromDiscriminatorValue); },
        "@odata.type": n => { deploymentSettings.odataType = n.getStringValue(); },
        "schedule": n => { deploymentSettings.schedule = n.getObjectValue<ScheduleSettings>(createScheduleSettingsFromDiscriminatorValue); },
        "userExperience": n => { deploymentSettings.userExperience = n.getObjectValue<UserExperienceSettings>(createUserExperienceSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param DeploymentState The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeploymentState(deploymentState: Partial<DeploymentState> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { deploymentState.backingStoreEnabled = true; },
        "effectiveValue": n => { deploymentState.effectiveValue = n.getEnumValue<DeploymentStateValue>(DeploymentStateValueObject); },
        "@odata.type": n => { deploymentState.odataType = n.getStringValue(); },
        "reasons": n => { deploymentState.reasons = n.getCollectionOfObjectValues<DeploymentStateReason>(createDeploymentStateReasonFromDiscriminatorValue); },
        "requestedValue": n => { deploymentState.requestedValue = n.getEnumValue<RequestedDeploymentStateValue>(RequestedDeploymentStateValueObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param DeploymentStateReason The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeploymentStateReason(deploymentStateReason: Partial<DeploymentStateReason> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { deploymentStateReason.backingStoreEnabled = true; },
        "@odata.type": n => { deploymentStateReason.odataType = n.getStringValue(); },
        "value": n => { deploymentStateReason.value = n.getEnumValue<DeploymentStateReasonValue>(DeploymentStateReasonValueObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param DriverUpdateCatalogEntry The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDriverUpdateCatalogEntry(driverUpdateCatalogEntry: Partial<DriverUpdateCatalogEntry> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSoftwareUpdateCatalogEntry(driverUpdateCatalogEntry),
        "description": n => { driverUpdateCatalogEntry.description = n.getStringValue(); },
        "driverClass": n => { driverUpdateCatalogEntry.driverClass = n.getStringValue(); },
        "manufacturer": n => { driverUpdateCatalogEntry.manufacturer = n.getStringValue(); },
        "provider": n => { driverUpdateCatalogEntry.provider = n.getStringValue(); },
        "setupInformationFile": n => { driverUpdateCatalogEntry.setupInformationFile = n.getStringValue(); },
        "version": n => { driverUpdateCatalogEntry.version = n.getStringValue(); },
        "versionDateTime": n => { driverUpdateCatalogEntry.versionDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DriverUpdateFilter The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDriverUpdateFilter(driverUpdateFilter: Partial<DriverUpdateFilter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWindowsUpdateFilter(driverUpdateFilter),
    }
}
/**
 * The deserialization information for the current model
 * @param DurationDrivenRolloutSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDurationDrivenRolloutSettings(durationDrivenRolloutSettings: Partial<DurationDrivenRolloutSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoGradualRolloutSettings(durationDrivenRolloutSettings),
        "durationUntilDeploymentEnd": n => { durationDrivenRolloutSettings.durationUntilDeploymentEnd = n.getDurationValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Edition The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEdition(edition: Partial<Edition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(edition),
        "deviceFamily": n => { edition.deviceFamily = n.getStringValue(); },
        "endOfServiceDateTime": n => { edition.endOfServiceDateTime = n.getDateValue(); },
        "generalAvailabilityDateTime": n => { edition.generalAvailabilityDateTime = n.getDateValue(); },
        "isInService": n => { edition.isInService = n.getBooleanValue(); },
        "name": n => { edition.name = n.getStringValue(); },
        "releasedName": n => { edition.releasedName = n.getStringValue(); },
        "servicingPeriods": n => { edition.servicingPeriods = n.getCollectionOfObjectValues<ServicingPeriod>(createServicingPeriodFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param EditionCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEditionCollectionResponse(editionCollectionResponse: Partial<EditionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(editionCollectionResponse),
        "value": n => { editionCollectionResponse.value = n.getCollectionOfObjectValues<Edition>(createEditionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ExpediteSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExpediteSettings(expediteSettings: Partial<ExpediteSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { expediteSettings.backingStoreEnabled = true; },
        "isExpedited": n => { expediteSettings.isExpedited = n.getBooleanValue(); },
        "isReadinessTest": n => { expediteSettings.isReadinessTest = n.getBooleanValue(); },
        "@odata.type": n => { expediteSettings.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param FeatureUpdateCatalogEntry The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFeatureUpdateCatalogEntry(featureUpdateCatalogEntry: Partial<FeatureUpdateCatalogEntry> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSoftwareUpdateCatalogEntry(featureUpdateCatalogEntry),
        "buildNumber": n => { featureUpdateCatalogEntry.buildNumber = n.getStringValue(); },
        "version": n => { featureUpdateCatalogEntry.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param GradualRolloutSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGradualRolloutSettings(gradualRolloutSettings: Partial<GradualRolloutSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { gradualRolloutSettings.backingStoreEnabled = true; },
        "durationBetweenOffers": n => { gradualRolloutSettings.durationBetweenOffers = n.getDurationValue(); },
        "@odata.type": n => { gradualRolloutSettings.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ItemBody The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoItemBody(itemBody: Partial<ItemBody> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { itemBody.backingStoreEnabled = true; },
        "content": n => { itemBody.content = n.getStringValue(); },
        "contentType": n => { itemBody.contentType = n.getEnumValue<BodyType>(BodyTypeObject); },
        "@odata.type": n => { itemBody.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param KnowledgeBaseArticle The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoKnowledgeBaseArticle(knowledgeBaseArticle: Partial<KnowledgeBaseArticle> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(knowledgeBaseArticle),
    }
}
/**
 * The deserialization information for the current model
 * @param KnownIssue The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoKnownIssue(knownIssue: Partial<KnownIssue> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(knownIssue),
        "description": n => { knownIssue.description = n.getStringValue(); },
        "knownIssueHistories": n => { knownIssue.knownIssueHistories = n.getCollectionOfObjectValues<KnownIssueHistoryItem>(createKnownIssueHistoryItemFromDiscriminatorValue); },
        "lastUpdatedDateTime": n => { knownIssue.lastUpdatedDateTime = n.getDateValue(); },
        "originatingKnowledgeBaseArticle": n => { knownIssue.originatingKnowledgeBaseArticle = n.getObjectValue<KnowledgeBaseArticle>(createKnowledgeBaseArticleFromDiscriminatorValue); },
        "resolvedDateTime": n => { knownIssue.resolvedDateTime = n.getDateValue(); },
        "resolvingKnowledgeBaseArticle": n => { knownIssue.resolvingKnowledgeBaseArticle = n.getObjectValue<KnowledgeBaseArticle>(createKnowledgeBaseArticleFromDiscriminatorValue); },
        "safeguardHoldIds": n => { knownIssue.safeguardHoldIds = n.getCollectionOfPrimitiveValues<number>(); },
        "startDateTime": n => { knownIssue.startDateTime = n.getDateValue(); },
        "status": n => { knownIssue.status = n.getEnumValue<WindowsReleaseHealthStatus>(WindowsReleaseHealthStatusObject); },
        "title": n => { knownIssue.title = n.getStringValue(); },
        "webViewUrl": n => { knownIssue.webViewUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param KnownIssueCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoKnownIssueCollectionResponse(knownIssueCollectionResponse: Partial<KnownIssueCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(knownIssueCollectionResponse),
        "value": n => { knownIssueCollectionResponse.value = n.getCollectionOfObjectValues<KnownIssue>(createKnownIssueFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param KnownIssueHistoryItem The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoKnownIssueHistoryItem(knownIssueHistoryItem: Partial<KnownIssueHistoryItem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { knownIssueHistoryItem.backingStoreEnabled = true; },
        "body": n => { knownIssueHistoryItem.body = n.getObjectValue<ItemBody>(createItemBodyFromDiscriminatorValue); },
        "createdDateTime": n => { knownIssueHistoryItem.createdDateTime = n.getDateValue(); },
        "@odata.type": n => { knownIssueHistoryItem.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param MonitoringRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoMonitoringRule(monitoringRule: Partial<MonitoringRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "action": n => { monitoringRule.action = n.getEnumValue<MonitoringAction>(MonitoringActionObject); },
        "backingStoreEnabled": n => { monitoringRule.backingStoreEnabled = true; },
        "@odata.type": n => { monitoringRule.odataType = n.getStringValue(); },
        "signal": n => { monitoringRule.signal = n.getEnumValue<MonitoringSignal>(MonitoringSignalObject); },
        "threshold": n => { monitoringRule.threshold = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param MonitoringSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoMonitoringSettings(monitoringSettings: Partial<MonitoringSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { monitoringSettings.backingStoreEnabled = true; },
        "monitoringRules": n => { monitoringSettings.monitoringRules = n.getCollectionOfObjectValues<MonitoringRule>(createMonitoringRuleFromDiscriminatorValue); },
        "@odata.type": n => { monitoringSettings.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param OperationalInsightsConnection The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoOperationalInsightsConnection(operationalInsightsConnection: Partial<OperationalInsightsConnection> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResourceConnection(operationalInsightsConnection),
        "azureResourceGroupName": n => { operationalInsightsConnection.azureResourceGroupName = n.getStringValue(); },
        "azureSubscriptionId": n => { operationalInsightsConnection.azureSubscriptionId = n.getStringValue(); },
        "workspaceName": n => { operationalInsightsConnection.workspaceName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Product The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoProduct(product: Partial<Product> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(product),
        "editions": n => { product.editions = n.getCollectionOfObjectValues<Edition>(createEditionFromDiscriminatorValue); },
        "friendlyNames": n => { product.friendlyNames = n.getCollectionOfPrimitiveValues<string>(); },
        "groupName": n => { product.groupName = n.getStringValue(); },
        "knownIssues": n => { product.knownIssues = n.getCollectionOfObjectValues<KnownIssue>(createKnownIssueFromDiscriminatorValue); },
        "name": n => { product.name = n.getStringValue(); },
        "revisions": n => { product.revisions = n.getCollectionOfObjectValues<ProductRevision>(createProductRevisionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ProductCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoProductCollectionResponse(productCollectionResponse: Partial<ProductCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(productCollectionResponse),
        "value": n => { productCollectionResponse.value = n.getCollectionOfObjectValues<Product>(createProductFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ProductRevision The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoProductRevision(productRevision: Partial<ProductRevision> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(productRevision),
        "catalogEntry": n => { productRevision.catalogEntry = n.getObjectValue<CatalogEntry>(createCatalogEntryFromDiscriminatorValue); },
        "displayName": n => { productRevision.displayName = n.getStringValue(); },
        "isHotpatchUpdate": n => { productRevision.isHotpatchUpdate = n.getBooleanValue(); },
        "knowledgeBaseArticle": n => { productRevision.knowledgeBaseArticle = n.getObjectValue<KnowledgeBaseArticle>(createKnowledgeBaseArticleFromDiscriminatorValue); },
        "osBuild": n => { productRevision.osBuild = n.getObjectValue<BuildVersionDetails>(createBuildVersionDetailsFromDiscriminatorValue); },
        "product": n => { productRevision.product = n.getStringValue(); },
        "releaseDateTime": n => { productRevision.releaseDateTime = n.getDateValue(); },
        "version": n => { productRevision.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ProductRevisionCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoProductRevisionCollectionResponse(productRevisionCollectionResponse: Partial<ProductRevisionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(productRevisionCollectionResponse),
        "value": n => { productRevisionCollectionResponse.value = n.getCollectionOfObjectValues<ProductRevision>(createProductRevisionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param QualityUpdateCatalogEntry The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoQualityUpdateCatalogEntry(qualityUpdateCatalogEntry: Partial<QualityUpdateCatalogEntry> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSoftwareUpdateCatalogEntry(qualityUpdateCatalogEntry),
        "catalogName": n => { qualityUpdateCatalogEntry.catalogName = n.getStringValue(); },
        "cveSeverityInformation": n => { qualityUpdateCatalogEntry.cveSeverityInformation = n.getObjectValue<QualityUpdateCveSeverityInformation>(createQualityUpdateCveSeverityInformationFromDiscriminatorValue); },
        "isExpeditable": n => { qualityUpdateCatalogEntry.isExpeditable = n.getBooleanValue(); },
        "productRevisions": n => { qualityUpdateCatalogEntry.productRevisions = n.getCollectionOfObjectValues<ProductRevision>(createProductRevisionFromDiscriminatorValue); },
        "qualityUpdateCadence": n => { qualityUpdateCatalogEntry.qualityUpdateCadence = n.getEnumValue<QualityUpdateCadence>(QualityUpdateCadenceObject); },
        "qualityUpdateClassification": n => { qualityUpdateCatalogEntry.qualityUpdateClassification = n.getEnumValue<QualityUpdateClassification>(QualityUpdateClassificationObject); },
        "shortName": n => { qualityUpdateCatalogEntry.shortName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param QualityUpdateCveSeverityInformation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoQualityUpdateCveSeverityInformation(qualityUpdateCveSeverityInformation: Partial<QualityUpdateCveSeverityInformation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { qualityUpdateCveSeverityInformation.backingStoreEnabled = true; },
        "exploitedCves": n => { qualityUpdateCveSeverityInformation.exploitedCves = n.getCollectionOfObjectValues<CveInformation>(createCveInformationFromDiscriminatorValue); },
        "maxBaseScore": n => { qualityUpdateCveSeverityInformation.maxBaseScore = n.getNumberValue(); },
        "maxSeverity": n => { qualityUpdateCveSeverityInformation.maxSeverity = n.getEnumValue<CveSeverityLevel>(CveSeverityLevelObject); },
        "@odata.type": n => { qualityUpdateCveSeverityInformation.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param QualityUpdateFilter The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoQualityUpdateFilter(qualityUpdateFilter: Partial<QualityUpdateFilter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWindowsUpdateFilter(qualityUpdateFilter),
        "cadence": n => { qualityUpdateFilter.cadence = n.getEnumValue<QualityUpdateCadence>(QualityUpdateCadenceObject); },
        "classification": n => { qualityUpdateFilter.classification = n.getEnumValue<QualityUpdateClassification>(QualityUpdateClassificationObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param RateDrivenRolloutSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRateDrivenRolloutSettings(rateDrivenRolloutSettings: Partial<RateDrivenRolloutSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoGradualRolloutSettings(rateDrivenRolloutSettings),
        "devicesPerOffer": n => { rateDrivenRolloutSettings.devicesPerOffer = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RemediationUpdateFilter The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRemediationUpdateFilter(remediationUpdateFilter: Partial<RemediationUpdateFilter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWindowsUpdateFilter(remediationUpdateFilter),
        "remediationType": n => { remediationUpdateFilter.remediationType = n.getEnumValue<RemediationType>(RemediationTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param ResourceConnection The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoResourceConnection(resourceConnection: Partial<ResourceConnection> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(resourceConnection),
        "state": n => { resourceConnection.state = n.getEnumValue<ResourceConnectionState>(ResourceConnectionStateObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param ResourceConnectionCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoResourceConnectionCollectionResponse(resourceConnectionCollectionResponse: Partial<ResourceConnectionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(resourceConnectionCollectionResponse),
        "value": n => { resourceConnectionCollectionResponse.value = n.getCollectionOfObjectValues<ResourceConnection>(createResourceConnectionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param SafeguardProfile The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSafeguardProfile(safeguardProfile: Partial<SafeguardProfile> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { safeguardProfile.backingStoreEnabled = true; },
        "category": n => { safeguardProfile.category = n.getEnumValue<SafeguardCategory>(SafeguardCategoryObject); },
        "@odata.type": n => { safeguardProfile.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param SafeguardSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSafeguardSettings(safeguardSettings: Partial<SafeguardSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { safeguardSettings.backingStoreEnabled = true; },
        "disabledSafeguardProfiles": n => { safeguardSettings.disabledSafeguardProfiles = n.getCollectionOfObjectValues<SafeguardProfile>(createSafeguardProfileFromDiscriminatorValue); },
        "@odata.type": n => { safeguardSettings.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ScheduleSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoScheduleSettings(scheduleSettings: Partial<ScheduleSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { scheduleSettings.backingStoreEnabled = true; },
        "gradualRollout": n => { scheduleSettings.gradualRollout = n.getObjectValue<GradualRolloutSettings>(createGradualRolloutSettingsFromDiscriminatorValue); },
        "@odata.type": n => { scheduleSettings.odataType = n.getStringValue(); },
        "startDateTime": n => { scheduleSettings.startDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ServicingPeriod The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoServicingPeriod(servicingPeriod: Partial<ServicingPeriod> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { servicingPeriod.backingStoreEnabled = true; },
        "endDateTime": n => { servicingPeriod.endDateTime = n.getDateValue(); },
        "name": n => { servicingPeriod.name = n.getStringValue(); },
        "@odata.type": n => { servicingPeriod.odataType = n.getStringValue(); },
        "startDateTime": n => { servicingPeriod.startDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param SoftwareUpdateCatalogEntry The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSoftwareUpdateCatalogEntry(softwareUpdateCatalogEntry: Partial<SoftwareUpdateCatalogEntry> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCatalogEntry(softwareUpdateCatalogEntry),
    }
}
/**
 * The deserialization information for the current model
 * @param SoftwareUpdateFilter The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSoftwareUpdateFilter(softwareUpdateFilter: Partial<SoftwareUpdateFilter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoContentFilter(softwareUpdateFilter),
    }
}
/**
 * The deserialization information for the current model
 * @param UpdatableAsset The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUpdatableAsset(updatableAsset: Partial<UpdatableAsset> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(updatableAsset),
    }
}
/**
 * The deserialization information for the current model
 * @param UpdatableAssetCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUpdatableAssetCollectionResponse(updatableAssetCollectionResponse: Partial<UpdatableAssetCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(updatableAssetCollectionResponse),
        "value": n => { updatableAssetCollectionResponse.value = n.getCollectionOfObjectValues<UpdatableAsset>(createUpdatableAssetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param UpdatableAssetError The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUpdatableAssetError(updatableAssetError: Partial<UpdatableAssetError> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { updatableAssetError.backingStoreEnabled = true; },
        "@odata.type": n => { updatableAssetError.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UpdatableAssetGroup The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUpdatableAssetGroup(updatableAssetGroup: Partial<UpdatableAssetGroup> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUpdatableAsset(updatableAssetGroup),
        "members": n => { updatableAssetGroup.members = n.getCollectionOfObjectValues<UpdatableAsset>(createUpdatableAssetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param UpdateCategoryEnrollmentInformation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUpdateCategoryEnrollmentInformation(updateCategoryEnrollmentInformation: Partial<UpdateCategoryEnrollmentInformation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { updateCategoryEnrollmentInformation.backingStoreEnabled = true; },
        "enrollmentState": n => { updateCategoryEnrollmentInformation.enrollmentState = n.getEnumValue<EnrollmentState>(EnrollmentStateObject); },
        "lastModifiedDateTime": n => { updateCategoryEnrollmentInformation.lastModifiedDateTime = n.getDateValue(); },
        "@odata.type": n => { updateCategoryEnrollmentInformation.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UpdateManagementEnrollment The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUpdateManagementEnrollment(updateManagementEnrollment: Partial<UpdateManagementEnrollment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { updateManagementEnrollment.backingStoreEnabled = true; },
        "driver": n => { updateManagementEnrollment.driver = n.getObjectValue<UpdateCategoryEnrollmentInformation>(createUpdateCategoryEnrollmentInformationFromDiscriminatorValue); },
        "feature": n => { updateManagementEnrollment.feature = n.getObjectValue<UpdateCategoryEnrollmentInformation>(createUpdateCategoryEnrollmentInformationFromDiscriminatorValue); },
        "@odata.type": n => { updateManagementEnrollment.odataType = n.getStringValue(); },
        "quality": n => { updateManagementEnrollment.quality = n.getObjectValue<UpdateCategoryEnrollmentInformation>(createUpdateCategoryEnrollmentInformationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param UpdatePolicy The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUpdatePolicy(updatePolicy: Partial<UpdatePolicy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(updatePolicy),
        "audience": n => { updatePolicy.audience = n.getObjectValue<DeploymentAudience>(createDeploymentAudienceFromDiscriminatorValue); },
        "complianceChangeRules": n => { updatePolicy.complianceChangeRules = n.getCollectionOfObjectValues<ComplianceChangeRule>(createComplianceChangeRuleFromDiscriminatorValue); },
        "complianceChanges": n => { updatePolicy.complianceChanges = n.getCollectionOfObjectValues<ComplianceChange>(createComplianceChangeFromDiscriminatorValue); },
        "createdDateTime": n => { updatePolicy.createdDateTime = n.getDateValue(); },
        "deploymentSettings": n => { updatePolicy.deploymentSettings = n.getObjectValue<DeploymentSettings>(createDeploymentSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param UpdatePolicyCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUpdatePolicyCollectionResponse(updatePolicyCollectionResponse: Partial<UpdatePolicyCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(updatePolicyCollectionResponse),
        "value": n => { updatePolicyCollectionResponse.value = n.getCollectionOfObjectValues<UpdatePolicy>(createUpdatePolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param UserExperienceSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUserExperienceSettings(userExperienceSettings: Partial<UserExperienceSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { userExperienceSettings.backingStoreEnabled = true; },
        "daysUntilForcedReboot": n => { userExperienceSettings.daysUntilForcedReboot = n.getNumberValue(); },
        "isHotpatchEnabled": n => { userExperienceSettings.isHotpatchEnabled = n.getBooleanValue(); },
        "@odata.type": n => { userExperienceSettings.odataType = n.getStringValue(); },
        "offerAsOptional": n => { userExperienceSettings.offerAsOptional = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param WindowsUpdateFilter The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWindowsUpdateFilter(windowsUpdateFilter: Partial<WindowsUpdateFilter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSoftwareUpdateFilter(windowsUpdateFilter),
    }
}
export interface DriverUpdateCatalogEntry extends Parsable, SoftwareUpdateCatalogEntry {
    /**
     * The description of the content.
     */
    description?: string | null;
    /**
     * The classification of the driver.
     */
    driverClass?: string | null;
    /**
     * The manufacturer of the driver.
     */
    manufacturer?: string | null;
    /**
     * The provider of the driver.
     */
    provider?: string | null;
    /**
     * The setup information file of the driver.
     */
    setupInformationFile?: string | null;
    /**
     * The unique version of the content.
     */
    version?: string | null;
    /**
     * The date and time when a new version of content was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    versionDateTime?: Date | null;
}
export interface DriverUpdateFilter extends Parsable, WindowsUpdateFilter {
}
export interface DurationDrivenRolloutSettings extends GradualRolloutSettings, Parsable {
    /**
     * The target duration of the rollout. Given durationBetweenOffers and durationUntilDeploymentEnd, the system will automatically calculate how many devices are in each offering.
     */
    durationUntilDeploymentEnd?: Duration | null;
}
export interface Edition extends Entity, Parsable {
    /**
     * The device family targeted by the edition.
     */
    deviceFamily?: string | null;
    /**
     * The date and time when the edition reached the end of service. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    endOfServiceDateTime?: Date | null;
    /**
     * The date and time when the edition became available to the general customers for the first time. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    generalAvailabilityDateTime?: Date | null;
    /**
     * Indicates whether the edition is in service or out of service.
     */
    isInService?: boolean | null;
    /**
     * The name of the edition. Read-only.
     */
    name?: string | null;
    /**
     * The public name of the edition. Read-only.
     */
    releasedName?: string | null;
    /**
     * The servicingPeriods property
     */
    servicingPeriods?: ServicingPeriod[] | null;
}
export interface EditionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Edition[] | null;
}
export type EnrollmentState = (typeof EnrollmentStateObject)[keyof typeof EnrollmentStateObject];
export interface ExpediteSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * True indicates that the deployment of the content is expedited.
     */
    isExpedited?: boolean | null;
    /**
     * True indicates that the deployment is an expedite readiness test.
     */
    isReadinessTest?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface FeatureUpdateCatalogEntry extends Parsable, SoftwareUpdateCatalogEntry {
    /**
     * The build number of the feature update. Read-only.
     */
    buildNumber?: string | null;
    /**
     * The version of the feature update. Read-only.
     */
    version?: string | null;
}
export interface GradualRolloutSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The duration between each set of devices being offered the update. The value is represented in ISO 8601 format for duration. Default value is P1D (one day).
     */
    durationBetweenOffers?: Duration | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface ItemBody extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The content of the item.
     */
    content?: string | null;
    /**
     * The type of the content indicated by the enum value of bodyType. Possible values are: text, html, unknownFutureValue.
     */
    contentType?: BodyType | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface KnowledgeBaseArticle extends Entity, Parsable {
}
export interface KnownIssue extends Entity, Parsable {
    /**
     * The description of the particular known issue.
     */
    description?: string | null;
    /**
     * The knownIssueHistories property
     */
    knownIssueHistories?: KnownIssueHistoryItem[] | null;
    /**
     * The date and time when the known issue was last updated. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    lastUpdatedDateTime?: Date | null;
    /**
     * Knowledge base article associated with the release when the known issue was first reported.
     */
    originatingKnowledgeBaseArticle?: KnowledgeBaseArticle | null;
    /**
     * The date and time when the known issue was resolved or mitigated. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    resolvedDateTime?: Date | null;
    /**
     * Knowledge base article associated with the release when the known issue was resolved or mitigated.
     */
    resolvingKnowledgeBaseArticle?: KnowledgeBaseArticle | null;
    /**
     * The safeguardHoldIds property
     */
    safeguardHoldIds?: number[] | null;
    /**
     * The date and time when the known issue was first reported. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    startDateTime?: Date | null;
    /**
     * The status property
     */
    status?: WindowsReleaseHealthStatus | null;
    /**
     * The title of the known issue.
     */
    title?: string | null;
    /**
     * The URL to the known issue in the Windows Release Health dashboard on Microsoft 365 admin center.
     */
    webViewUrl?: string | null;
}
export interface KnownIssueCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: KnownIssue[] | null;
}
export interface KnownIssueHistoryItem extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The body property
     */
    body?: ItemBody | null;
    /**
     * The date and time when the post was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    createdDateTime?: Date | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export type MonitoringAction = (typeof MonitoringActionObject)[keyof typeof MonitoringActionObject];
export interface MonitoringRule extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The action triggered when the threshold for the given signal is reached. Possible values are: alertError, pauseDeployment, offerFallback, unknownFutureValue. The offerFallback member is only supported on feature update deployments of Windows 11 and must be paired with the ineligible signal. The fallback version offered is the version 22H2 of Windows 10.
     */
    action?: MonitoringAction | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The signal to monitor. Possible values are: rollback, ineligible, unknownFutureValue. The ineligible member is only supported on feature update deployments of Windows 11 and must be paired with the offerFallback action.
     */
    signal?: MonitoringSignal | null;
    /**
     * The threshold for a signal at which to trigger the action. An integer from 1 to 100 (inclusive). This value is ignored when the signal is ineligible and the action is offerFallback.
     */
    threshold?: number | null;
}
export interface MonitoringSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Specifies the rules through which monitoring signals can trigger actions on the deployment. Rules are combined using 'or.'
     */
    monitoringRules?: MonitoringRule[] | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export type MonitoringSignal = (typeof MonitoringSignalObject)[keyof typeof MonitoringSignalObject];
export interface OperationalInsightsConnection extends Parsable, ResourceConnection {
    /**
     * The name of the Azure resource group that contains the Log Analytics workspace.
     */
    azureResourceGroupName?: string | null;
    /**
     * The Azure subscription ID that contains the Log Analytics workspace.
     */
    azureSubscriptionId?: string | null;
    /**
     * The name of the Log Analytics workspace.
     */
    workspaceName?: string | null;
}
export interface Product extends Entity, Parsable {
    /**
     * Represents an edition of a particular Windows product.
     */
    editions?: Edition[] | null;
    /**
     * The friendly names of the product. For example, Version 22H2 (OS build 22621). Read-only.
     */
    friendlyNames?: string[] | null;
    /**
     * The name of the product group. For example, Windows 11. Read-only.
     */
    groupName?: string | null;
    /**
     * Represents a known issue related to a Windows product.
     */
    knownIssues?: KnownIssue[] | null;
    /**
     * The name of the product. For example, Windows 11, version 22H2. Read-only.
     */
    name?: string | null;
    /**
     * Represents a product revision.
     */
    revisions?: ProductRevision[] | null;
}
export interface ProductCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Product[] | null;
}
export interface ProductRevision extends Entity, Parsable {
    /**
     * The catalogEntry property
     */
    catalogEntry?: CatalogEntry | null;
    /**
     * The display name of the content. Read-only.
     */
    displayName?: string | null;
    /**
     * True indicates that the content is hotpatchable; otherwise, false. For more information, see Deploy a hotpatch quality update using Windows Autopatch. Read-only.
     */
    isHotpatchUpdate?: boolean | null;
    /**
     * The knowledge base article associated with the product revision.
     */
    knowledgeBaseArticle?: KnowledgeBaseArticle | null;
    /**
     * The osBuild property
     */
    osBuild?: BuildVersionDetails | null;
    /**
     * The product of the revision. Possible values are: Windows 10, Windows 11. Read-only.
     */
    product?: string | null;
    /**
     * The release date for the content. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    releaseDateTime?: Date | null;
    /**
     * The version of the feature update. Read-only.
     */
    version?: string | null;
}
export interface ProductRevisionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ProductRevision[] | null;
}
export type QualityUpdateCadence = (typeof QualityUpdateCadenceObject)[keyof typeof QualityUpdateCadenceObject];
export interface QualityUpdateCatalogEntry extends Parsable, SoftwareUpdateCatalogEntry {
    /**
     * The catalog name of the content. Read-only.
     */
    catalogName?: string | null;
    /**
     * Severity information of the Common Vulnerabilities and Exposures associated with the content.
     */
    cveSeverityInformation?: QualityUpdateCveSeverityInformation | null;
    /**
     * Indicates whether the content can be deployed as an expedited quality update. Read-only.
     */
    isExpeditable?: boolean | null;
    /**
     * The operating system product revisions that are released as part of this quality update.
     */
    productRevisions?: ProductRevision[] | null;
    /**
     * The publishing cadence of the quality update. Possible values are: monthly, outOfBand, unknownFutureValue. Read-only.
     */
    qualityUpdateCadence?: QualityUpdateCadence | null;
    /**
     * The qualityUpdateClassification property
     */
    qualityUpdateClassification?: QualityUpdateClassification | null;
    /**
     * The short name of the content. Read-only.
     */
    shortName?: string | null;
}
export type QualityUpdateClassification = (typeof QualityUpdateClassificationObject)[keyof typeof QualityUpdateClassificationObject];
export interface QualityUpdateCveSeverityInformation extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The exploitedCves property
     */
    exploitedCves?: CveInformation[] | null;
    /**
     * Highest base score that occurs of any CVE addressed by the quality update. Read-only.
     */
    maxBaseScore?: number | null;
    /**
     * The maxSeverity property
     */
    maxSeverity?: CveSeverityLevel | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface QualityUpdateFilter extends Parsable, WindowsUpdateFilter {
    /**
     * Specifies the cadence for publishing quality updates of the filter. The possible values are: monthly, outOfBand, unknownFutureValue.
     */
    cadence?: QualityUpdateCadence | null;
    /**
     * Specifies the quality update classification of the filter. The possible values are: all, security, nonSecurity, unknownFutureValue.
     */
    classification?: QualityUpdateClassification | null;
}
export interface RateDrivenRolloutSettings extends GradualRolloutSettings, Parsable {
    /**
     * Specifies the number of devices that are offered at the same time. When not set, all devices in the deployment are offered content at the same time.
     */
    devicesPerOffer?: number | null;
}
export type RemediationType = (typeof RemediationTypeObject)[keyof typeof RemediationTypeObject];
export interface RemediationUpdateFilter extends Parsable, WindowsUpdateFilter {
    /**
     * The remediationType property
     */
    remediationType?: RemediationType | null;
}
export type RequestedDeploymentStateValue = (typeof RequestedDeploymentStateValueObject)[keyof typeof RequestedDeploymentStateValueObject];
export interface ResourceConnection extends Entity, Parsable {
    /**
     * The state of the connection. The possible values are: connected, notAuthorized, notFound, unknownFutureValue.
     */
    state?: ResourceConnectionState | null;
}
export interface ResourceConnectionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ResourceConnection[] | null;
}
export type ResourceConnectionState = (typeof ResourceConnectionStateObject)[keyof typeof ResourceConnectionStateObject];
export type SafeguardCategory = (typeof SafeguardCategoryObject)[keyof typeof SafeguardCategoryObject];
export interface SafeguardProfile extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Specifies the category of safeguards. The possible values are: likelyIssues, unknownFutureValue.
     */
    category?: SafeguardCategory | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface SafeguardSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * List of safeguards to ignore per device.
     */
    disabledSafeguardProfiles?: SafeguardProfile[] | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface ScheduleSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Settings for governing how to rollout content to devices. One of: microsoft.graph.windowsUpdates.dateDrivenRolloutSettings, microsoft.graph.windowsUpdates.durationDrivenRolloutSettings, or microsoft.graph.windowsUpdates.rateDrivenRolloutSettings.
     */
    gradualRollout?: GradualRolloutSettings | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The date on which devices in the deployment start receiving the update. When not set, the deployment starts as soon as devices are assigned. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    startDateTime?: Date | null;
}
/**
 * Serializes information the current object
 * @param ApplicableContent The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeApplicableContent(writer: SerializationWriter, applicableContent: Partial<ApplicableContent> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!applicableContent || isSerializingDerivedType) { return; }
    writer.writeObjectValue<CatalogEntry>("catalogEntry", applicableContent.catalogEntry, serializeCatalogEntry);
    writer.writeStringValue("catalogEntryId", applicableContent.catalogEntryId);
    writer.writeCollectionOfObjectValues<ApplicableContentDeviceMatch>("matchedDevices", applicableContent.matchedDevices, serializeApplicableContentDeviceMatch);
    writer.writeStringValue("@odata.type", applicableContent.odataType);
    writer.writeAdditionalData(applicableContent.additionalData);
}
/**
 * Serializes information the current object
 * @param ApplicableContentCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeApplicableContentCollectionResponse(writer: SerializationWriter, applicableContentCollectionResponse: Partial<ApplicableContentCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!applicableContentCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, applicableContentCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ApplicableContent>("value", applicableContentCollectionResponse.value, serializeApplicableContent);
}
/**
 * Serializes information the current object
 * @param ApplicableContentDeviceMatch The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeApplicableContentDeviceMatch(writer: SerializationWriter, applicableContentDeviceMatch: Partial<ApplicableContentDeviceMatch> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!applicableContentDeviceMatch || isSerializingDerivedType) { return; }
    writer.writeStringValue("deviceId", applicableContentDeviceMatch.deviceId);
    writer.writeStringValue("@odata.type", applicableContentDeviceMatch.odataType);
    writer.writeCollectionOfPrimitiveValues<string>("recommendedBy", applicableContentDeviceMatch.recommendedBy);
    writer.writeAdditionalData(applicableContentDeviceMatch.additionalData);
}
/**
 * Serializes information the current object
 * @param ApplicableContentDeviceMatchCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeApplicableContentDeviceMatchCollectionResponse(writer: SerializationWriter, applicableContentDeviceMatchCollectionResponse: Partial<ApplicableContentDeviceMatchCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!applicableContentDeviceMatchCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, applicableContentDeviceMatchCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ApplicableContentDeviceMatch>("value", applicableContentDeviceMatchCollectionResponse.value, serializeApplicableContentDeviceMatch);
}
/**
 * Serializes information the current object
 * @param AzureADDevice The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAzureADDevice(writer: SerializationWriter, azureADDevice: Partial<AzureADDevice> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!azureADDevice || isSerializingDerivedType) { return; }
    serializeUpdatableAsset(writer, azureADDevice, isSerializingDerivedType)
    writer.writeObjectValue<UpdateManagementEnrollment>("enrollment", azureADDevice.enrollment, serializeUpdateManagementEnrollment);
    writer.writeCollectionOfObjectValues<UpdatableAssetError>("errors", azureADDevice.errors, serializeUpdatableAssetError);
}
/**
 * Serializes information the current object
 * @param AzureADDeviceRegistrationError The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAzureADDeviceRegistrationError(writer: SerializationWriter, azureADDeviceRegistrationError: Partial<AzureADDeviceRegistrationError> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!azureADDeviceRegistrationError || isSerializingDerivedType) { return; }
    serializeUpdatableAssetError(writer, azureADDeviceRegistrationError, isSerializingDerivedType)
    writer.writeEnumValue<AzureADDeviceRegistrationErrorReason>("reason", azureADDeviceRegistrationError.reason);
}
/**
 * Serializes information the current object
 * @param BuildVersionDetails The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeBuildVersionDetails(writer: SerializationWriter, buildVersionDetails: Partial<BuildVersionDetails> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!buildVersionDetails || isSerializingDerivedType) { return; }
    writer.writeNumberValue("buildNumber", buildVersionDetails.buildNumber);
    writer.writeNumberValue("majorVersion", buildVersionDetails.majorVersion);
    writer.writeNumberValue("minorVersion", buildVersionDetails.minorVersion);
    writer.writeStringValue("@odata.type", buildVersionDetails.odataType);
    writer.writeNumberValue("updateBuildRevision", buildVersionDetails.updateBuildRevision);
    writer.writeAdditionalData(buildVersionDetails.additionalData);
}
/**
 * Serializes information the current object
 * @param Catalog The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCatalog(writer: SerializationWriter, catalog: Partial<Catalog> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!catalog || isSerializingDerivedType) { return; }
    serializeEntity(writer, catalog, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<CatalogEntry>("entries", catalog.entries, serializeCatalogEntry);
}
/**
 * Serializes information the current object
 * @param CatalogContent The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCatalogContent(writer: SerializationWriter, catalogContent: Partial<CatalogContent> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!catalogContent || isSerializingDerivedType) { return; }
    serializeDeployableContent(writer, catalogContent, isSerializingDerivedType)
    writer.writeObjectValue<CatalogEntry>("catalogEntry", catalogContent.catalogEntry, serializeCatalogEntry);
}
/**
 * Serializes information the current object
 * @param CatalogEntry The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCatalogEntry(writer: SerializationWriter, catalogEntry: Partial<CatalogEntry> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!catalogEntry || isSerializingDerivedType) { return; }
    serializeEntity(writer, catalogEntry, isSerializingDerivedType)
    writer.writeDateValue("deployableUntilDateTime", catalogEntry.deployableUntilDateTime);
    writer.writeStringValue("displayName", catalogEntry.displayName);
    writer.writeDateValue("releaseDateTime", catalogEntry.releaseDateTime);
    switch (catalogEntry.odataType) {
        case "#microsoft.graph.windowsUpdates.driverUpdateCatalogEntry":
            serializeDriverUpdateCatalogEntry(writer, catalogEntry, true);
        break;
        case "#microsoft.graph.windowsUpdates.featureUpdateCatalogEntry":
            serializeFeatureUpdateCatalogEntry(writer, catalogEntry, true);
        break;
        case "#microsoft.graph.windowsUpdates.qualityUpdateCatalogEntry":
            serializeQualityUpdateCatalogEntry(writer, catalogEntry, true);
        break;
        case "#microsoft.graph.windowsUpdates.softwareUpdateCatalogEntry":
            serializeSoftwareUpdateCatalogEntry(writer, catalogEntry, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param CatalogEntryCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCatalogEntryCollectionResponse(writer: SerializationWriter, catalogEntryCollectionResponse: Partial<CatalogEntryCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!catalogEntryCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, catalogEntryCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<CatalogEntry>("value", catalogEntryCollectionResponse.value, serializeCatalogEntry);
}
/**
 * Serializes information the current object
 * @param ComplianceChange The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeComplianceChange(writer: SerializationWriter, complianceChange: Partial<ComplianceChange> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!complianceChange || isSerializingDerivedType) { return; }
    serializeEntity(writer, complianceChange, isSerializingDerivedType)
    writer.writeDateValue("createdDateTime", complianceChange.createdDateTime);
    writer.writeBooleanValue("isRevoked", complianceChange.isRevoked);
    writer.writeDateValue("revokedDateTime", complianceChange.revokedDateTime);
    writer.writeObjectValue<UpdatePolicy>("updatePolicy", complianceChange.updatePolicy, serializeUpdatePolicy);
    switch (complianceChange.odataType) {
        case "#microsoft.graph.windowsUpdates.contentApproval":
            serializeContentApproval(writer, complianceChange, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param ComplianceChangeCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeComplianceChangeCollectionResponse(writer: SerializationWriter, complianceChangeCollectionResponse: Partial<ComplianceChangeCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!complianceChangeCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, complianceChangeCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ComplianceChange>("value", complianceChangeCollectionResponse.value, serializeComplianceChange);
}
/**
 * Serializes information the current object
 * @param ComplianceChangeRule The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeComplianceChangeRule(writer: SerializationWriter, complianceChangeRule: Partial<ComplianceChangeRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!complianceChangeRule || isSerializingDerivedType) { return; }
    writer.writeDateValue("createdDateTime", complianceChangeRule.createdDateTime);
    writer.writeDateValue("lastEvaluatedDateTime", complianceChangeRule.lastEvaluatedDateTime);
    writer.writeDateValue("lastModifiedDateTime", complianceChangeRule.lastModifiedDateTime);
    writer.writeStringValue("@odata.type", complianceChangeRule.odataType);
    writer.writeAdditionalData(complianceChangeRule.additionalData);
    switch (complianceChangeRule.odataType) {
        case "#microsoft.graph.windowsUpdates.contentApprovalRule":
            serializeContentApprovalRule(writer, complianceChangeRule, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param ContentApplicabilitySettings The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeContentApplicabilitySettings(writer: SerializationWriter, contentApplicabilitySettings: Partial<ContentApplicabilitySettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!contentApplicabilitySettings || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", contentApplicabilitySettings.odataType);
    writer.writeCollectionOfPrimitiveValues<string>("offerWhileRecommendedBy", contentApplicabilitySettings.offerWhileRecommendedBy);
    writer.writeObjectValue<SafeguardSettings>("safeguard", contentApplicabilitySettings.safeguard, serializeSafeguardSettings);
    writer.writeAdditionalData(contentApplicabilitySettings.additionalData);
}
/**
 * Serializes information the current object
 * @param ContentApproval The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeContentApproval(writer: SerializationWriter, contentApproval: Partial<ContentApproval> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!contentApproval || isSerializingDerivedType) { return; }
    serializeComplianceChange(writer, contentApproval, isSerializingDerivedType)
    writer.writeObjectValue<DeployableContent>("content", contentApproval.content, serializeDeployableContent);
    writer.writeCollectionOfObjectValues<Deployment>("deployments", contentApproval.deployments, serializeDeployment);
    writer.writeObjectValue<DeploymentSettings>("deploymentSettings", contentApproval.deploymentSettings, serializeDeploymentSettings);
}
/**
 * Serializes information the current object
 * @param ContentApprovalRule The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeContentApprovalRule(writer: SerializationWriter, contentApprovalRule: Partial<ContentApprovalRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!contentApprovalRule || isSerializingDerivedType) { return; }
    serializeComplianceChangeRule(writer, contentApprovalRule, isSerializingDerivedType)
    writer.writeObjectValue<ContentFilter>("contentFilter", contentApprovalRule.contentFilter, serializeContentFilter);
    writer.writeDurationValue("durationBeforeDeploymentStart", contentApprovalRule.durationBeforeDeploymentStart);
}
/**
 * Serializes information the current object
 * @param ContentFilter The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeContentFilter(writer: SerializationWriter, contentFilter: Partial<ContentFilter> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!contentFilter || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", contentFilter.odataType);
    writer.writeAdditionalData(contentFilter.additionalData);
    switch (contentFilter.odataType) {
        case "#microsoft.graph.windowsUpdates.driverUpdateFilter":
            serializeDriverUpdateFilter(writer, contentFilter, true);
        break;
        case "#microsoft.graph.windowsUpdates.qualityUpdateFilter":
            serializeQualityUpdateFilter(writer, contentFilter, true);
        break;
        case "#microsoft.graph.windowsUpdates.remediationUpdateFilter":
            serializeRemediationUpdateFilter(writer, contentFilter, true);
        break;
        case "#microsoft.graph.windowsUpdates.softwareUpdateFilter":
            serializeSoftwareUpdateFilter(writer, contentFilter, true);
        break;
        case "#microsoft.graph.windowsUpdates.windowsUpdateFilter":
            serializeWindowsUpdateFilter(writer, contentFilter, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param CveInformation The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCveInformation(writer: SerializationWriter, cveInformation: Partial<CveInformation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!cveInformation || isSerializingDerivedType) { return; }
    writer.writeStringValue("number", cveInformation.number);
    writer.writeStringValue("@odata.type", cveInformation.odataType);
    writer.writeStringValue("url", cveInformation.url);
    writer.writeAdditionalData(cveInformation.additionalData);
}
/**
 * Serializes information the current object
 * @param DateDrivenRolloutSettings The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDateDrivenRolloutSettings(writer: SerializationWriter, dateDrivenRolloutSettings: Partial<DateDrivenRolloutSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!dateDrivenRolloutSettings || isSerializingDerivedType) { return; }
    serializeGradualRolloutSettings(writer, dateDrivenRolloutSettings, isSerializingDerivedType)
    writer.writeDateValue("endDateTime", dateDrivenRolloutSettings.endDateTime);
}
/**
 * Serializes information the current object
 * @param DeployableContent The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeployableContent(writer: SerializationWriter, deployableContent: Partial<DeployableContent> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deployableContent || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", deployableContent.odataType);
    writer.writeAdditionalData(deployableContent.additionalData);
    switch (deployableContent.odataType) {
        case "#microsoft.graph.windowsUpdates.catalogContent":
            serializeCatalogContent(writer, deployableContent, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param Deployment The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeployment(writer: SerializationWriter, deployment: Partial<Deployment> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deployment || isSerializingDerivedType) { return; }
    serializeEntity(writer, deployment, isSerializingDerivedType)
    writer.writeObjectValue<DeploymentAudience>("audience", deployment.audience, serializeDeploymentAudience);
    writer.writeObjectValue<DeployableContent>("content", deployment.content, serializeDeployableContent);
    writer.writeDateValue("createdDateTime", deployment.createdDateTime);
    writer.writeDateValue("lastModifiedDateTime", deployment.lastModifiedDateTime);
    writer.writeObjectValue<DeploymentSettings>("settings", deployment.settings, serializeDeploymentSettings);
    writer.writeObjectValue<DeploymentState>("state", deployment.state, serializeDeploymentState);
}
/**
 * Serializes information the current object
 * @param DeploymentAudience The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeploymentAudience(writer: SerializationWriter, deploymentAudience: Partial<DeploymentAudience> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deploymentAudience || isSerializingDerivedType) { return; }
    serializeEntity(writer, deploymentAudience, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param DeploymentAudienceCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeploymentAudienceCollectionResponse(writer: SerializationWriter, deploymentAudienceCollectionResponse: Partial<DeploymentAudienceCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deploymentAudienceCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, deploymentAudienceCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<DeploymentAudience>("value", deploymentAudienceCollectionResponse.value, serializeDeploymentAudience);
}
/**
 * Serializes information the current object
 * @param DeploymentCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeploymentCollectionResponse(writer: SerializationWriter, deploymentCollectionResponse: Partial<DeploymentCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deploymentCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, deploymentCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Deployment>("value", deploymentCollectionResponse.value, serializeDeployment);
}
/**
 * Serializes information the current object
 * @param DeploymentSettings The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeploymentSettings(writer: SerializationWriter, deploymentSettings: Partial<DeploymentSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deploymentSettings || isSerializingDerivedType) { return; }
    writer.writeObjectValue<ContentApplicabilitySettings>("contentApplicability", deploymentSettings.contentApplicability, serializeContentApplicabilitySettings);
    writer.writeObjectValue<ExpediteSettings>("expedite", deploymentSettings.expedite, serializeExpediteSettings);
    writer.writeObjectValue<MonitoringSettings>("monitoring", deploymentSettings.monitoring, serializeMonitoringSettings);
    writer.writeStringValue("@odata.type", deploymentSettings.odataType);
    writer.writeObjectValue<ScheduleSettings>("schedule", deploymentSettings.schedule, serializeScheduleSettings);
    writer.writeObjectValue<UserExperienceSettings>("userExperience", deploymentSettings.userExperience, serializeUserExperienceSettings);
    writer.writeAdditionalData(deploymentSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param DeploymentState The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeploymentState(writer: SerializationWriter, deploymentState: Partial<DeploymentState> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deploymentState || isSerializingDerivedType) { return; }
    writer.writeEnumValue<DeploymentStateValue>("effectiveValue", deploymentState.effectiveValue);
    writer.writeStringValue("@odata.type", deploymentState.odataType);
    writer.writeCollectionOfObjectValues<DeploymentStateReason>("reasons", deploymentState.reasons, serializeDeploymentStateReason);
    writer.writeEnumValue<RequestedDeploymentStateValue>("requestedValue", deploymentState.requestedValue);
    writer.writeAdditionalData(deploymentState.additionalData);
}
/**
 * Serializes information the current object
 * @param DeploymentStateReason The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeploymentStateReason(writer: SerializationWriter, deploymentStateReason: Partial<DeploymentStateReason> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!deploymentStateReason || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", deploymentStateReason.odataType);
    writer.writeEnumValue<DeploymentStateReasonValue>("value", deploymentStateReason.value);
    writer.writeAdditionalData(deploymentStateReason.additionalData);
}
/**
 * Serializes information the current object
 * @param DriverUpdateCatalogEntry The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDriverUpdateCatalogEntry(writer: SerializationWriter, driverUpdateCatalogEntry: Partial<DriverUpdateCatalogEntry> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!driverUpdateCatalogEntry || isSerializingDerivedType) { return; }
    serializeSoftwareUpdateCatalogEntry(writer, driverUpdateCatalogEntry, isSerializingDerivedType)
    writer.writeStringValue("description", driverUpdateCatalogEntry.description);
    writer.writeStringValue("driverClass", driverUpdateCatalogEntry.driverClass);
    writer.writeStringValue("manufacturer", driverUpdateCatalogEntry.manufacturer);
    writer.writeStringValue("provider", driverUpdateCatalogEntry.provider);
    writer.writeStringValue("setupInformationFile", driverUpdateCatalogEntry.setupInformationFile);
    writer.writeStringValue("version", driverUpdateCatalogEntry.version);
    writer.writeDateValue("versionDateTime", driverUpdateCatalogEntry.versionDateTime);
}
/**
 * Serializes information the current object
 * @param DriverUpdateFilter The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDriverUpdateFilter(writer: SerializationWriter, driverUpdateFilter: Partial<DriverUpdateFilter> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!driverUpdateFilter || isSerializingDerivedType) { return; }
    serializeWindowsUpdateFilter(writer, driverUpdateFilter, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param DurationDrivenRolloutSettings The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDurationDrivenRolloutSettings(writer: SerializationWriter, durationDrivenRolloutSettings: Partial<DurationDrivenRolloutSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!durationDrivenRolloutSettings || isSerializingDerivedType) { return; }
    serializeGradualRolloutSettings(writer, durationDrivenRolloutSettings, isSerializingDerivedType)
    writer.writeDurationValue("durationUntilDeploymentEnd", durationDrivenRolloutSettings.durationUntilDeploymentEnd);
}
/**
 * Serializes information the current object
 * @param Edition The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEdition(writer: SerializationWriter, edition: Partial<Edition> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!edition || isSerializingDerivedType) { return; }
    serializeEntity(writer, edition, isSerializingDerivedType)
    writer.writeStringValue("deviceFamily", edition.deviceFamily);
    writer.writeDateValue("endOfServiceDateTime", edition.endOfServiceDateTime);
    writer.writeDateValue("generalAvailabilityDateTime", edition.generalAvailabilityDateTime);
    writer.writeBooleanValue("isInService", edition.isInService);
    writer.writeStringValue("name", edition.name);
    writer.writeStringValue("releasedName", edition.releasedName);
    writer.writeCollectionOfObjectValues<ServicingPeriod>("servicingPeriods", edition.servicingPeriods, serializeServicingPeriod);
}
/**
 * Serializes information the current object
 * @param EditionCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEditionCollectionResponse(writer: SerializationWriter, editionCollectionResponse: Partial<EditionCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!editionCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, editionCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Edition>("value", editionCollectionResponse.value, serializeEdition);
}
/**
 * Serializes information the current object
 * @param ExpediteSettings The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExpediteSettings(writer: SerializationWriter, expediteSettings: Partial<ExpediteSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!expediteSettings || isSerializingDerivedType) { return; }
    writer.writeBooleanValue("isExpedited", expediteSettings.isExpedited);
    writer.writeBooleanValue("isReadinessTest", expediteSettings.isReadinessTest);
    writer.writeStringValue("@odata.type", expediteSettings.odataType);
    writer.writeAdditionalData(expediteSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param FeatureUpdateCatalogEntry The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFeatureUpdateCatalogEntry(writer: SerializationWriter, featureUpdateCatalogEntry: Partial<FeatureUpdateCatalogEntry> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!featureUpdateCatalogEntry || isSerializingDerivedType) { return; }
    serializeSoftwareUpdateCatalogEntry(writer, featureUpdateCatalogEntry, isSerializingDerivedType)
    writer.writeStringValue("buildNumber", featureUpdateCatalogEntry.buildNumber);
    writer.writeStringValue("version", featureUpdateCatalogEntry.version);
}
/**
 * Serializes information the current object
 * @param GradualRolloutSettings The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGradualRolloutSettings(writer: SerializationWriter, gradualRolloutSettings: Partial<GradualRolloutSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!gradualRolloutSettings || isSerializingDerivedType) { return; }
    writer.writeDurationValue("durationBetweenOffers", gradualRolloutSettings.durationBetweenOffers);
    writer.writeStringValue("@odata.type", gradualRolloutSettings.odataType);
    writer.writeAdditionalData(gradualRolloutSettings.additionalData);
    switch (gradualRolloutSettings.odataType) {
        case "#microsoft.graph.windowsUpdates.dateDrivenRolloutSettings":
            serializeDateDrivenRolloutSettings(writer, gradualRolloutSettings, true);
        break;
        case "#microsoft.graph.windowsUpdates.durationDrivenRolloutSettings":
            serializeDurationDrivenRolloutSettings(writer, gradualRolloutSettings, true);
        break;
        case "#microsoft.graph.windowsUpdates.rateDrivenRolloutSettings":
            serializeRateDrivenRolloutSettings(writer, gradualRolloutSettings, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ItemBody The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeItemBody(writer: SerializationWriter, itemBody: Partial<ItemBody> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!itemBody || isSerializingDerivedType) { return; }
    writer.writeStringValue("content", itemBody.content);
    writer.writeEnumValue<BodyType>("contentType", itemBody.contentType);
    writer.writeStringValue("@odata.type", itemBody.odataType);
    writer.writeAdditionalData(itemBody.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param KnowledgeBaseArticle The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeKnowledgeBaseArticle(writer: SerializationWriter, knowledgeBaseArticle: Partial<KnowledgeBaseArticle> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!knowledgeBaseArticle || isSerializingDerivedType) { return; }
    serializeEntity(writer, knowledgeBaseArticle, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param KnownIssue The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeKnownIssue(writer: SerializationWriter, knownIssue: Partial<KnownIssue> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!knownIssue || isSerializingDerivedType) { return; }
    serializeEntity(writer, knownIssue, isSerializingDerivedType)
    writer.writeStringValue("description", knownIssue.description);
    writer.writeCollectionOfObjectValues<KnownIssueHistoryItem>("knownIssueHistories", knownIssue.knownIssueHistories, serializeKnownIssueHistoryItem);
    writer.writeDateValue("lastUpdatedDateTime", knownIssue.lastUpdatedDateTime);
    writer.writeObjectValue<KnowledgeBaseArticle>("originatingKnowledgeBaseArticle", knownIssue.originatingKnowledgeBaseArticle, serializeKnowledgeBaseArticle);
    writer.writeDateValue("resolvedDateTime", knownIssue.resolvedDateTime);
    writer.writeObjectValue<KnowledgeBaseArticle>("resolvingKnowledgeBaseArticle", knownIssue.resolvingKnowledgeBaseArticle, serializeKnowledgeBaseArticle);
    writer.writeCollectionOfPrimitiveValues<number>("safeguardHoldIds", knownIssue.safeguardHoldIds);
    writer.writeDateValue("startDateTime", knownIssue.startDateTime);
    writer.writeEnumValue<WindowsReleaseHealthStatus>("status", knownIssue.status);
    writer.writeStringValue("title", knownIssue.title);
    writer.writeStringValue("webViewUrl", knownIssue.webViewUrl);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param KnownIssueCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeKnownIssueCollectionResponse(writer: SerializationWriter, knownIssueCollectionResponse: Partial<KnownIssueCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!knownIssueCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, knownIssueCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<KnownIssue>("value", knownIssueCollectionResponse.value, serializeKnownIssue);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param KnownIssueHistoryItem The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeKnownIssueHistoryItem(writer: SerializationWriter, knownIssueHistoryItem: Partial<KnownIssueHistoryItem> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!knownIssueHistoryItem || isSerializingDerivedType) { return; }
    writer.writeObjectValue<ItemBody>("body", knownIssueHistoryItem.body, serializeItemBody);
    writer.writeDateValue("createdDateTime", knownIssueHistoryItem.createdDateTime);
    writer.writeStringValue("@odata.type", knownIssueHistoryItem.odataType);
    writer.writeAdditionalData(knownIssueHistoryItem.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param MonitoringRule The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeMonitoringRule(writer: SerializationWriter, monitoringRule: Partial<MonitoringRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!monitoringRule || isSerializingDerivedType) { return; }
    writer.writeEnumValue<MonitoringAction>("action", monitoringRule.action);
    writer.writeStringValue("@odata.type", monitoringRule.odataType);
    writer.writeEnumValue<MonitoringSignal>("signal", monitoringRule.signal);
    writer.writeNumberValue("threshold", monitoringRule.threshold);
    writer.writeAdditionalData(monitoringRule.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param MonitoringSettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeMonitoringSettings(writer: SerializationWriter, monitoringSettings: Partial<MonitoringSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!monitoringSettings || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<MonitoringRule>("monitoringRules", monitoringSettings.monitoringRules, serializeMonitoringRule);
    writer.writeStringValue("@odata.type", monitoringSettings.odataType);
    writer.writeAdditionalData(monitoringSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param OperationalInsightsConnection The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeOperationalInsightsConnection(writer: SerializationWriter, operationalInsightsConnection: Partial<OperationalInsightsConnection> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!operationalInsightsConnection || isSerializingDerivedType) { return; }
    serializeResourceConnection(writer, operationalInsightsConnection, isSerializingDerivedType)
    writer.writeStringValue("azureResourceGroupName", operationalInsightsConnection.azureResourceGroupName);
    writer.writeStringValue("azureSubscriptionId", operationalInsightsConnection.azureSubscriptionId);
    writer.writeStringValue("workspaceName", operationalInsightsConnection.workspaceName);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Product The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeProduct(writer: SerializationWriter, product: Partial<Product> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!product || isSerializingDerivedType) { return; }
    serializeEntity(writer, product, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Edition>("editions", product.editions, serializeEdition);
    writer.writeCollectionOfPrimitiveValues<string>("friendlyNames", product.friendlyNames);
    writer.writeStringValue("groupName", product.groupName);
    writer.writeCollectionOfObjectValues<KnownIssue>("knownIssues", product.knownIssues, serializeKnownIssue);
    writer.writeStringValue("name", product.name);
    writer.writeCollectionOfObjectValues<ProductRevision>("revisions", product.revisions, serializeProductRevision);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ProductCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeProductCollectionResponse(writer: SerializationWriter, productCollectionResponse: Partial<ProductCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!productCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, productCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Product>("value", productCollectionResponse.value, serializeProduct);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ProductRevision The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeProductRevision(writer: SerializationWriter, productRevision: Partial<ProductRevision> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!productRevision || isSerializingDerivedType) { return; }
    serializeEntity(writer, productRevision, isSerializingDerivedType)
    writer.writeObjectValue<CatalogEntry>("catalogEntry", productRevision.catalogEntry, serializeCatalogEntry);
    writer.writeStringValue("displayName", productRevision.displayName);
    writer.writeBooleanValue("isHotpatchUpdate", productRevision.isHotpatchUpdate);
    writer.writeObjectValue<KnowledgeBaseArticle>("knowledgeBaseArticle", productRevision.knowledgeBaseArticle, serializeKnowledgeBaseArticle);
    writer.writeObjectValue<BuildVersionDetails>("osBuild", productRevision.osBuild, serializeBuildVersionDetails);
    writer.writeStringValue("product", productRevision.product);
    writer.writeDateValue("releaseDateTime", productRevision.releaseDateTime);
    writer.writeStringValue("version", productRevision.version);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ProductRevisionCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeProductRevisionCollectionResponse(writer: SerializationWriter, productRevisionCollectionResponse: Partial<ProductRevisionCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!productRevisionCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, productRevisionCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ProductRevision>("value", productRevisionCollectionResponse.value, serializeProductRevision);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param QualityUpdateCatalogEntry The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeQualityUpdateCatalogEntry(writer: SerializationWriter, qualityUpdateCatalogEntry: Partial<QualityUpdateCatalogEntry> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!qualityUpdateCatalogEntry || isSerializingDerivedType) { return; }
    serializeSoftwareUpdateCatalogEntry(writer, qualityUpdateCatalogEntry, isSerializingDerivedType)
    writer.writeStringValue("catalogName", qualityUpdateCatalogEntry.catalogName);
    writer.writeObjectValue<QualityUpdateCveSeverityInformation>("cveSeverityInformation", qualityUpdateCatalogEntry.cveSeverityInformation, serializeQualityUpdateCveSeverityInformation);
    writer.writeBooleanValue("isExpeditable", qualityUpdateCatalogEntry.isExpeditable);
    writer.writeCollectionOfObjectValues<ProductRevision>("productRevisions", qualityUpdateCatalogEntry.productRevisions, serializeProductRevision);
    writer.writeEnumValue<QualityUpdateCadence>("qualityUpdateCadence", qualityUpdateCatalogEntry.qualityUpdateCadence);
    writer.writeEnumValue<QualityUpdateClassification>("qualityUpdateClassification", qualityUpdateCatalogEntry.qualityUpdateClassification);
    writer.writeStringValue("shortName", qualityUpdateCatalogEntry.shortName);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param QualityUpdateCveSeverityInformation The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeQualityUpdateCveSeverityInformation(writer: SerializationWriter, qualityUpdateCveSeverityInformation: Partial<QualityUpdateCveSeverityInformation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!qualityUpdateCveSeverityInformation || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<CveInformation>("exploitedCves", qualityUpdateCveSeverityInformation.exploitedCves, serializeCveInformation);
    writer.writeNumberValue("maxBaseScore", qualityUpdateCveSeverityInformation.maxBaseScore);
    writer.writeEnumValue<CveSeverityLevel>("maxSeverity", qualityUpdateCveSeverityInformation.maxSeverity);
    writer.writeStringValue("@odata.type", qualityUpdateCveSeverityInformation.odataType);
    writer.writeAdditionalData(qualityUpdateCveSeverityInformation.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param QualityUpdateFilter The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeQualityUpdateFilter(writer: SerializationWriter, qualityUpdateFilter: Partial<QualityUpdateFilter> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!qualityUpdateFilter || isSerializingDerivedType) { return; }
    serializeWindowsUpdateFilter(writer, qualityUpdateFilter, isSerializingDerivedType)
    writer.writeEnumValue<QualityUpdateCadence>("cadence", qualityUpdateFilter.cadence);
    writer.writeEnumValue<QualityUpdateClassification>("classification", qualityUpdateFilter.classification);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RateDrivenRolloutSettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRateDrivenRolloutSettings(writer: SerializationWriter, rateDrivenRolloutSettings: Partial<RateDrivenRolloutSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!rateDrivenRolloutSettings || isSerializingDerivedType) { return; }
    serializeGradualRolloutSettings(writer, rateDrivenRolloutSettings, isSerializingDerivedType)
    writer.writeNumberValue("devicesPerOffer", rateDrivenRolloutSettings.devicesPerOffer);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RemediationUpdateFilter The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRemediationUpdateFilter(writer: SerializationWriter, remediationUpdateFilter: Partial<RemediationUpdateFilter> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!remediationUpdateFilter || isSerializingDerivedType) { return; }
    serializeWindowsUpdateFilter(writer, remediationUpdateFilter, isSerializingDerivedType)
    writer.writeEnumValue<RemediationType>("remediationType", remediationUpdateFilter.remediationType);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ResourceConnection The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeResourceConnection(writer: SerializationWriter, resourceConnection: Partial<ResourceConnection> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!resourceConnection || isSerializingDerivedType) { return; }
    serializeEntity(writer, resourceConnection, isSerializingDerivedType)
    writer.writeEnumValue<ResourceConnectionState>("state", resourceConnection.state);
    switch (resourceConnection.odataType) {
        case "#microsoft.graph.windowsUpdates.operationalInsightsConnection":
            serializeOperationalInsightsConnection(writer, resourceConnection, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ResourceConnectionCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeResourceConnectionCollectionResponse(writer: SerializationWriter, resourceConnectionCollectionResponse: Partial<ResourceConnectionCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!resourceConnectionCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, resourceConnectionCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ResourceConnection>("value", resourceConnectionCollectionResponse.value, serializeResourceConnection);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SafeguardProfile The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSafeguardProfile(writer: SerializationWriter, safeguardProfile: Partial<SafeguardProfile> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!safeguardProfile || isSerializingDerivedType) { return; }
    writer.writeEnumValue<SafeguardCategory>("category", safeguardProfile.category);
    writer.writeStringValue("@odata.type", safeguardProfile.odataType);
    writer.writeAdditionalData(safeguardProfile.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SafeguardSettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSafeguardSettings(writer: SerializationWriter, safeguardSettings: Partial<SafeguardSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!safeguardSettings || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<SafeguardProfile>("disabledSafeguardProfiles", safeguardSettings.disabledSafeguardProfiles, serializeSafeguardProfile);
    writer.writeStringValue("@odata.type", safeguardSettings.odataType);
    writer.writeAdditionalData(safeguardSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ScheduleSettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeScheduleSettings(writer: SerializationWriter, scheduleSettings: Partial<ScheduleSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!scheduleSettings || isSerializingDerivedType) { return; }
    writer.writeObjectValue<GradualRolloutSettings>("gradualRollout", scheduleSettings.gradualRollout, serializeGradualRolloutSettings);
    writer.writeStringValue("@odata.type", scheduleSettings.odataType);
    writer.writeDateValue("startDateTime", scheduleSettings.startDateTime);
    writer.writeAdditionalData(scheduleSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ServicingPeriod The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeServicingPeriod(writer: SerializationWriter, servicingPeriod: Partial<ServicingPeriod> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!servicingPeriod || isSerializingDerivedType) { return; }
    writer.writeDateValue("endDateTime", servicingPeriod.endDateTime);
    writer.writeStringValue("name", servicingPeriod.name);
    writer.writeStringValue("@odata.type", servicingPeriod.odataType);
    writer.writeDateValue("startDateTime", servicingPeriod.startDateTime);
    writer.writeAdditionalData(servicingPeriod.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SoftwareUpdateCatalogEntry The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSoftwareUpdateCatalogEntry(writer: SerializationWriter, softwareUpdateCatalogEntry: Partial<SoftwareUpdateCatalogEntry> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!softwareUpdateCatalogEntry || isSerializingDerivedType) { return; }
    serializeCatalogEntry(writer, softwareUpdateCatalogEntry, isSerializingDerivedType)
    switch (softwareUpdateCatalogEntry.odataType) {
        case "#microsoft.graph.windowsUpdates.driverUpdateCatalogEntry":
            serializeDriverUpdateCatalogEntry(writer, softwareUpdateCatalogEntry, true);
        break;
        case "#microsoft.graph.windowsUpdates.featureUpdateCatalogEntry":
            serializeFeatureUpdateCatalogEntry(writer, softwareUpdateCatalogEntry, true);
        break;
        case "#microsoft.graph.windowsUpdates.qualityUpdateCatalogEntry":
            serializeQualityUpdateCatalogEntry(writer, softwareUpdateCatalogEntry, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SoftwareUpdateFilter The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSoftwareUpdateFilter(writer: SerializationWriter, softwareUpdateFilter: Partial<SoftwareUpdateFilter> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!softwareUpdateFilter || isSerializingDerivedType) { return; }
    serializeContentFilter(writer, softwareUpdateFilter, isSerializingDerivedType)
    switch (softwareUpdateFilter.odataType) {
        case "#microsoft.graph.windowsUpdates.driverUpdateFilter":
            serializeDriverUpdateFilter(writer, softwareUpdateFilter, true);
        break;
        case "#microsoft.graph.windowsUpdates.qualityUpdateFilter":
            serializeQualityUpdateFilter(writer, softwareUpdateFilter, true);
        break;
        case "#microsoft.graph.windowsUpdates.remediationUpdateFilter":
            serializeRemediationUpdateFilter(writer, softwareUpdateFilter, true);
        break;
        case "#microsoft.graph.windowsUpdates.windowsUpdateFilter":
            serializeWindowsUpdateFilter(writer, softwareUpdateFilter, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UpdatableAsset The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUpdatableAsset(writer: SerializationWriter, updatableAsset: Partial<UpdatableAsset> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!updatableAsset || isSerializingDerivedType) { return; }
    serializeEntity(writer, updatableAsset, isSerializingDerivedType)
    switch (updatableAsset.odataType) {
        case "#microsoft.graph.windowsUpdates.azureADDevice":
            serializeAzureADDevice(writer, updatableAsset, true);
        break;
        case "#microsoft.graph.windowsUpdates.updatableAssetGroup":
            serializeUpdatableAssetGroup(writer, updatableAsset, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UpdatableAssetCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUpdatableAssetCollectionResponse(writer: SerializationWriter, updatableAssetCollectionResponse: Partial<UpdatableAssetCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!updatableAssetCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, updatableAssetCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<UpdatableAsset>("value", updatableAssetCollectionResponse.value, serializeUpdatableAsset);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UpdatableAssetError The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUpdatableAssetError(writer: SerializationWriter, updatableAssetError: Partial<UpdatableAssetError> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!updatableAssetError || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", updatableAssetError.odataType);
    writer.writeAdditionalData(updatableAssetError.additionalData);
    switch (updatableAssetError.odataType) {
        case "#microsoft.graph.windowsUpdates.azureADDeviceRegistrationError":
            serializeAzureADDeviceRegistrationError(writer, updatableAssetError, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UpdatableAssetGroup The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUpdatableAssetGroup(writer: SerializationWriter, updatableAssetGroup: Partial<UpdatableAssetGroup> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!updatableAssetGroup || isSerializingDerivedType) { return; }
    serializeUpdatableAsset(writer, updatableAssetGroup, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<UpdatableAsset>("members", updatableAssetGroup.members, serializeUpdatableAsset);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UpdateCategoryEnrollmentInformation The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUpdateCategoryEnrollmentInformation(writer: SerializationWriter, updateCategoryEnrollmentInformation: Partial<UpdateCategoryEnrollmentInformation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!updateCategoryEnrollmentInformation || isSerializingDerivedType) { return; }
    writer.writeEnumValue<EnrollmentState>("enrollmentState", updateCategoryEnrollmentInformation.enrollmentState);
    writer.writeDateValue("lastModifiedDateTime", updateCategoryEnrollmentInformation.lastModifiedDateTime);
    writer.writeStringValue("@odata.type", updateCategoryEnrollmentInformation.odataType);
    writer.writeAdditionalData(updateCategoryEnrollmentInformation.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UpdateManagementEnrollment The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUpdateManagementEnrollment(writer: SerializationWriter, updateManagementEnrollment: Partial<UpdateManagementEnrollment> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!updateManagementEnrollment || isSerializingDerivedType) { return; }
    writer.writeObjectValue<UpdateCategoryEnrollmentInformation>("driver", updateManagementEnrollment.driver, serializeUpdateCategoryEnrollmentInformation);
    writer.writeObjectValue<UpdateCategoryEnrollmentInformation>("feature", updateManagementEnrollment.feature, serializeUpdateCategoryEnrollmentInformation);
    writer.writeStringValue("@odata.type", updateManagementEnrollment.odataType);
    writer.writeObjectValue<UpdateCategoryEnrollmentInformation>("quality", updateManagementEnrollment.quality, serializeUpdateCategoryEnrollmentInformation);
    writer.writeAdditionalData(updateManagementEnrollment.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UpdatePolicy The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUpdatePolicy(writer: SerializationWriter, updatePolicy: Partial<UpdatePolicy> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!updatePolicy || isSerializingDerivedType) { return; }
    serializeEntity(writer, updatePolicy, isSerializingDerivedType)
    writer.writeObjectValue<DeploymentAudience>("audience", updatePolicy.audience, serializeDeploymentAudience);
    writer.writeCollectionOfObjectValues<ComplianceChangeRule>("complianceChangeRules", updatePolicy.complianceChangeRules, serializeComplianceChangeRule);
    writer.writeCollectionOfObjectValues<ComplianceChange>("complianceChanges", updatePolicy.complianceChanges, serializeComplianceChange);
    writer.writeDateValue("createdDateTime", updatePolicy.createdDateTime);
    writer.writeObjectValue<DeploymentSettings>("deploymentSettings", updatePolicy.deploymentSettings, serializeDeploymentSettings);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UpdatePolicyCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUpdatePolicyCollectionResponse(writer: SerializationWriter, updatePolicyCollectionResponse: Partial<UpdatePolicyCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!updatePolicyCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, updatePolicyCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<UpdatePolicy>("value", updatePolicyCollectionResponse.value, serializeUpdatePolicy);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UserExperienceSettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUserExperienceSettings(writer: SerializationWriter, userExperienceSettings: Partial<UserExperienceSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!userExperienceSettings || isSerializingDerivedType) { return; }
    writer.writeNumberValue("daysUntilForcedReboot", userExperienceSettings.daysUntilForcedReboot);
    writer.writeBooleanValue("isHotpatchEnabled", userExperienceSettings.isHotpatchEnabled);
    writer.writeStringValue("@odata.type", userExperienceSettings.odataType);
    writer.writeBooleanValue("offerAsOptional", userExperienceSettings.offerAsOptional);
    writer.writeAdditionalData(userExperienceSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WindowsUpdateFilter The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWindowsUpdateFilter(writer: SerializationWriter, windowsUpdateFilter: Partial<WindowsUpdateFilter> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!windowsUpdateFilter || isSerializingDerivedType) { return; }
    serializeSoftwareUpdateFilter(writer, windowsUpdateFilter, isSerializingDerivedType)
    switch (windowsUpdateFilter.odataType) {
        case "#microsoft.graph.windowsUpdates.driverUpdateFilter":
            serializeDriverUpdateFilter(writer, windowsUpdateFilter, true);
        break;
        case "#microsoft.graph.windowsUpdates.qualityUpdateFilter":
            serializeQualityUpdateFilter(writer, windowsUpdateFilter, true);
        break;
        case "#microsoft.graph.windowsUpdates.remediationUpdateFilter":
            serializeRemediationUpdateFilter(writer, windowsUpdateFilter, true);
        break;
    }
}
export interface ServicingPeriod extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The date and time when the servicing period ends. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    endDateTime?: Date | null;
    /**
     * The name of the servicing period. For example, Modern Lifecycle.
     */
    name?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The start date and time of the servicing period. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    startDateTime?: Date | null;
}
export interface SoftwareUpdateCatalogEntry extends CatalogEntry, Parsable {
}
export interface SoftwareUpdateFilter extends ContentFilter, Parsable {
}
export interface UpdatableAsset extends Entity, Parsable {
}
export interface UpdatableAssetCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UpdatableAsset[] | null;
}
export interface UpdatableAssetError extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface UpdatableAssetGroup extends Parsable, UpdatableAsset {
    /**
     * Members of the group. Read-only.
     */
    members?: UpdatableAsset[] | null;
}
export type UpdateCategory = (typeof UpdateCategoryObject)[keyof typeof UpdateCategoryObject];
export interface UpdateCategoryEnrollmentInformation extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The enrollmentState property
     */
    enrollmentState?: EnrollmentState | null;
    /**
     * The lastModifiedDateTime property
     */
    lastModifiedDateTime?: Date | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface UpdateManagementEnrollment extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The driver property
     */
    driver?: UpdateCategoryEnrollmentInformation | null;
    /**
     * The feature property
     */
    feature?: UpdateCategoryEnrollmentInformation | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The quality property
     */
    quality?: UpdateCategoryEnrollmentInformation | null;
}
export interface UpdatePolicy extends Entity, Parsable {
    /**
     * Specifies the audience to target.
     */
    audience?: DeploymentAudience | null;
    /**
     * Rules for governing the automatic creation of compliance changes.
     */
    complianceChangeRules?: ComplianceChangeRule[] | null;
    /**
     * Compliance changes like content approvals which result in the automatic creation of deployments using the audience and deploymentSettings of the policy.
     */
    complianceChanges?: ComplianceChange[] | null;
    /**
     * The date and time when the update policy was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    createdDateTime?: Date | null;
    /**
     * Settings for governing how to deploy content.
     */
    deploymentSettings?: DeploymentSettings | null;
}
export interface UpdatePolicyCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UpdatePolicy[] | null;
}
export interface UserExperienceSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Specifies the number of days after an update is installed, during which the user of the device can control when the device restarts.
     */
    daysUntilForcedReboot?: number | null;
    /**
     * Specifies whether the update is offered as a hotpatch. It can only be set to true on automatic policies that target monthly security updates.
     */
    isHotpatchEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Specifies whether the update is offered as Optional rather than Required.
     */
    offerAsOptional?: boolean | null;
}
export type WindowsReleaseHealthStatus = (typeof WindowsReleaseHealthStatusObject)[keyof typeof WindowsReleaseHealthStatusObject];
export interface WindowsUpdateFilter extends Parsable, SoftwareUpdateFilter {
}
export const AzureADDeviceRegistrationErrorReasonObject = {
    InvalidGlobalDeviceId: "invalidGlobalDeviceId",
    InvalidAzureADDeviceId: "invalidAzureADDeviceId",
    MissingTrustType: "missingTrustType",
    InvalidAzureADJoin: "invalidAzureADJoin",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const BodyTypeObject = {
    Text: "text",
    Html: "html",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const CveSeverityLevelObject = {
    Critical: "critical",
    Important: "important",
    Moderate: "moderate",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeploymentStateReasonValueObject = {
    ScheduledByOfferWindow: "scheduledByOfferWindow",
    OfferingByRequest: "offeringByRequest",
    PausedByRequest: "pausedByRequest",
    PausedByMonitoring: "pausedByMonitoring",
    UnknownFutureValue: "unknownFutureValue",
    FaultedByContentOutdated: "faultedByContentOutdated",
} as const;
export const DeploymentStateValueObject = {
    Scheduled: "scheduled",
    Offering: "offering",
    Paused: "paused",
    Faulted: "faulted",
    Archived: "archived",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EnrollmentStateObject = {
    NotEnrolled: "notEnrolled",
    Enrolled: "enrolled",
    EnrolledWithPolicy: "enrolledWithPolicy",
    Enrolling: "enrolling",
    Unenrolling: "unenrolling",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const MonitoringActionObject = {
    AlertError: "alertError",
    OfferFallback: "offerFallback",
    PauseDeployment: "pauseDeployment",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const MonitoringSignalObject = {
    Rollback: "rollback",
    Ineligible: "ineligible",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const QualityUpdateCadenceObject = {
    Monthly: "monthly",
    OutOfBand: "outOfBand",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const QualityUpdateClassificationObject = {
    All: "all",
    Security: "security",
    NonSecurity: "nonSecurity",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RemediationTypeObject = {
    InPlaceUpgrade: "inPlaceUpgrade",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RequestedDeploymentStateValueObject = {
    None: "none",
    Paused: "paused",
    Archived: "archived",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ResourceConnectionStateObject = {
    Connected: "connected",
    NotAuthorized: "notAuthorized",
    NotFound: "notFound",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SafeguardCategoryObject = {
    LikelyIssues: "likelyIssues",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const UpdateCategoryObject = {
    Feature: "feature",
    Quality: "quality",
    UnknownFutureValue: "unknownFutureValue",
    Driver: "driver",
} as const;
export const WindowsReleaseHealthStatusObject = {
    Resolved: "resolved",
    MitigatedExternal: "mitigatedExternal",
    Mitigated: "mitigated",
    ResolvedExternal: "resolvedExternal",
    Confirmed: "confirmed",
    Reported: "reported",
    Investigating: "investigating",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
