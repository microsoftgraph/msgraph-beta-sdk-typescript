/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
import { deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, type BaseCollectionPaginationCountResponse, type Entity } from '../';
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Duration, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface ApplicableContent extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Catalog entry for the update or content.
     */
    catalogEntry?: CatalogEntry;
    /**
     * ID of the catalog entry for the applicable content.
     */
    catalogEntryId?: string;
    /**
     * Collection of devices and recommendations for applicable catalog content.
     */
    matchedDevices?: ApplicableContentDeviceMatch[];
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface ApplicableContentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ApplicableContent[];
}
export interface ApplicableContentDeviceMatch extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Collection of vendors who recommend the content.
     */
    deviceId?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Collection of vendors who recommend the content.
     */
    recommendedBy?: string[];
}
export interface ApplicableContentDeviceMatchCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ApplicableContentDeviceMatch[];
}
export interface AzureADDevice extends Parsable, UpdatableAsset {
    /**
     * Specifies areas of the service in which the device is enrolled. Read-only. Returned by default.
     */
    enrollments?: UpdatableAssetEnrollment[];
    /**
     * Specifies any errors that prevent the device from being enrolled in update management or receving deployed content. Read-only. Returned by default.
     */
    errors?: UpdatableAssetError[];
}
export interface AzureADDeviceRegistrationError extends Parsable, UpdatableAssetError {
    /**
     * The reason property
     */
    reason?: AzureADDeviceRegistrationErrorReason;
}
export type AzureADDeviceRegistrationErrorReason = (typeof AzureADDeviceRegistrationErrorReasonObject)[keyof typeof AzureADDeviceRegistrationErrorReasonObject];
export type BodyType = (typeof BodyTypeObject)[keyof typeof BodyTypeObject];
export interface BuildVersionDetails extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The build number of the product release. Read-only.
     */
    buildNumber?: number;
    /**
     * The major version of the product release. Read-only.
     */
    majorVersion?: number;
    /**
     * The minor version of the product release. Read-only.
     */
    minorVersion?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The update build revision number of the product revision. Read-only.
     */
    updateBuildRevision?: number;
}
export interface Catalog extends Entity, Parsable {
    /**
     * Lists the content that you can approve for deployment. Read-only.
     */
    entries?: CatalogEntry[];
}
export interface CatalogContent extends DeployableContent, Parsable {
    /**
     * The catalogEntry property
     */
    catalogEntry?: CatalogEntry;
}
export interface CatalogEntry extends Entity, Parsable {
    /**
     * The date on which the content is no longer available to deploy using the service. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    deployableUntilDateTime?: Date;
    /**
     * The display name of the content. Read-only.
     */
    displayName?: string;
    /**
     * The release date for the content. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    releaseDateTime?: Date;
}
export interface CatalogEntryCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CatalogEntry[];
}
export interface ComplianceChange extends Entity, Parsable {
    /**
     * The date and time when a compliance change was created.
     */
    createdDateTime?: Date;
    /**
     * True indicates that a compliance change is revoked, preventing further application. Revoking a compliance change is a final action.
     */
    isRevoked?: boolean;
    /**
     * The date and time when the compliance change was revoked.
     */
    revokedDateTime?: Date;
    /**
     * The policy this compliance change is a member of.
     */
    updatePolicy?: UpdatePolicy;
}
export interface ComplianceChangeCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ComplianceChange[];
}
export interface ComplianceChangeRule extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The date and time when the rule was created.
     */
    createdDateTime?: Date;
    /**
     * The date and time when the rule was last evaluated.
     */
    lastEvaluatedDateTime?: Date;
    /**
     * The date and time when the rule was last modified.
     */
    lastModifiedDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface ContentApplicabilitySettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Offer if the update is recommended by a vendor in the list, otherwise withhold the offer.
     */
    offerWhileRecommendedBy?: string[];
    /**
     * Settings for governing safeguard-holds on offering content.
     */
    safeguard?: SafeguardSettings;
}
export interface ContentApproval extends ComplianceChange, Parsable {
    /**
     * The content property
     */
    content?: DeployableContent;
    /**
     * Deployments created as a result of applying the approval.
     */
    deployments?: Deployment[];
    /**
     * Settings for governing how to deploy content.
     */
    deploymentSettings?: DeploymentSettings;
}
export interface ContentApprovalRule extends ComplianceChangeRule, Parsable {
    /**
     * A filter to determine which content matches the rule on an ongoing basis.
     */
    contentFilter?: ContentFilter;
    /**
     * The time before the deployment starts represented in ISO 8601 format for durations.
     */
    durationBeforeDeploymentStart?: Duration;
}
export interface ContentFilter extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ApplicableContentCollectionResponse}
 */
export function createApplicableContentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoApplicableContentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ApplicableContentDeviceMatchCollectionResponse}
 */
export function createApplicableContentDeviceMatchCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoApplicableContentDeviceMatchCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ApplicableContentDeviceMatch}
 */
export function createApplicableContentDeviceMatchFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoApplicableContentDeviceMatch;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ApplicableContent}
 */
export function createApplicableContentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoApplicableContent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AzureADDevice}
 */
export function createAzureADDeviceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAzureADDevice;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AzureADDeviceRegistrationError}
 */
export function createAzureADDeviceRegistrationErrorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAzureADDeviceRegistrationError;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BuildVersionDetails}
 */
export function createBuildVersionDetailsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBuildVersionDetails;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CatalogContent}
 */
export function createCatalogContentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCatalogContent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CatalogEntryCollectionResponse}
 */
export function createCatalogEntryCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCatalogEntryCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CatalogEntry}
 */
export function createCatalogEntryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.driverUpdateCatalogEntry":
                    return deserializeIntoDriverUpdateCatalogEntry;
                case "#microsoft.graph.windowsUpdates.featureUpdateCatalogEntry":
                    return deserializeIntoFeatureUpdateCatalogEntry;
                case "#microsoft.graph.windowsUpdates.qualityUpdateCatalogEntry":
                    return deserializeIntoQualityUpdateCatalogEntry;
                case "#microsoft.graph.windowsUpdates.softwareUpdateCatalogEntry":
                    return deserializeIntoSoftwareUpdateCatalogEntry;
            }
        }
    }
    return deserializeIntoCatalogEntry;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Catalog}
 */
export function createCatalogFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCatalog;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ComplianceChangeCollectionResponse}
 */
export function createComplianceChangeCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoComplianceChangeCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ComplianceChange}
 */
export function createComplianceChangeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.contentApproval":
                    return deserializeIntoContentApproval;
            }
        }
    }
    return deserializeIntoComplianceChange;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ComplianceChangeRule}
 */
export function createComplianceChangeRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.contentApprovalRule":
                    return deserializeIntoContentApprovalRule;
            }
        }
    }
    return deserializeIntoComplianceChangeRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContentApplicabilitySettings}
 */
export function createContentApplicabilitySettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContentApplicabilitySettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContentApproval}
 */
export function createContentApprovalFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContentApproval;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContentApprovalRule}
 */
export function createContentApprovalRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContentApprovalRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContentFilter}
 */
export function createContentFilterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.driverUpdateFilter":
                    return deserializeIntoDriverUpdateFilter;
                case "#microsoft.graph.windowsUpdates.qualityUpdateFilter":
                    return deserializeIntoQualityUpdateFilter;
                case "#microsoft.graph.windowsUpdates.softwareUpdateFilter":
                    return deserializeIntoSoftwareUpdateFilter;
                case "#microsoft.graph.windowsUpdates.windowsUpdateFilter":
                    return deserializeIntoWindowsUpdateFilter;
            }
        }
    }
    return deserializeIntoContentFilter;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CveInformation}
 */
export function createCveInformationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCveInformation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DateDrivenRolloutSettings}
 */
export function createDateDrivenRolloutSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDateDrivenRolloutSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeployableContent}
 */
export function createDeployableContentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.catalogContent":
                    return deserializeIntoCatalogContent;
            }
        }
    }
    return deserializeIntoDeployableContent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentAudienceCollectionResponse}
 */
export function createDeploymentAudienceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentAudienceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentAudience}
 */
export function createDeploymentAudienceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentAudience;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentCollectionResponse}
 */
export function createDeploymentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Deployment}
 */
export function createDeploymentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeployment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentSettings}
 */
export function createDeploymentSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentState}
 */
export function createDeploymentStateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentState;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentStateReason}
 */
export function createDeploymentStateReasonFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentStateReason;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DriverUpdateCatalogEntry}
 */
export function createDriverUpdateCatalogEntryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDriverUpdateCatalogEntry;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DriverUpdateFilter}
 */
export function createDriverUpdateFilterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDriverUpdateFilter;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DurationDrivenRolloutSettings}
 */
export function createDurationDrivenRolloutSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDurationDrivenRolloutSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EditionCollectionResponse}
 */
export function createEditionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEditionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Edition}
 */
export function createEditionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExpediteSettings}
 */
export function createExpediteSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExpediteSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FeatureUpdateCatalogEntry}
 */
export function createFeatureUpdateCatalogEntryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFeatureUpdateCatalogEntry;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GradualRolloutSettings}
 */
export function createGradualRolloutSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.dateDrivenRolloutSettings":
                    return deserializeIntoDateDrivenRolloutSettings;
                case "#microsoft.graph.windowsUpdates.durationDrivenRolloutSettings":
                    return deserializeIntoDurationDrivenRolloutSettings;
                case "#microsoft.graph.windowsUpdates.rateDrivenRolloutSettings":
                    return deserializeIntoRateDrivenRolloutSettings;
            }
        }
    }
    return deserializeIntoGradualRolloutSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ItemBody}
 */
export function createItemBodyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoItemBody;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KnowledgeBaseArticle}
 */
export function createKnowledgeBaseArticleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKnowledgeBaseArticle;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KnownIssueCollectionResponse}
 */
export function createKnownIssueCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKnownIssueCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KnownIssue}
 */
export function createKnownIssueFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKnownIssue;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KnownIssueHistoryItem}
 */
export function createKnownIssueHistoryItemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKnownIssueHistoryItem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MonitoringRule}
 */
export function createMonitoringRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMonitoringRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MonitoringSettings}
 */
export function createMonitoringSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMonitoringSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OperationalInsightsConnection}
 */
export function createOperationalInsightsConnectionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOperationalInsightsConnection;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProductCollectionResponse}
 */
export function createProductCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProductCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Product}
 */
export function createProductFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProduct;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProductRevisionCollectionResponse}
 */
export function createProductRevisionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProductRevisionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProductRevision}
 */
export function createProductRevisionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProductRevision;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {QualityUpdateCatalogEntry}
 */
export function createQualityUpdateCatalogEntryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQualityUpdateCatalogEntry;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {QualityUpdateCveSeverityInformation}
 */
export function createQualityUpdateCveSeverityInformationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQualityUpdateCveSeverityInformation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {QualityUpdateFilter}
 */
export function createQualityUpdateFilterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQualityUpdateFilter;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RateDrivenRolloutSettings}
 */
export function createRateDrivenRolloutSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRateDrivenRolloutSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ResourceConnectionCollectionResponse}
 */
export function createResourceConnectionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoResourceConnectionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ResourceConnection}
 */
export function createResourceConnectionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.operationalInsightsConnection":
                    return deserializeIntoOperationalInsightsConnection;
            }
        }
    }
    return deserializeIntoResourceConnection;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SafeguardProfile}
 */
export function createSafeguardProfileFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSafeguardProfile;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SafeguardSettings}
 */
export function createSafeguardSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSafeguardSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ScheduleSettings}
 */
export function createScheduleSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoScheduleSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServicingPeriod}
 */
export function createServicingPeriodFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServicingPeriod;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SoftwareUpdateCatalogEntry}
 */
export function createSoftwareUpdateCatalogEntryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.driverUpdateCatalogEntry":
                    return deserializeIntoDriverUpdateCatalogEntry;
                case "#microsoft.graph.windowsUpdates.featureUpdateCatalogEntry":
                    return deserializeIntoFeatureUpdateCatalogEntry;
                case "#microsoft.graph.windowsUpdates.qualityUpdateCatalogEntry":
                    return deserializeIntoQualityUpdateCatalogEntry;
            }
        }
    }
    return deserializeIntoSoftwareUpdateCatalogEntry;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SoftwareUpdateFilter}
 */
export function createSoftwareUpdateFilterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.driverUpdateFilter":
                    return deserializeIntoDriverUpdateFilter;
                case "#microsoft.graph.windowsUpdates.qualityUpdateFilter":
                    return deserializeIntoQualityUpdateFilter;
                case "#microsoft.graph.windowsUpdates.windowsUpdateFilter":
                    return deserializeIntoWindowsUpdateFilter;
            }
        }
    }
    return deserializeIntoSoftwareUpdateFilter;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatableAssetCollectionResponse}
 */
export function createUpdatableAssetCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdatableAssetCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatableAssetEnrollment}
 */
export function createUpdatableAssetEnrollmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.updateManagementEnrollment":
                    return deserializeIntoUpdateManagementEnrollment;
            }
        }
    }
    return deserializeIntoUpdatableAssetEnrollment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatableAssetError}
 */
export function createUpdatableAssetErrorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.azureADDeviceRegistrationError":
                    return deserializeIntoAzureADDeviceRegistrationError;
            }
        }
    }
    return deserializeIntoUpdatableAssetError;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatableAsset}
 */
export function createUpdatableAssetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.azureADDevice":
                    return deserializeIntoAzureADDevice;
                case "#microsoft.graph.windowsUpdates.updatableAssetGroup":
                    return deserializeIntoUpdatableAssetGroup;
            }
        }
    }
    return deserializeIntoUpdatableAsset;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatableAssetGroup}
 */
export function createUpdatableAssetGroupFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdatableAssetGroup;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdateManagementEnrollment}
 */
export function createUpdateManagementEnrollmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdateManagementEnrollment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatePolicyCollectionResponse}
 */
export function createUpdatePolicyCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdatePolicyCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdatePolicy}
 */
export function createUpdatePolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdatePolicy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserExperienceSettings}
 */
export function createUserExperienceSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserExperienceSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WindowsUpdateFilter}
 */
export function createWindowsUpdateFilterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.windowsUpdates.driverUpdateFilter":
                    return deserializeIntoDriverUpdateFilter;
                case "#microsoft.graph.windowsUpdates.qualityUpdateFilter":
                    return deserializeIntoQualityUpdateFilter;
            }
        }
    }
    return deserializeIntoWindowsUpdateFilter;
}
export interface CveInformation extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Identifies the number of the CVE. Read-only.
     */
    number?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * URL to the full CVE information. Read-only.
     */
    url?: string;
}
export type CveSeverityLevel = (typeof CveSeverityLevelObject)[keyof typeof CveSeverityLevelObject];
export interface DateDrivenRolloutSettings extends GradualRolloutSettings, Parsable {
    /**
     * Specifies the date before which all devices currently in the deployment are offered the update. Devices added after this date are offered immediately. When the endDateTime isn't set, all devices in the deployment are offered content at the same time.
     */
    endDateTime?: Date;
}
export interface DeployableContent extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface Deployment extends Entity, Parsable {
    /**
     * Specifies the audience to which content is deployed.
     */
    audience?: DeploymentAudience;
    /**
     * Specifies what content to deploy. Cannot be changed. Returned by default.
     */
    content?: DeployableContent;
    /**
     * The date and time the deployment was created. Returned by default. Read-only.
     */
    createdDateTime?: Date;
    /**
     * The date and time the deployment was last modified. Returned by default. Read-only.
     */
    lastModifiedDateTime?: Date;
    /**
     * Settings specified on the specific deployment governing how to deploy content. Returned by default.
     */
    settings?: DeploymentSettings;
    /**
     * Execution status of the deployment. Returned by default.
     */
    state?: DeploymentState;
}
export interface DeploymentAudience extends Entity, Parsable {
    /**
     * Content eligible to deploy to devices in the audience. Not nullable. Read-only.
     */
    applicableContent?: ApplicableContent[];
    /**
     * Specifies the assets to exclude from the audience.
     */
    exclusions?: UpdatableAsset[];
    /**
     * Specifies the assets to include in the audience.
     */
    members?: UpdatableAsset[];
}
export interface DeploymentAudienceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: DeploymentAudience[];
}
export interface DeploymentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Deployment[];
}
export interface DeploymentSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Settings for governing whether content is applicable to a device.
     */
    contentApplicability?: ContentApplicabilitySettings;
    /**
     * Settings for governing whether updates should be expedited.
     */
    expedite?: ExpediteSettings;
    /**
     * Settings for governing conditions to monitor and automated actions to take.
     */
    monitoring?: MonitoringSettings;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Settings for governing how and when the content is rolled out.
     */
    schedule?: ScheduleSettings;
    /**
     * Settings for governing end user update experience.
     */
    userExperience?: UserExperienceSettings;
}
export interface DeploymentState extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The effectiveValue property
     */
    effectiveValue?: DeploymentStateValue;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Specifies the reasons the deployment has its state value. Read-only.
     */
    reasons?: DeploymentStateReason[];
    /**
     * The requestedValue property
     */
    requestedValue?: RequestedDeploymentStateValue;
}
export interface DeploymentStateReason extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The value property
     */
    value?: DeploymentStateReasonValue;
}
export type DeploymentStateReasonValue = (typeof DeploymentStateReasonValueObject)[keyof typeof DeploymentStateReasonValueObject];
export type DeploymentStateValue = (typeof DeploymentStateValueObject)[keyof typeof DeploymentStateValueObject];
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoApplicableContent(applicableContent: Partial<ApplicableContent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { applicableContent.backingStoreEnabled = true; },
        "catalogEntry": n => { applicableContent.catalogEntry = n.getObjectValue<CatalogEntry>(createCatalogEntryFromDiscriminatorValue); },
        "catalogEntryId": n => { applicableContent.catalogEntryId = n.getStringValue(); },
        "matchedDevices": n => { applicableContent.matchedDevices = n.getCollectionOfObjectValues<ApplicableContentDeviceMatch>(createApplicableContentDeviceMatchFromDiscriminatorValue); },
        "@odata.type": n => { applicableContent.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoApplicableContentCollectionResponse(applicableContentCollectionResponse: Partial<ApplicableContentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(applicableContentCollectionResponse),
        "value": n => { applicableContentCollectionResponse.value = n.getCollectionOfObjectValues<ApplicableContent>(createApplicableContentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoApplicableContentDeviceMatch(applicableContentDeviceMatch: Partial<ApplicableContentDeviceMatch> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { applicableContentDeviceMatch.backingStoreEnabled = true; },
        "deviceId": n => { applicableContentDeviceMatch.deviceId = n.getStringValue(); },
        "@odata.type": n => { applicableContentDeviceMatch.odataType = n.getStringValue(); },
        "recommendedBy": n => { applicableContentDeviceMatch.recommendedBy = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoApplicableContentDeviceMatchCollectionResponse(applicableContentDeviceMatchCollectionResponse: Partial<ApplicableContentDeviceMatchCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(applicableContentDeviceMatchCollectionResponse),
        "value": n => { applicableContentDeviceMatchCollectionResponse.value = n.getCollectionOfObjectValues<ApplicableContentDeviceMatch>(createApplicableContentDeviceMatchFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAzureADDevice(azureADDevice: Partial<AzureADDevice> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUpdatableAsset(azureADDevice),
        "enrollments": n => { azureADDevice.enrollments = n.getCollectionOfObjectValues<UpdatableAssetEnrollment>(createUpdatableAssetEnrollmentFromDiscriminatorValue); },
        "errors": n => { azureADDevice.errors = n.getCollectionOfObjectValues<UpdatableAssetError>(createUpdatableAssetErrorFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAzureADDeviceRegistrationError(azureADDeviceRegistrationError: Partial<AzureADDeviceRegistrationError> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUpdatableAssetError(azureADDeviceRegistrationError),
        "reason": n => { azureADDeviceRegistrationError.reason = n.getEnumValue<AzureADDeviceRegistrationErrorReason>(AzureADDeviceRegistrationErrorReasonObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoBuildVersionDetails(buildVersionDetails: Partial<BuildVersionDetails> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { buildVersionDetails.backingStoreEnabled = true; },
        "buildNumber": n => { buildVersionDetails.buildNumber = n.getNumberValue(); },
        "majorVersion": n => { buildVersionDetails.majorVersion = n.getNumberValue(); },
        "minorVersion": n => { buildVersionDetails.minorVersion = n.getNumberValue(); },
        "@odata.type": n => { buildVersionDetails.odataType = n.getStringValue(); },
        "updateBuildRevision": n => { buildVersionDetails.updateBuildRevision = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCatalog(catalog: Partial<Catalog> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(catalog),
        "entries": n => { catalog.entries = n.getCollectionOfObjectValues<CatalogEntry>(createCatalogEntryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCatalogContent(catalogContent: Partial<CatalogContent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDeployableContent(catalogContent),
        "catalogEntry": n => { catalogContent.catalogEntry = n.getObjectValue<CatalogEntry>(createCatalogEntryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCatalogEntry(catalogEntry: Partial<CatalogEntry> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(catalogEntry),
        "deployableUntilDateTime": n => { catalogEntry.deployableUntilDateTime = n.getDateValue(); },
        "displayName": n => { catalogEntry.displayName = n.getStringValue(); },
        "releaseDateTime": n => { catalogEntry.releaseDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCatalogEntryCollectionResponse(catalogEntryCollectionResponse: Partial<CatalogEntryCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(catalogEntryCollectionResponse),
        "value": n => { catalogEntryCollectionResponse.value = n.getCollectionOfObjectValues<CatalogEntry>(createCatalogEntryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoComplianceChange(complianceChange: Partial<ComplianceChange> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(complianceChange),
        "createdDateTime": n => { complianceChange.createdDateTime = n.getDateValue(); },
        "isRevoked": n => { complianceChange.isRevoked = n.getBooleanValue(); },
        "revokedDateTime": n => { complianceChange.revokedDateTime = n.getDateValue(); },
        "updatePolicy": n => { complianceChange.updatePolicy = n.getObjectValue<UpdatePolicy>(createUpdatePolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoComplianceChangeCollectionResponse(complianceChangeCollectionResponse: Partial<ComplianceChangeCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(complianceChangeCollectionResponse),
        "value": n => { complianceChangeCollectionResponse.value = n.getCollectionOfObjectValues<ComplianceChange>(createComplianceChangeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoComplianceChangeRule(complianceChangeRule: Partial<ComplianceChangeRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { complianceChangeRule.backingStoreEnabled = true; },
        "createdDateTime": n => { complianceChangeRule.createdDateTime = n.getDateValue(); },
        "lastEvaluatedDateTime": n => { complianceChangeRule.lastEvaluatedDateTime = n.getDateValue(); },
        "lastModifiedDateTime": n => { complianceChangeRule.lastModifiedDateTime = n.getDateValue(); },
        "@odata.type": n => { complianceChangeRule.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContentApplicabilitySettings(contentApplicabilitySettings: Partial<ContentApplicabilitySettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { contentApplicabilitySettings.backingStoreEnabled = true; },
        "@odata.type": n => { contentApplicabilitySettings.odataType = n.getStringValue(); },
        "offerWhileRecommendedBy": n => { contentApplicabilitySettings.offerWhileRecommendedBy = n.getCollectionOfPrimitiveValues<string>(); },
        "safeguard": n => { contentApplicabilitySettings.safeguard = n.getObjectValue<SafeguardSettings>(createSafeguardSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContentApproval(contentApproval: Partial<ContentApproval> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoComplianceChange(contentApproval),
        "content": n => { contentApproval.content = n.getObjectValue<DeployableContent>(createDeployableContentFromDiscriminatorValue); },
        "deployments": n => { contentApproval.deployments = n.getCollectionOfObjectValues<Deployment>(createDeploymentFromDiscriminatorValue); },
        "deploymentSettings": n => { contentApproval.deploymentSettings = n.getObjectValue<DeploymentSettings>(createDeploymentSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContentApprovalRule(contentApprovalRule: Partial<ContentApprovalRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoComplianceChangeRule(contentApprovalRule),
        "contentFilter": n => { contentApprovalRule.contentFilter = n.getObjectValue<ContentFilter>(createContentFilterFromDiscriminatorValue); },
        "durationBeforeDeploymentStart": n => { contentApprovalRule.durationBeforeDeploymentStart = n.getDurationValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContentFilter(contentFilter: Partial<ContentFilter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { contentFilter.backingStoreEnabled = true; },
        "@odata.type": n => { contentFilter.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCveInformation(cveInformation: Partial<CveInformation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { cveInformation.backingStoreEnabled = true; },
        "number": n => { cveInformation.number = n.getStringValue(); },
        "@odata.type": n => { cveInformation.odataType = n.getStringValue(); },
        "url": n => { cveInformation.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDateDrivenRolloutSettings(dateDrivenRolloutSettings: Partial<DateDrivenRolloutSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoGradualRolloutSettings(dateDrivenRolloutSettings),
        "endDateTime": n => { dateDrivenRolloutSettings.endDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeployableContent(deployableContent: Partial<DeployableContent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { deployableContent.backingStoreEnabled = true; },
        "@odata.type": n => { deployableContent.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeployment(deployment: Partial<Deployment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(deployment),
        "audience": n => { deployment.audience = n.getObjectValue<DeploymentAudience>(createDeploymentAudienceFromDiscriminatorValue); },
        "content": n => { deployment.content = n.getObjectValue<DeployableContent>(createDeployableContentFromDiscriminatorValue); },
        "createdDateTime": n => { deployment.createdDateTime = n.getDateValue(); },
        "lastModifiedDateTime": n => { deployment.lastModifiedDateTime = n.getDateValue(); },
        "settings": n => { deployment.settings = n.getObjectValue<DeploymentSettings>(createDeploymentSettingsFromDiscriminatorValue); },
        "state": n => { deployment.state = n.getObjectValue<DeploymentState>(createDeploymentStateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeploymentAudience(deploymentAudience: Partial<DeploymentAudience> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(deploymentAudience),
        "applicableContent": n => { deploymentAudience.applicableContent = n.getCollectionOfObjectValues<ApplicableContent>(createApplicableContentFromDiscriminatorValue); },
        "exclusions": n => { deploymentAudience.exclusions = n.getCollectionOfObjectValues<UpdatableAsset>(createUpdatableAssetFromDiscriminatorValue); },
        "members": n => { deploymentAudience.members = n.getCollectionOfObjectValues<UpdatableAsset>(createUpdatableAssetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeploymentAudienceCollectionResponse(deploymentAudienceCollectionResponse: Partial<DeploymentAudienceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(deploymentAudienceCollectionResponse),
        "value": n => { deploymentAudienceCollectionResponse.value = n.getCollectionOfObjectValues<DeploymentAudience>(createDeploymentAudienceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeploymentCollectionResponse(deploymentCollectionResponse: Partial<DeploymentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(deploymentCollectionResponse),
        "value": n => { deploymentCollectionResponse.value = n.getCollectionOfObjectValues<Deployment>(createDeploymentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeploymentSettings(deploymentSettings: Partial<DeploymentSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { deploymentSettings.backingStoreEnabled = true; },
        "contentApplicability": n => { deploymentSettings.contentApplicability = n.getObjectValue<ContentApplicabilitySettings>(createContentApplicabilitySettingsFromDiscriminatorValue); },
        "expedite": n => { deploymentSettings.expedite = n.getObjectValue<ExpediteSettings>(createExpediteSettingsFromDiscriminatorValue); },
        "monitoring": n => { deploymentSettings.monitoring = n.getObjectValue<MonitoringSettings>(createMonitoringSettingsFromDiscriminatorValue); },
        "@odata.type": n => { deploymentSettings.odataType = n.getStringValue(); },
        "schedule": n => { deploymentSettings.schedule = n.getObjectValue<ScheduleSettings>(createScheduleSettingsFromDiscriminatorValue); },
        "userExperience": n => { deploymentSettings.userExperience = n.getObjectValue<UserExperienceSettings>(createUserExperienceSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeploymentState(deploymentState: Partial<DeploymentState> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { deploymentState.backingStoreEnabled = true; },
        "effectiveValue": n => { deploymentState.effectiveValue = n.getEnumValue<DeploymentStateValue>(DeploymentStateValueObject); },
        "@odata.type": n => { deploymentState.odataType = n.getStringValue(); },
        "reasons": n => { deploymentState.reasons = n.getCollectionOfObjectValues<DeploymentStateReason>(createDeploymentStateReasonFromDiscriminatorValue); },
        "requestedValue": n => { deploymentState.requestedValue = n.getEnumValue<RequestedDeploymentStateValue>(RequestedDeploymentStateValueObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeploymentStateReason(deploymentStateReason: Partial<DeploymentStateReason> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { deploymentStateReason.backingStoreEnabled = true; },
        "@odata.type": n => { deploymentStateReason.odataType = n.getStringValue(); },
        "value": n => { deploymentStateReason.value = n.getEnumValue<DeploymentStateReasonValue>(DeploymentStateReasonValueObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDriverUpdateCatalogEntry(driverUpdateCatalogEntry: Partial<DriverUpdateCatalogEntry> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSoftwareUpdateCatalogEntry(driverUpdateCatalogEntry),
        "description": n => { driverUpdateCatalogEntry.description = n.getStringValue(); },
        "driverClass": n => { driverUpdateCatalogEntry.driverClass = n.getStringValue(); },
        "manufacturer": n => { driverUpdateCatalogEntry.manufacturer = n.getStringValue(); },
        "provider": n => { driverUpdateCatalogEntry.provider = n.getStringValue(); },
        "setupInformationFile": n => { driverUpdateCatalogEntry.setupInformationFile = n.getStringValue(); },
        "version": n => { driverUpdateCatalogEntry.version = n.getStringValue(); },
        "versionDateTime": n => { driverUpdateCatalogEntry.versionDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDriverUpdateFilter(driverUpdateFilter: Partial<DriverUpdateFilter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWindowsUpdateFilter(driverUpdateFilter),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDurationDrivenRolloutSettings(durationDrivenRolloutSettings: Partial<DurationDrivenRolloutSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoGradualRolloutSettings(durationDrivenRolloutSettings),
        "durationUntilDeploymentEnd": n => { durationDrivenRolloutSettings.durationUntilDeploymentEnd = n.getDurationValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdition(edition: Partial<Edition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(edition),
        "deviceFamily": n => { edition.deviceFamily = n.getStringValue(); },
        "endOfServiceDateTime": n => { edition.endOfServiceDateTime = n.getDateValue(); },
        "generalAvailabilityDateTime": n => { edition.generalAvailabilityDateTime = n.getDateValue(); },
        "isInService": n => { edition.isInService = n.getBooleanValue(); },
        "name": n => { edition.name = n.getStringValue(); },
        "releasedName": n => { edition.releasedName = n.getStringValue(); },
        "servicingPeriods": n => { edition.servicingPeriods = n.getCollectionOfObjectValues<ServicingPeriod>(createServicingPeriodFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEditionCollectionResponse(editionCollectionResponse: Partial<EditionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(editionCollectionResponse),
        "value": n => { editionCollectionResponse.value = n.getCollectionOfObjectValues<Edition>(createEditionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExpediteSettings(expediteSettings: Partial<ExpediteSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { expediteSettings.backingStoreEnabled = true; },
        "isExpedited": n => { expediteSettings.isExpedited = n.getBooleanValue(); },
        "isReadinessTest": n => { expediteSettings.isReadinessTest = n.getBooleanValue(); },
        "@odata.type": n => { expediteSettings.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFeatureUpdateCatalogEntry(featureUpdateCatalogEntry: Partial<FeatureUpdateCatalogEntry> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSoftwareUpdateCatalogEntry(featureUpdateCatalogEntry),
        "buildNumber": n => { featureUpdateCatalogEntry.buildNumber = n.getStringValue(); },
        "version": n => { featureUpdateCatalogEntry.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoGradualRolloutSettings(gradualRolloutSettings: Partial<GradualRolloutSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { gradualRolloutSettings.backingStoreEnabled = true; },
        "durationBetweenOffers": n => { gradualRolloutSettings.durationBetweenOffers = n.getDurationValue(); },
        "@odata.type": n => { gradualRolloutSettings.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoItemBody(itemBody: Partial<ItemBody> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { itemBody.backingStoreEnabled = true; },
        "content": n => { itemBody.content = n.getStringValue(); },
        "contentType": n => { itemBody.contentType = n.getEnumValue<BodyType>(BodyTypeObject); },
        "@odata.type": n => { itemBody.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKnowledgeBaseArticle(knowledgeBaseArticle: Partial<KnowledgeBaseArticle> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(knowledgeBaseArticle),
        "url": n => { knowledgeBaseArticle.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKnownIssue(knownIssue: Partial<KnownIssue> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(knownIssue),
        "description": n => { knownIssue.description = n.getStringValue(); },
        "knownIssueHistories": n => { knownIssue.knownIssueHistories = n.getCollectionOfObjectValues<KnownIssueHistoryItem>(createKnownIssueHistoryItemFromDiscriminatorValue); },
        "lastUpdatedDateTime": n => { knownIssue.lastUpdatedDateTime = n.getDateValue(); },
        "originatingKnowledgeBaseArticle": n => { knownIssue.originatingKnowledgeBaseArticle = n.getObjectValue<KnowledgeBaseArticle>(createKnowledgeBaseArticleFromDiscriminatorValue); },
        "resolvedDateTime": n => { knownIssue.resolvedDateTime = n.getDateValue(); },
        "resolvingKnowledgeBaseArticle": n => { knownIssue.resolvingKnowledgeBaseArticle = n.getObjectValue<KnowledgeBaseArticle>(createKnowledgeBaseArticleFromDiscriminatorValue); },
        "safeguardHoldIds": n => { knownIssue.safeguardHoldIds = n.getCollectionOfPrimitiveValues<number>(); },
        "startDateTime": n => { knownIssue.startDateTime = n.getDateValue(); },
        "status": n => { knownIssue.status = n.getEnumValue<WindowsReleaseHealthStatus>(WindowsReleaseHealthStatusObject); },
        "title": n => { knownIssue.title = n.getStringValue(); },
        "webViewUrl": n => { knownIssue.webViewUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKnownIssueCollectionResponse(knownIssueCollectionResponse: Partial<KnownIssueCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(knownIssueCollectionResponse),
        "value": n => { knownIssueCollectionResponse.value = n.getCollectionOfObjectValues<KnownIssue>(createKnownIssueFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKnownIssueHistoryItem(knownIssueHistoryItem: Partial<KnownIssueHistoryItem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { knownIssueHistoryItem.backingStoreEnabled = true; },
        "body": n => { knownIssueHistoryItem.body = n.getObjectValue<ItemBody>(createItemBodyFromDiscriminatorValue); },
        "createdDateTime": n => { knownIssueHistoryItem.createdDateTime = n.getDateValue(); },
        "@odata.type": n => { knownIssueHistoryItem.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMonitoringRule(monitoringRule: Partial<MonitoringRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "action": n => { monitoringRule.action = n.getEnumValue<MonitoringAction>(MonitoringActionObject); },
        "backingStoreEnabled": n => { monitoringRule.backingStoreEnabled = true; },
        "@odata.type": n => { monitoringRule.odataType = n.getStringValue(); },
        "signal": n => { monitoringRule.signal = n.getEnumValue<MonitoringSignal>(MonitoringSignalObject); },
        "threshold": n => { monitoringRule.threshold = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMonitoringSettings(monitoringSettings: Partial<MonitoringSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { monitoringSettings.backingStoreEnabled = true; },
        "monitoringRules": n => { monitoringSettings.monitoringRules = n.getCollectionOfObjectValues<MonitoringRule>(createMonitoringRuleFromDiscriminatorValue); },
        "@odata.type": n => { monitoringSettings.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoOperationalInsightsConnection(operationalInsightsConnection: Partial<OperationalInsightsConnection> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoResourceConnection(operationalInsightsConnection),
        "azureResourceGroupName": n => { operationalInsightsConnection.azureResourceGroupName = n.getStringValue(); },
        "azureSubscriptionId": n => { operationalInsightsConnection.azureSubscriptionId = n.getStringValue(); },
        "workspaceName": n => { operationalInsightsConnection.workspaceName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProduct(product: Partial<Product> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(product),
        "editions": n => { product.editions = n.getCollectionOfObjectValues<Edition>(createEditionFromDiscriminatorValue); },
        "friendlyNames": n => { product.friendlyNames = n.getCollectionOfPrimitiveValues<string>(); },
        "groupName": n => { product.groupName = n.getStringValue(); },
        "knownIssues": n => { product.knownIssues = n.getCollectionOfObjectValues<KnownIssue>(createKnownIssueFromDiscriminatorValue); },
        "name": n => { product.name = n.getStringValue(); },
        "revisions": n => { product.revisions = n.getCollectionOfObjectValues<ProductRevision>(createProductRevisionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProductCollectionResponse(productCollectionResponse: Partial<ProductCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(productCollectionResponse),
        "value": n => { productCollectionResponse.value = n.getCollectionOfObjectValues<Product>(createProductFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProductRevision(productRevision: Partial<ProductRevision> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(productRevision),
        "catalogEntry": n => { productRevision.catalogEntry = n.getObjectValue<CatalogEntry>(createCatalogEntryFromDiscriminatorValue); },
        "displayName": n => { productRevision.displayName = n.getStringValue(); },
        "knowledgeBaseArticle": n => { productRevision.knowledgeBaseArticle = n.getObjectValue<KnowledgeBaseArticle>(createKnowledgeBaseArticleFromDiscriminatorValue); },
        "osBuild": n => { productRevision.osBuild = n.getObjectValue<BuildVersionDetails>(createBuildVersionDetailsFromDiscriminatorValue); },
        "product": n => { productRevision.product = n.getStringValue(); },
        "releaseDateTime": n => { productRevision.releaseDateTime = n.getDateValue(); },
        "version": n => { productRevision.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProductRevisionCollectionResponse(productRevisionCollectionResponse: Partial<ProductRevisionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(productRevisionCollectionResponse),
        "value": n => { productRevisionCollectionResponse.value = n.getCollectionOfObjectValues<ProductRevision>(createProductRevisionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoQualityUpdateCatalogEntry(qualityUpdateCatalogEntry: Partial<QualityUpdateCatalogEntry> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSoftwareUpdateCatalogEntry(qualityUpdateCatalogEntry),
        "catalogName": n => { qualityUpdateCatalogEntry.catalogName = n.getStringValue(); },
        "cveSeverityInformation": n => { qualityUpdateCatalogEntry.cveSeverityInformation = n.getObjectValue<QualityUpdateCveSeverityInformation>(createQualityUpdateCveSeverityInformationFromDiscriminatorValue); },
        "isExpeditable": n => { qualityUpdateCatalogEntry.isExpeditable = n.getBooleanValue(); },
        "productRevisions": n => { qualityUpdateCatalogEntry.productRevisions = n.getCollectionOfObjectValues<ProductRevision>(createProductRevisionFromDiscriminatorValue); },
        "qualityUpdateCadence": n => { qualityUpdateCatalogEntry.qualityUpdateCadence = n.getEnumValue<QualityUpdateCadence>(QualityUpdateCadenceObject); },
        "qualityUpdateClassification": n => { qualityUpdateCatalogEntry.qualityUpdateClassification = n.getEnumValue<QualityUpdateClassification>(QualityUpdateClassificationObject); },
        "shortName": n => { qualityUpdateCatalogEntry.shortName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoQualityUpdateCveSeverityInformation(qualityUpdateCveSeverityInformation: Partial<QualityUpdateCveSeverityInformation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { qualityUpdateCveSeverityInformation.backingStoreEnabled = true; },
        "exploitedCves": n => { qualityUpdateCveSeverityInformation.exploitedCves = n.getCollectionOfObjectValues<CveInformation>(createCveInformationFromDiscriminatorValue); },
        "maxBaseScore": n => { qualityUpdateCveSeverityInformation.maxBaseScore = n.getNumberValue(); },
        "maxSeverity": n => { qualityUpdateCveSeverityInformation.maxSeverity = n.getEnumValue<CveSeverityLevel>(CveSeverityLevelObject); },
        "@odata.type": n => { qualityUpdateCveSeverityInformation.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoQualityUpdateFilter(qualityUpdateFilter: Partial<QualityUpdateFilter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWindowsUpdateFilter(qualityUpdateFilter),
        "cadence": n => { qualityUpdateFilter.cadence = n.getEnumValue<QualityUpdateCadence>(QualityUpdateCadenceObject); },
        "classification": n => { qualityUpdateFilter.classification = n.getEnumValue<QualityUpdateClassification>(QualityUpdateClassificationObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRateDrivenRolloutSettings(rateDrivenRolloutSettings: Partial<RateDrivenRolloutSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoGradualRolloutSettings(rateDrivenRolloutSettings),
        "devicesPerOffer": n => { rateDrivenRolloutSettings.devicesPerOffer = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoResourceConnection(resourceConnection: Partial<ResourceConnection> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(resourceConnection),
        "state": n => { resourceConnection.state = n.getEnumValue<ResourceConnectionState>(ResourceConnectionStateObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoResourceConnectionCollectionResponse(resourceConnectionCollectionResponse: Partial<ResourceConnectionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(resourceConnectionCollectionResponse),
        "value": n => { resourceConnectionCollectionResponse.value = n.getCollectionOfObjectValues<ResourceConnection>(createResourceConnectionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSafeguardProfile(safeguardProfile: Partial<SafeguardProfile> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { safeguardProfile.backingStoreEnabled = true; },
        "category": n => { safeguardProfile.category = n.getEnumValue<SafeguardCategory>(SafeguardCategoryObject); },
        "@odata.type": n => { safeguardProfile.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSafeguardSettings(safeguardSettings: Partial<SafeguardSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { safeguardSettings.backingStoreEnabled = true; },
        "disabledSafeguardProfiles": n => { safeguardSettings.disabledSafeguardProfiles = n.getCollectionOfObjectValues<SafeguardProfile>(createSafeguardProfileFromDiscriminatorValue); },
        "@odata.type": n => { safeguardSettings.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoScheduleSettings(scheduleSettings: Partial<ScheduleSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { scheduleSettings.backingStoreEnabled = true; },
        "gradualRollout": n => { scheduleSettings.gradualRollout = n.getObjectValue<GradualRolloutSettings>(createGradualRolloutSettingsFromDiscriminatorValue); },
        "@odata.type": n => { scheduleSettings.odataType = n.getStringValue(); },
        "startDateTime": n => { scheduleSettings.startDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoServicingPeriod(servicingPeriod: Partial<ServicingPeriod> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { servicingPeriod.backingStoreEnabled = true; },
        "endDateTime": n => { servicingPeriod.endDateTime = n.getDateValue(); },
        "name": n => { servicingPeriod.name = n.getStringValue(); },
        "@odata.type": n => { servicingPeriod.odataType = n.getStringValue(); },
        "startDateTime": n => { servicingPeriod.startDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSoftwareUpdateCatalogEntry(softwareUpdateCatalogEntry: Partial<SoftwareUpdateCatalogEntry> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCatalogEntry(softwareUpdateCatalogEntry),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSoftwareUpdateFilter(softwareUpdateFilter: Partial<SoftwareUpdateFilter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoContentFilter(softwareUpdateFilter),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUpdatableAsset(updatableAsset: Partial<UpdatableAsset> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(updatableAsset),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUpdatableAssetCollectionResponse(updatableAssetCollectionResponse: Partial<UpdatableAssetCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(updatableAssetCollectionResponse),
        "value": n => { updatableAssetCollectionResponse.value = n.getCollectionOfObjectValues<UpdatableAsset>(createUpdatableAssetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUpdatableAssetEnrollment(updatableAssetEnrollment: Partial<UpdatableAssetEnrollment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { updatableAssetEnrollment.backingStoreEnabled = true; },
        "@odata.type": n => { updatableAssetEnrollment.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUpdatableAssetError(updatableAssetError: Partial<UpdatableAssetError> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { updatableAssetError.backingStoreEnabled = true; },
        "@odata.type": n => { updatableAssetError.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUpdatableAssetGroup(updatableAssetGroup: Partial<UpdatableAssetGroup> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUpdatableAsset(updatableAssetGroup),
        "members": n => { updatableAssetGroup.members = n.getCollectionOfObjectValues<UpdatableAsset>(createUpdatableAssetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUpdateManagementEnrollment(updateManagementEnrollment: Partial<UpdateManagementEnrollment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUpdatableAssetEnrollment(updateManagementEnrollment),
        "updateCategory": n => { updateManagementEnrollment.updateCategory = n.getEnumValue<UpdateCategory>(UpdateCategoryObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUpdatePolicy(updatePolicy: Partial<UpdatePolicy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(updatePolicy),
        "audience": n => { updatePolicy.audience = n.getObjectValue<DeploymentAudience>(createDeploymentAudienceFromDiscriminatorValue); },
        "complianceChangeRules": n => { updatePolicy.complianceChangeRules = n.getCollectionOfObjectValues<ComplianceChangeRule>(createComplianceChangeRuleFromDiscriminatorValue); },
        "complianceChanges": n => { updatePolicy.complianceChanges = n.getCollectionOfObjectValues<ComplianceChange>(createComplianceChangeFromDiscriminatorValue); },
        "createdDateTime": n => { updatePolicy.createdDateTime = n.getDateValue(); },
        "deploymentSettings": n => { updatePolicy.deploymentSettings = n.getObjectValue<DeploymentSettings>(createDeploymentSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUpdatePolicyCollectionResponse(updatePolicyCollectionResponse: Partial<UpdatePolicyCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(updatePolicyCollectionResponse),
        "value": n => { updatePolicyCollectionResponse.value = n.getCollectionOfObjectValues<UpdatePolicy>(createUpdatePolicyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserExperienceSettings(userExperienceSettings: Partial<UserExperienceSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { userExperienceSettings.backingStoreEnabled = true; },
        "daysUntilForcedReboot": n => { userExperienceSettings.daysUntilForcedReboot = n.getNumberValue(); },
        "isHotpatchEnabled": n => { userExperienceSettings.isHotpatchEnabled = n.getBooleanValue(); },
        "@odata.type": n => { userExperienceSettings.odataType = n.getStringValue(); },
        "offerAsOptional": n => { userExperienceSettings.offerAsOptional = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWindowsUpdateFilter(windowsUpdateFilter: Partial<WindowsUpdateFilter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSoftwareUpdateFilter(windowsUpdateFilter),
    }
}
export interface DriverUpdateCatalogEntry extends Parsable, SoftwareUpdateCatalogEntry {
    /**
     * The description of the content.
     */
    description?: string;
    /**
     * The classification of the driver.
     */
    driverClass?: string;
    /**
     * The manufacturer of the driver.
     */
    manufacturer?: string;
    /**
     * The provider of the driver.
     */
    provider?: string;
    /**
     * The setup information file of the driver.
     */
    setupInformationFile?: string;
    /**
     * The unique version of the content.
     */
    version?: string;
    /**
     * The date and time when a new version of content was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    versionDateTime?: Date;
}
export interface DriverUpdateFilter extends Parsable, WindowsUpdateFilter {
}
export interface DurationDrivenRolloutSettings extends GradualRolloutSettings, Parsable {
    /**
     * The target duration of the rollout. Given durationBetweenOffers and durationUntilDeploymentEnd, the system will automatically calculate how many devices are in each offering.
     */
    durationUntilDeploymentEnd?: Duration;
}
export interface Edition extends Entity, Parsable {
    /**
     * The device family targeted by the edition.
     */
    deviceFamily?: string;
    /**
     * The date and time when the edition reached the end of service. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    endOfServiceDateTime?: Date;
    /**
     * The date and time when the edition became available to the general customers for the first time. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    generalAvailabilityDateTime?: Date;
    /**
     * Indicates whether the edition is in service or out of service.
     */
    isInService?: boolean;
    /**
     * The name of the edition. Read-only.
     */
    name?: string;
    /**
     * The public name of the edition. Read-only.
     */
    releasedName?: string;
    /**
     * The servicingPeriods property
     */
    servicingPeriods?: ServicingPeriod[];
}
export interface EditionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Edition[];
}
export interface ExpediteSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * True indicates that the deployment of the content is expedited.
     */
    isExpedited?: boolean;
    /**
     * True indicates that the deployment is an expedite readiness test.
     */
    isReadinessTest?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface FeatureUpdateCatalogEntry extends Parsable, SoftwareUpdateCatalogEntry {
    /**
     * The build number of the feature update. Read-only.
     */
    buildNumber?: string;
    /**
     * The version of the feature update. Read-only.
     */
    version?: string;
}
export interface GradualRolloutSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The duration between each set of devices being offered the update. The value is represented in ISO 8601 format for duration. Default value is P1D (one day).
     */
    durationBetweenOffers?: Duration;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface ItemBody extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The content of the item.
     */
    content?: string;
    /**
     * The type of the content indicated by the enum value of bodyType. Possible values are: text, html, unknownFutureValue.
     */
    contentType?: BodyType;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface KnowledgeBaseArticle extends Entity, Parsable {
    /**
     * The URL of the knowledge base article. Read-only.
     */
    url?: string;
}
export interface KnownIssue extends Entity, Parsable {
    /**
     * The description of the particular known issue.
     */
    description?: string;
    /**
     * The knownIssueHistories property
     */
    knownIssueHistories?: KnownIssueHistoryItem[];
    /**
     * The date and time when the known issue was last updated. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    lastUpdatedDateTime?: Date;
    /**
     * Knowledge base article associated with the release when the known issue was first reported.
     */
    originatingKnowledgeBaseArticle?: KnowledgeBaseArticle;
    /**
     * The date and time when the known issue was resolved or mitigated. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    resolvedDateTime?: Date;
    /**
     * Knowledge base article associated with the release when the known issue was resolved or mitigated.
     */
    resolvingKnowledgeBaseArticle?: KnowledgeBaseArticle;
    /**
     * The safeguardHoldIds property
     */
    safeguardHoldIds?: number[];
    /**
     * The date and time when the known issue was first reported. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    startDateTime?: Date;
    /**
     * The status property
     */
    status?: WindowsReleaseHealthStatus;
    /**
     * The title of the known issue.
     */
    title?: string;
    /**
     * The URL to the known issue in the Windows Release Health dashboard on Microsoft 365 admin center.
     */
    webViewUrl?: string;
}
export interface KnownIssueCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: KnownIssue[];
}
export interface KnownIssueHistoryItem extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The body property
     */
    body?: ItemBody;
    /**
     * The date and time when the post was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    createdDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type MonitoringAction = (typeof MonitoringActionObject)[keyof typeof MonitoringActionObject];
export interface MonitoringRule extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The action triggered when the threshold for the given signal is reached. Possible values are: alertError, pauseDeployment, offerFallback, unknownFutureValue. The offerFallback member is only supported on feature update deployments of Windows 11 and must be paired with the ineligible signal. The fallback version offered is the version 22H2 of Windows 10.
     */
    action?: MonitoringAction;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The signal to monitor. Possible values are: rollback, ineligible, unknownFutureValue. The ineligible member is only supported on feature update deployments of Windows 11 and must be paired with the offerFallback action.
     */
    signal?: MonitoringSignal;
    /**
     * The threshold for a signal at which to trigger the action. An integer from 1 to 100 (inclusive). This value is ignored when the signal is ineligible and the action is offerFallback.
     */
    threshold?: number;
}
export interface MonitoringSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Specifies the rules through which monitoring signals can trigger actions on the deployment. Rules are combined using 'or.'
     */
    monitoringRules?: MonitoringRule[];
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type MonitoringSignal = (typeof MonitoringSignalObject)[keyof typeof MonitoringSignalObject];
export interface OperationalInsightsConnection extends Parsable, ResourceConnection {
    /**
     * The name of the Azure resource group that contains the Log Analytics workspace.
     */
    azureResourceGroupName?: string;
    /**
     * The Azure subscription ID that contains the Log Analytics workspace.
     */
    azureSubscriptionId?: string;
    /**
     * The name of the Log Analytics workspace.
     */
    workspaceName?: string;
}
export interface Product extends Entity, Parsable {
    /**
     * Represents an edition of a particular Windows product.
     */
    editions?: Edition[];
    /**
     * The friendly names of the product. For example, Version 22H2 (OS build 22621). Read-only.
     */
    friendlyNames?: string[];
    /**
     * The name of the product group. For example, Windows 11. Read-only.
     */
    groupName?: string;
    /**
     * Represents a known issue related to a Windows product.
     */
    knownIssues?: KnownIssue[];
    /**
     * The name of the product. For example, Windows 11, version 22H2. Read-only.
     */
    name?: string;
    /**
     * Represents a product revision.
     */
    revisions?: ProductRevision[];
}
export interface ProductCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Product[];
}
export interface ProductRevision extends Entity, Parsable {
    /**
     * The catalogEntry property
     */
    catalogEntry?: CatalogEntry;
    /**
     * The display name of the content. Read-only.
     */
    displayName?: string;
    /**
     * The knowledge base article associated with the product revision.
     */
    knowledgeBaseArticle?: KnowledgeBaseArticle;
    /**
     * The osBuild property
     */
    osBuild?: BuildVersionDetails;
    /**
     * The product of the revision. Possible values are: Windows 10, Windows 11. Read-only.
     */
    product?: string;
    /**
     * The release date for the content. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    releaseDateTime?: Date;
    /**
     * The version of the feature update. Read-only.
     */
    version?: string;
}
export interface ProductRevisionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ProductRevision[];
}
export type QualityUpdateCadence = (typeof QualityUpdateCadenceObject)[keyof typeof QualityUpdateCadenceObject];
export interface QualityUpdateCatalogEntry extends Parsable, SoftwareUpdateCatalogEntry {
    /**
     * The catalog name of the content. Read-only.
     */
    catalogName?: string;
    /**
     * Severity information of the Common Vulnerabilities and Exposures associated with the content.
     */
    cveSeverityInformation?: QualityUpdateCveSeverityInformation;
    /**
     * Indicates whether the content can be deployed as an expedited quality update. Read-only.
     */
    isExpeditable?: boolean;
    /**
     * The operating system product revisions that are released as part of this quality update.
     */
    productRevisions?: ProductRevision[];
    /**
     * The publishing cadence of the quality update. Possible values are: monthly, outOfBand, unknownFutureValue. Read-only.
     */
    qualityUpdateCadence?: QualityUpdateCadence;
    /**
     * The qualityUpdateClassification property
     */
    qualityUpdateClassification?: QualityUpdateClassification;
    /**
     * The short name of the content. Read-only.
     */
    shortName?: string;
}
export type QualityUpdateClassification = (typeof QualityUpdateClassificationObject)[keyof typeof QualityUpdateClassificationObject];
export interface QualityUpdateCveSeverityInformation extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The exploitedCves property
     */
    exploitedCves?: CveInformation[];
    /**
     * Highest base score that occurs of any CVE addressed by the quality update. Read-only.
     */
    maxBaseScore?: number;
    /**
     * The maxSeverity property
     */
    maxSeverity?: CveSeverityLevel;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface QualityUpdateFilter extends Parsable, WindowsUpdateFilter {
    /**
     * The cadence property
     */
    cadence?: QualityUpdateCadence;
    /**
     * The classification property
     */
    classification?: QualityUpdateClassification;
}
export interface RateDrivenRolloutSettings extends GradualRolloutSettings, Parsable {
    /**
     * Specifies the number of devices that are offered at the same time. When not set, all devices in the deployment are offered content at the same time.
     */
    devicesPerOffer?: number;
}
export type RequestedDeploymentStateValue = (typeof RequestedDeploymentStateValueObject)[keyof typeof RequestedDeploymentStateValueObject];
export interface ResourceConnection extends Entity, Parsable {
    /**
     * The state of the connection. The possible values are: connected, notAuthorized, notFound, unknownFutureValue.
     */
    state?: ResourceConnectionState;
}
export interface ResourceConnectionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ResourceConnection[];
}
export type ResourceConnectionState = (typeof ResourceConnectionStateObject)[keyof typeof ResourceConnectionStateObject];
export type SafeguardCategory = (typeof SafeguardCategoryObject)[keyof typeof SafeguardCategoryObject];
export interface SafeguardProfile extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Specifies the category of safeguards. The possible values are: likelyIssues, unknownFutureValue.
     */
    category?: SafeguardCategory;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface SafeguardSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * List of safeguards to ignore per device.
     */
    disabledSafeguardProfiles?: SafeguardProfile[];
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface ScheduleSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Settings for governing how to rollout content to devices. One of: microsoft.graph.windowsUpdates.dateDrivenRolloutSettings, microsoft.graph.windowsUpdates.durationDrivenRolloutSettings, or microsoft.graph.windowsUpdates.rateDrivenRolloutSettings.
     */
    gradualRollout?: GradualRolloutSettings;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The date on which devices in the deployment start receiving the update. When not set, the deployment starts as soon as devices are assigned. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    startDateTime?: Date;
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeApplicableContent(writer: SerializationWriter, applicableContent: Partial<ApplicableContent> | undefined = {}) : void {
    writer.writeObjectValue<CatalogEntry>("catalogEntry", applicableContent.catalogEntry, serializeCatalogEntry);
    writer.writeStringValue("catalogEntryId", applicableContent.catalogEntryId);
    writer.writeCollectionOfObjectValues<ApplicableContentDeviceMatch>("matchedDevices", applicableContent.matchedDevices, serializeApplicableContentDeviceMatch);
    writer.writeStringValue("@odata.type", applicableContent.odataType);
    writer.writeAdditionalData(applicableContent.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeApplicableContentCollectionResponse(writer: SerializationWriter, applicableContentCollectionResponse: Partial<ApplicableContentCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, applicableContentCollectionResponse)
    writer.writeCollectionOfObjectValues<ApplicableContent>("value", applicableContentCollectionResponse.value, serializeApplicableContent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeApplicableContentDeviceMatch(writer: SerializationWriter, applicableContentDeviceMatch: Partial<ApplicableContentDeviceMatch> | undefined = {}) : void {
    writer.writeStringValue("deviceId", applicableContentDeviceMatch.deviceId);
    writer.writeStringValue("@odata.type", applicableContentDeviceMatch.odataType);
    writer.writeCollectionOfPrimitiveValues<string>("recommendedBy", applicableContentDeviceMatch.recommendedBy);
    writer.writeAdditionalData(applicableContentDeviceMatch.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeApplicableContentDeviceMatchCollectionResponse(writer: SerializationWriter, applicableContentDeviceMatchCollectionResponse: Partial<ApplicableContentDeviceMatchCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, applicableContentDeviceMatchCollectionResponse)
    writer.writeCollectionOfObjectValues<ApplicableContentDeviceMatch>("value", applicableContentDeviceMatchCollectionResponse.value, serializeApplicableContentDeviceMatch);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAzureADDevice(writer: SerializationWriter, azureADDevice: Partial<AzureADDevice> | undefined = {}) : void {
    serializeUpdatableAsset(writer, azureADDevice)
    writer.writeCollectionOfObjectValues<UpdatableAssetEnrollment>("enrollments", azureADDevice.enrollments, serializeUpdatableAssetEnrollment);
    writer.writeCollectionOfObjectValues<UpdatableAssetError>("errors", azureADDevice.errors, serializeUpdatableAssetError);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAzureADDeviceRegistrationError(writer: SerializationWriter, azureADDeviceRegistrationError: Partial<AzureADDeviceRegistrationError> | undefined = {}) : void {
    serializeUpdatableAssetError(writer, azureADDeviceRegistrationError)
    writer.writeEnumValue<AzureADDeviceRegistrationErrorReason>("reason", azureADDeviceRegistrationError.reason);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeBuildVersionDetails(writer: SerializationWriter, buildVersionDetails: Partial<BuildVersionDetails> | undefined = {}) : void {
    writer.writeNumberValue("buildNumber", buildVersionDetails.buildNumber);
    writer.writeNumberValue("majorVersion", buildVersionDetails.majorVersion);
    writer.writeNumberValue("minorVersion", buildVersionDetails.minorVersion);
    writer.writeStringValue("@odata.type", buildVersionDetails.odataType);
    writer.writeNumberValue("updateBuildRevision", buildVersionDetails.updateBuildRevision);
    writer.writeAdditionalData(buildVersionDetails.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCatalog(writer: SerializationWriter, catalog: Partial<Catalog> | undefined = {}) : void {
    serializeEntity(writer, catalog)
    writer.writeCollectionOfObjectValues<CatalogEntry>("entries", catalog.entries, serializeCatalogEntry);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCatalogContent(writer: SerializationWriter, catalogContent: Partial<CatalogContent> | undefined = {}) : void {
    serializeDeployableContent(writer, catalogContent)
    writer.writeObjectValue<CatalogEntry>("catalogEntry", catalogContent.catalogEntry, serializeCatalogEntry);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCatalogEntry(writer: SerializationWriter, catalogEntry: Partial<CatalogEntry> | undefined = {}) : void {
    serializeEntity(writer, catalogEntry)
    writer.writeDateValue("deployableUntilDateTime", catalogEntry.deployableUntilDateTime);
    writer.writeStringValue("displayName", catalogEntry.displayName);
    writer.writeDateValue("releaseDateTime", catalogEntry.releaseDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCatalogEntryCollectionResponse(writer: SerializationWriter, catalogEntryCollectionResponse: Partial<CatalogEntryCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, catalogEntryCollectionResponse)
    writer.writeCollectionOfObjectValues<CatalogEntry>("value", catalogEntryCollectionResponse.value, serializeCatalogEntry);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeComplianceChange(writer: SerializationWriter, complianceChange: Partial<ComplianceChange> | undefined = {}) : void {
    serializeEntity(writer, complianceChange)
    writer.writeDateValue("createdDateTime", complianceChange.createdDateTime);
    writer.writeBooleanValue("isRevoked", complianceChange.isRevoked);
    writer.writeDateValue("revokedDateTime", complianceChange.revokedDateTime);
    writer.writeObjectValue<UpdatePolicy>("updatePolicy", complianceChange.updatePolicy, serializeUpdatePolicy);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeComplianceChangeCollectionResponse(writer: SerializationWriter, complianceChangeCollectionResponse: Partial<ComplianceChangeCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, complianceChangeCollectionResponse)
    writer.writeCollectionOfObjectValues<ComplianceChange>("value", complianceChangeCollectionResponse.value, serializeComplianceChange);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeComplianceChangeRule(writer: SerializationWriter, complianceChangeRule: Partial<ComplianceChangeRule> | undefined = {}) : void {
    writer.writeDateValue("createdDateTime", complianceChangeRule.createdDateTime);
    writer.writeDateValue("lastEvaluatedDateTime", complianceChangeRule.lastEvaluatedDateTime);
    writer.writeDateValue("lastModifiedDateTime", complianceChangeRule.lastModifiedDateTime);
    writer.writeStringValue("@odata.type", complianceChangeRule.odataType);
    writer.writeAdditionalData(complianceChangeRule.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContentApplicabilitySettings(writer: SerializationWriter, contentApplicabilitySettings: Partial<ContentApplicabilitySettings> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", contentApplicabilitySettings.odataType);
    writer.writeCollectionOfPrimitiveValues<string>("offerWhileRecommendedBy", contentApplicabilitySettings.offerWhileRecommendedBy);
    writer.writeObjectValue<SafeguardSettings>("safeguard", contentApplicabilitySettings.safeguard, serializeSafeguardSettings);
    writer.writeAdditionalData(contentApplicabilitySettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContentApproval(writer: SerializationWriter, contentApproval: Partial<ContentApproval> | undefined = {}) : void {
    serializeComplianceChange(writer, contentApproval)
    writer.writeObjectValue<DeployableContent>("content", contentApproval.content, serializeDeployableContent);
    writer.writeCollectionOfObjectValues<Deployment>("deployments", contentApproval.deployments, serializeDeployment);
    writer.writeObjectValue<DeploymentSettings>("deploymentSettings", contentApproval.deploymentSettings, serializeDeploymentSettings);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContentApprovalRule(writer: SerializationWriter, contentApprovalRule: Partial<ContentApprovalRule> | undefined = {}) : void {
    serializeComplianceChangeRule(writer, contentApprovalRule)
    writer.writeObjectValue<ContentFilter>("contentFilter", contentApprovalRule.contentFilter, serializeContentFilter);
    writer.writeDurationValue("durationBeforeDeploymentStart", contentApprovalRule.durationBeforeDeploymentStart);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContentFilter(writer: SerializationWriter, contentFilter: Partial<ContentFilter> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", contentFilter.odataType);
    writer.writeAdditionalData(contentFilter.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCveInformation(writer: SerializationWriter, cveInformation: Partial<CveInformation> | undefined = {}) : void {
    writer.writeStringValue("number", cveInformation.number);
    writer.writeStringValue("@odata.type", cveInformation.odataType);
    writer.writeStringValue("url", cveInformation.url);
    writer.writeAdditionalData(cveInformation.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDateDrivenRolloutSettings(writer: SerializationWriter, dateDrivenRolloutSettings: Partial<DateDrivenRolloutSettings> | undefined = {}) : void {
    serializeGradualRolloutSettings(writer, dateDrivenRolloutSettings)
    writer.writeDateValue("endDateTime", dateDrivenRolloutSettings.endDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeployableContent(writer: SerializationWriter, deployableContent: Partial<DeployableContent> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", deployableContent.odataType);
    writer.writeAdditionalData(deployableContent.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeployment(writer: SerializationWriter, deployment: Partial<Deployment> | undefined = {}) : void {
    serializeEntity(writer, deployment)
    writer.writeObjectValue<DeploymentAudience>("audience", deployment.audience, serializeDeploymentAudience);
    writer.writeObjectValue<DeployableContent>("content", deployment.content, serializeDeployableContent);
    writer.writeDateValue("createdDateTime", deployment.createdDateTime);
    writer.writeDateValue("lastModifiedDateTime", deployment.lastModifiedDateTime);
    writer.writeObjectValue<DeploymentSettings>("settings", deployment.settings, serializeDeploymentSettings);
    writer.writeObjectValue<DeploymentState>("state", deployment.state, serializeDeploymentState);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeploymentAudience(writer: SerializationWriter, deploymentAudience: Partial<DeploymentAudience> | undefined = {}) : void {
    serializeEntity(writer, deploymentAudience)
    writer.writeCollectionOfObjectValues<ApplicableContent>("applicableContent", deploymentAudience.applicableContent, serializeApplicableContent);
    writer.writeCollectionOfObjectValues<UpdatableAsset>("exclusions", deploymentAudience.exclusions, serializeUpdatableAsset);
    writer.writeCollectionOfObjectValues<UpdatableAsset>("members", deploymentAudience.members, serializeUpdatableAsset);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeploymentAudienceCollectionResponse(writer: SerializationWriter, deploymentAudienceCollectionResponse: Partial<DeploymentAudienceCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, deploymentAudienceCollectionResponse)
    writer.writeCollectionOfObjectValues<DeploymentAudience>("value", deploymentAudienceCollectionResponse.value, serializeDeploymentAudience);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeploymentCollectionResponse(writer: SerializationWriter, deploymentCollectionResponse: Partial<DeploymentCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, deploymentCollectionResponse)
    writer.writeCollectionOfObjectValues<Deployment>("value", deploymentCollectionResponse.value, serializeDeployment);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeploymentSettings(writer: SerializationWriter, deploymentSettings: Partial<DeploymentSettings> | undefined = {}) : void {
    writer.writeObjectValue<ContentApplicabilitySettings>("contentApplicability", deploymentSettings.contentApplicability, serializeContentApplicabilitySettings);
    writer.writeObjectValue<ExpediteSettings>("expedite", deploymentSettings.expedite, serializeExpediteSettings);
    writer.writeObjectValue<MonitoringSettings>("monitoring", deploymentSettings.monitoring, serializeMonitoringSettings);
    writer.writeStringValue("@odata.type", deploymentSettings.odataType);
    writer.writeObjectValue<ScheduleSettings>("schedule", deploymentSettings.schedule, serializeScheduleSettings);
    writer.writeObjectValue<UserExperienceSettings>("userExperience", deploymentSettings.userExperience, serializeUserExperienceSettings);
    writer.writeAdditionalData(deploymentSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeploymentState(writer: SerializationWriter, deploymentState: Partial<DeploymentState> | undefined = {}) : void {
    writer.writeEnumValue<DeploymentStateValue>("effectiveValue", deploymentState.effectiveValue);
    writer.writeStringValue("@odata.type", deploymentState.odataType);
    writer.writeCollectionOfObjectValues<DeploymentStateReason>("reasons", deploymentState.reasons, serializeDeploymentStateReason);
    writer.writeEnumValue<RequestedDeploymentStateValue>("requestedValue", deploymentState.requestedValue);
    writer.writeAdditionalData(deploymentState.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeploymentStateReason(writer: SerializationWriter, deploymentStateReason: Partial<DeploymentStateReason> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", deploymentStateReason.odataType);
    writer.writeEnumValue<DeploymentStateReasonValue>("value", deploymentStateReason.value);
    writer.writeAdditionalData(deploymentStateReason.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDriverUpdateCatalogEntry(writer: SerializationWriter, driverUpdateCatalogEntry: Partial<DriverUpdateCatalogEntry> | undefined = {}) : void {
    serializeSoftwareUpdateCatalogEntry(writer, driverUpdateCatalogEntry)
    writer.writeStringValue("description", driverUpdateCatalogEntry.description);
    writer.writeStringValue("driverClass", driverUpdateCatalogEntry.driverClass);
    writer.writeStringValue("manufacturer", driverUpdateCatalogEntry.manufacturer);
    writer.writeStringValue("provider", driverUpdateCatalogEntry.provider);
    writer.writeStringValue("setupInformationFile", driverUpdateCatalogEntry.setupInformationFile);
    writer.writeStringValue("version", driverUpdateCatalogEntry.version);
    writer.writeDateValue("versionDateTime", driverUpdateCatalogEntry.versionDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDriverUpdateFilter(writer: SerializationWriter, driverUpdateFilter: Partial<DriverUpdateFilter> | undefined = {}) : void {
    serializeWindowsUpdateFilter(writer, driverUpdateFilter)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDurationDrivenRolloutSettings(writer: SerializationWriter, durationDrivenRolloutSettings: Partial<DurationDrivenRolloutSettings> | undefined = {}) : void {
    serializeGradualRolloutSettings(writer, durationDrivenRolloutSettings)
    writer.writeDurationValue("durationUntilDeploymentEnd", durationDrivenRolloutSettings.durationUntilDeploymentEnd);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdition(writer: SerializationWriter, edition: Partial<Edition> | undefined = {}) : void {
    serializeEntity(writer, edition)
    writer.writeStringValue("deviceFamily", edition.deviceFamily);
    writer.writeDateValue("endOfServiceDateTime", edition.endOfServiceDateTime);
    writer.writeDateValue("generalAvailabilityDateTime", edition.generalAvailabilityDateTime);
    writer.writeBooleanValue("isInService", edition.isInService);
    writer.writeStringValue("name", edition.name);
    writer.writeStringValue("releasedName", edition.releasedName);
    writer.writeCollectionOfObjectValues<ServicingPeriod>("servicingPeriods", edition.servicingPeriods, serializeServicingPeriod);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEditionCollectionResponse(writer: SerializationWriter, editionCollectionResponse: Partial<EditionCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, editionCollectionResponse)
    writer.writeCollectionOfObjectValues<Edition>("value", editionCollectionResponse.value, serializeEdition);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExpediteSettings(writer: SerializationWriter, expediteSettings: Partial<ExpediteSettings> | undefined = {}) : void {
    writer.writeBooleanValue("isExpedited", expediteSettings.isExpedited);
    writer.writeBooleanValue("isReadinessTest", expediteSettings.isReadinessTest);
    writer.writeStringValue("@odata.type", expediteSettings.odataType);
    writer.writeAdditionalData(expediteSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFeatureUpdateCatalogEntry(writer: SerializationWriter, featureUpdateCatalogEntry: Partial<FeatureUpdateCatalogEntry> | undefined = {}) : void {
    serializeSoftwareUpdateCatalogEntry(writer, featureUpdateCatalogEntry)
    writer.writeStringValue("buildNumber", featureUpdateCatalogEntry.buildNumber);
    writer.writeStringValue("version", featureUpdateCatalogEntry.version);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeGradualRolloutSettings(writer: SerializationWriter, gradualRolloutSettings: Partial<GradualRolloutSettings> | undefined = {}) : void {
    writer.writeDurationValue("durationBetweenOffers", gradualRolloutSettings.durationBetweenOffers);
    writer.writeStringValue("@odata.type", gradualRolloutSettings.odataType);
    writer.writeAdditionalData(gradualRolloutSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeItemBody(writer: SerializationWriter, itemBody: Partial<ItemBody> | undefined = {}) : void {
    writer.writeStringValue("content", itemBody.content);
    writer.writeEnumValue<BodyType>("contentType", itemBody.contentType);
    writer.writeStringValue("@odata.type", itemBody.odataType);
    writer.writeAdditionalData(itemBody.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKnowledgeBaseArticle(writer: SerializationWriter, knowledgeBaseArticle: Partial<KnowledgeBaseArticle> | undefined = {}) : void {
    serializeEntity(writer, knowledgeBaseArticle)
    writer.writeStringValue("url", knowledgeBaseArticle.url);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKnownIssue(writer: SerializationWriter, knownIssue: Partial<KnownIssue> | undefined = {}) : void {
    serializeEntity(writer, knownIssue)
    writer.writeStringValue("description", knownIssue.description);
    writer.writeCollectionOfObjectValues<KnownIssueHistoryItem>("knownIssueHistories", knownIssue.knownIssueHistories, serializeKnownIssueHistoryItem);
    writer.writeDateValue("lastUpdatedDateTime", knownIssue.lastUpdatedDateTime);
    writer.writeObjectValue<KnowledgeBaseArticle>("originatingKnowledgeBaseArticle", knownIssue.originatingKnowledgeBaseArticle, serializeKnowledgeBaseArticle);
    writer.writeDateValue("resolvedDateTime", knownIssue.resolvedDateTime);
    writer.writeObjectValue<KnowledgeBaseArticle>("resolvingKnowledgeBaseArticle", knownIssue.resolvingKnowledgeBaseArticle, serializeKnowledgeBaseArticle);
    writer.writeCollectionOfPrimitiveValues<number>("safeguardHoldIds", knownIssue.safeguardHoldIds);
    writer.writeDateValue("startDateTime", knownIssue.startDateTime);
    writer.writeEnumValue<WindowsReleaseHealthStatus>("status", knownIssue.status);
    writer.writeStringValue("title", knownIssue.title);
    writer.writeStringValue("webViewUrl", knownIssue.webViewUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKnownIssueCollectionResponse(writer: SerializationWriter, knownIssueCollectionResponse: Partial<KnownIssueCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, knownIssueCollectionResponse)
    writer.writeCollectionOfObjectValues<KnownIssue>("value", knownIssueCollectionResponse.value, serializeKnownIssue);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKnownIssueHistoryItem(writer: SerializationWriter, knownIssueHistoryItem: Partial<KnownIssueHistoryItem> | undefined = {}) : void {
    writer.writeObjectValue<ItemBody>("body", knownIssueHistoryItem.body, serializeItemBody);
    writer.writeDateValue("createdDateTime", knownIssueHistoryItem.createdDateTime);
    writer.writeStringValue("@odata.type", knownIssueHistoryItem.odataType);
    writer.writeAdditionalData(knownIssueHistoryItem.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMonitoringRule(writer: SerializationWriter, monitoringRule: Partial<MonitoringRule> | undefined = {}) : void {
    writer.writeEnumValue<MonitoringAction>("action", monitoringRule.action);
    writer.writeStringValue("@odata.type", monitoringRule.odataType);
    writer.writeEnumValue<MonitoringSignal>("signal", monitoringRule.signal);
    writer.writeNumberValue("threshold", monitoringRule.threshold);
    writer.writeAdditionalData(monitoringRule.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMonitoringSettings(writer: SerializationWriter, monitoringSettings: Partial<MonitoringSettings> | undefined = {}) : void {
    writer.writeCollectionOfObjectValues<MonitoringRule>("monitoringRules", monitoringSettings.monitoringRules, serializeMonitoringRule);
    writer.writeStringValue("@odata.type", monitoringSettings.odataType);
    writer.writeAdditionalData(monitoringSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOperationalInsightsConnection(writer: SerializationWriter, operationalInsightsConnection: Partial<OperationalInsightsConnection> | undefined = {}) : void {
    serializeResourceConnection(writer, operationalInsightsConnection)
    writer.writeStringValue("azureResourceGroupName", operationalInsightsConnection.azureResourceGroupName);
    writer.writeStringValue("azureSubscriptionId", operationalInsightsConnection.azureSubscriptionId);
    writer.writeStringValue("workspaceName", operationalInsightsConnection.workspaceName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProduct(writer: SerializationWriter, product: Partial<Product> | undefined = {}) : void {
    serializeEntity(writer, product)
    writer.writeCollectionOfObjectValues<Edition>("editions", product.editions, serializeEdition);
    writer.writeCollectionOfPrimitiveValues<string>("friendlyNames", product.friendlyNames);
    writer.writeStringValue("groupName", product.groupName);
    writer.writeCollectionOfObjectValues<KnownIssue>("knownIssues", product.knownIssues, serializeKnownIssue);
    writer.writeStringValue("name", product.name);
    writer.writeCollectionOfObjectValues<ProductRevision>("revisions", product.revisions, serializeProductRevision);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProductCollectionResponse(writer: SerializationWriter, productCollectionResponse: Partial<ProductCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, productCollectionResponse)
    writer.writeCollectionOfObjectValues<Product>("value", productCollectionResponse.value, serializeProduct);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProductRevision(writer: SerializationWriter, productRevision: Partial<ProductRevision> | undefined = {}) : void {
    serializeEntity(writer, productRevision)
    writer.writeObjectValue<CatalogEntry>("catalogEntry", productRevision.catalogEntry, serializeCatalogEntry);
    writer.writeStringValue("displayName", productRevision.displayName);
    writer.writeObjectValue<KnowledgeBaseArticle>("knowledgeBaseArticle", productRevision.knowledgeBaseArticle, serializeKnowledgeBaseArticle);
    writer.writeObjectValue<BuildVersionDetails>("osBuild", productRevision.osBuild, serializeBuildVersionDetails);
    writer.writeStringValue("product", productRevision.product);
    writer.writeDateValue("releaseDateTime", productRevision.releaseDateTime);
    writer.writeStringValue("version", productRevision.version);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProductRevisionCollectionResponse(writer: SerializationWriter, productRevisionCollectionResponse: Partial<ProductRevisionCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, productRevisionCollectionResponse)
    writer.writeCollectionOfObjectValues<ProductRevision>("value", productRevisionCollectionResponse.value, serializeProductRevision);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeQualityUpdateCatalogEntry(writer: SerializationWriter, qualityUpdateCatalogEntry: Partial<QualityUpdateCatalogEntry> | undefined = {}) : void {
    serializeSoftwareUpdateCatalogEntry(writer, qualityUpdateCatalogEntry)
    writer.writeStringValue("catalogName", qualityUpdateCatalogEntry.catalogName);
    writer.writeObjectValue<QualityUpdateCveSeverityInformation>("cveSeverityInformation", qualityUpdateCatalogEntry.cveSeverityInformation, serializeQualityUpdateCveSeverityInformation);
    writer.writeBooleanValue("isExpeditable", qualityUpdateCatalogEntry.isExpeditable);
    writer.writeCollectionOfObjectValues<ProductRevision>("productRevisions", qualityUpdateCatalogEntry.productRevisions, serializeProductRevision);
    writer.writeEnumValue<QualityUpdateCadence>("qualityUpdateCadence", qualityUpdateCatalogEntry.qualityUpdateCadence);
    writer.writeEnumValue<QualityUpdateClassification>("qualityUpdateClassification", qualityUpdateCatalogEntry.qualityUpdateClassification);
    writer.writeStringValue("shortName", qualityUpdateCatalogEntry.shortName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeQualityUpdateCveSeverityInformation(writer: SerializationWriter, qualityUpdateCveSeverityInformation: Partial<QualityUpdateCveSeverityInformation> | undefined = {}) : void {
    writer.writeCollectionOfObjectValues<CveInformation>("exploitedCves", qualityUpdateCveSeverityInformation.exploitedCves, serializeCveInformation);
    writer.writeNumberValue("maxBaseScore", qualityUpdateCveSeverityInformation.maxBaseScore);
    writer.writeEnumValue<CveSeverityLevel>("maxSeverity", qualityUpdateCveSeverityInformation.maxSeverity);
    writer.writeStringValue("@odata.type", qualityUpdateCveSeverityInformation.odataType);
    writer.writeAdditionalData(qualityUpdateCveSeverityInformation.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeQualityUpdateFilter(writer: SerializationWriter, qualityUpdateFilter: Partial<QualityUpdateFilter> | undefined = {}) : void {
    serializeWindowsUpdateFilter(writer, qualityUpdateFilter)
    writer.writeEnumValue<QualityUpdateCadence>("cadence", qualityUpdateFilter.cadence);
    writer.writeEnumValue<QualityUpdateClassification>("classification", qualityUpdateFilter.classification);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRateDrivenRolloutSettings(writer: SerializationWriter, rateDrivenRolloutSettings: Partial<RateDrivenRolloutSettings> | undefined = {}) : void {
    serializeGradualRolloutSettings(writer, rateDrivenRolloutSettings)
    writer.writeNumberValue("devicesPerOffer", rateDrivenRolloutSettings.devicesPerOffer);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeResourceConnection(writer: SerializationWriter, resourceConnection: Partial<ResourceConnection> | undefined = {}) : void {
    serializeEntity(writer, resourceConnection)
    writer.writeEnumValue<ResourceConnectionState>("state", resourceConnection.state);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeResourceConnectionCollectionResponse(writer: SerializationWriter, resourceConnectionCollectionResponse: Partial<ResourceConnectionCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, resourceConnectionCollectionResponse)
    writer.writeCollectionOfObjectValues<ResourceConnection>("value", resourceConnectionCollectionResponse.value, serializeResourceConnection);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSafeguardProfile(writer: SerializationWriter, safeguardProfile: Partial<SafeguardProfile> | undefined = {}) : void {
    writer.writeEnumValue<SafeguardCategory>("category", safeguardProfile.category);
    writer.writeStringValue("@odata.type", safeguardProfile.odataType);
    writer.writeAdditionalData(safeguardProfile.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSafeguardSettings(writer: SerializationWriter, safeguardSettings: Partial<SafeguardSettings> | undefined = {}) : void {
    writer.writeCollectionOfObjectValues<SafeguardProfile>("disabledSafeguardProfiles", safeguardSettings.disabledSafeguardProfiles, serializeSafeguardProfile);
    writer.writeStringValue("@odata.type", safeguardSettings.odataType);
    writer.writeAdditionalData(safeguardSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeScheduleSettings(writer: SerializationWriter, scheduleSettings: Partial<ScheduleSettings> | undefined = {}) : void {
    writer.writeObjectValue<GradualRolloutSettings>("gradualRollout", scheduleSettings.gradualRollout, serializeGradualRolloutSettings);
    writer.writeStringValue("@odata.type", scheduleSettings.odataType);
    writer.writeDateValue("startDateTime", scheduleSettings.startDateTime);
    writer.writeAdditionalData(scheduleSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeServicingPeriod(writer: SerializationWriter, servicingPeriod: Partial<ServicingPeriod> | undefined = {}) : void {
    writer.writeDateValue("endDateTime", servicingPeriod.endDateTime);
    writer.writeStringValue("name", servicingPeriod.name);
    writer.writeStringValue("@odata.type", servicingPeriod.odataType);
    writer.writeDateValue("startDateTime", servicingPeriod.startDateTime);
    writer.writeAdditionalData(servicingPeriod.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSoftwareUpdateCatalogEntry(writer: SerializationWriter, softwareUpdateCatalogEntry: Partial<SoftwareUpdateCatalogEntry> | undefined = {}) : void {
    serializeCatalogEntry(writer, softwareUpdateCatalogEntry)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSoftwareUpdateFilter(writer: SerializationWriter, softwareUpdateFilter: Partial<SoftwareUpdateFilter> | undefined = {}) : void {
    serializeContentFilter(writer, softwareUpdateFilter)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUpdatableAsset(writer: SerializationWriter, updatableAsset: Partial<UpdatableAsset> | undefined = {}) : void {
    serializeEntity(writer, updatableAsset)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUpdatableAssetCollectionResponse(writer: SerializationWriter, updatableAssetCollectionResponse: Partial<UpdatableAssetCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, updatableAssetCollectionResponse)
    writer.writeCollectionOfObjectValues<UpdatableAsset>("value", updatableAssetCollectionResponse.value, serializeUpdatableAsset);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUpdatableAssetEnrollment(writer: SerializationWriter, updatableAssetEnrollment: Partial<UpdatableAssetEnrollment> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", updatableAssetEnrollment.odataType);
    writer.writeAdditionalData(updatableAssetEnrollment.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUpdatableAssetError(writer: SerializationWriter, updatableAssetError: Partial<UpdatableAssetError> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", updatableAssetError.odataType);
    writer.writeAdditionalData(updatableAssetError.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUpdatableAssetGroup(writer: SerializationWriter, updatableAssetGroup: Partial<UpdatableAssetGroup> | undefined = {}) : void {
    serializeUpdatableAsset(writer, updatableAssetGroup)
    writer.writeCollectionOfObjectValues<UpdatableAsset>("members", updatableAssetGroup.members, serializeUpdatableAsset);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUpdateManagementEnrollment(writer: SerializationWriter, updateManagementEnrollment: Partial<UpdateManagementEnrollment> | undefined = {}) : void {
    serializeUpdatableAssetEnrollment(writer, updateManagementEnrollment)
    writer.writeEnumValue<UpdateCategory>("updateCategory", updateManagementEnrollment.updateCategory);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUpdatePolicy(writer: SerializationWriter, updatePolicy: Partial<UpdatePolicy> | undefined = {}) : void {
    serializeEntity(writer, updatePolicy)
    writer.writeObjectValue<DeploymentAudience>("audience", updatePolicy.audience, serializeDeploymentAudience);
    writer.writeCollectionOfObjectValues<ComplianceChangeRule>("complianceChangeRules", updatePolicy.complianceChangeRules, serializeComplianceChangeRule);
    writer.writeCollectionOfObjectValues<ComplianceChange>("complianceChanges", updatePolicy.complianceChanges, serializeComplianceChange);
    writer.writeDateValue("createdDateTime", updatePolicy.createdDateTime);
    writer.writeObjectValue<DeploymentSettings>("deploymentSettings", updatePolicy.deploymentSettings, serializeDeploymentSettings);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUpdatePolicyCollectionResponse(writer: SerializationWriter, updatePolicyCollectionResponse: Partial<UpdatePolicyCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, updatePolicyCollectionResponse)
    writer.writeCollectionOfObjectValues<UpdatePolicy>("value", updatePolicyCollectionResponse.value, serializeUpdatePolicy);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserExperienceSettings(writer: SerializationWriter, userExperienceSettings: Partial<UserExperienceSettings> | undefined = {}) : void {
    writer.writeNumberValue("daysUntilForcedReboot", userExperienceSettings.daysUntilForcedReboot);
    writer.writeBooleanValue("isHotpatchEnabled", userExperienceSettings.isHotpatchEnabled);
    writer.writeStringValue("@odata.type", userExperienceSettings.odataType);
    writer.writeBooleanValue("offerAsOptional", userExperienceSettings.offerAsOptional);
    writer.writeAdditionalData(userExperienceSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWindowsUpdateFilter(writer: SerializationWriter, windowsUpdateFilter: Partial<WindowsUpdateFilter> | undefined = {}) : void {
    serializeSoftwareUpdateFilter(writer, windowsUpdateFilter)
}
export interface ServicingPeriod extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The date and time when the servicing period ends. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    endDateTime?: Date;
    /**
     * The name of the servicing period. For example, Modern Lifecycle.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The start date and time of the servicing period. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    startDateTime?: Date;
}
export interface SoftwareUpdateCatalogEntry extends CatalogEntry, Parsable {
}
export interface SoftwareUpdateFilter extends ContentFilter, Parsable {
}
export interface UpdatableAsset extends Entity, Parsable {
}
export interface UpdatableAssetCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UpdatableAsset[];
}
export interface UpdatableAssetEnrollment extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface UpdatableAssetError extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface UpdatableAssetGroup extends Parsable, UpdatableAsset {
    /**
     * Members of the group. Read-only.
     */
    members?: UpdatableAsset[];
}
export type UpdateCategory = (typeof UpdateCategoryObject)[keyof typeof UpdateCategoryObject];
export interface UpdateManagementEnrollment extends Parsable, UpdatableAssetEnrollment {
    /**
     * The updateCategory property
     */
    updateCategory?: UpdateCategory;
}
export interface UpdatePolicy extends Entity, Parsable {
    /**
     * Specifies the audience to target.
     */
    audience?: DeploymentAudience;
    /**
     * Rules for governing the automatic creation of compliance changes.
     */
    complianceChangeRules?: ComplianceChangeRule[];
    /**
     * Compliance changes like content approvals which result in the automatic creation of deployments using the audience and deploymentSettings of the policy.
     */
    complianceChanges?: ComplianceChange[];
    /**
     * The date and time when the update policy was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    createdDateTime?: Date;
    /**
     * Settings for governing how to deploy content.
     */
    deploymentSettings?: DeploymentSettings;
}
export interface UpdatePolicyCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UpdatePolicy[];
}
export interface UserExperienceSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Specifies the number of days after an update is installed, during which the user of the device can control when the device restarts.
     */
    daysUntilForcedReboot?: number;
    /**
     * The isHotpatchEnabled property
     */
    isHotpatchEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Specifies whether the update is offered as Optional rather than Required.
     */
    offerAsOptional?: boolean;
}
export type WindowsReleaseHealthStatus = (typeof WindowsReleaseHealthStatusObject)[keyof typeof WindowsReleaseHealthStatusObject];
export interface WindowsUpdateFilter extends Parsable, SoftwareUpdateFilter {
}
export const AzureADDeviceRegistrationErrorReasonObject = {
    InvalidGlobalDeviceId: "invalidGlobalDeviceId",
    InvalidAzureADDeviceId: "invalidAzureADDeviceId",
    MissingTrustType: "missingTrustType",
    InvalidAzureADJoin: "invalidAzureADJoin",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const BodyTypeObject = {
    Text: "text",
    Html: "html",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const CveSeverityLevelObject = {
    Critical: "critical",
    Important: "important",
    Moderate: "moderate",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeploymentStateReasonValueObject = {
    ScheduledByOfferWindow: "scheduledByOfferWindow",
    OfferingByRequest: "offeringByRequest",
    PausedByRequest: "pausedByRequest",
    PausedByMonitoring: "pausedByMonitoring",
    UnknownFutureValue: "unknownFutureValue",
    FaultedByContentOutdated: "faultedByContentOutdated",
} as const;
export const DeploymentStateValueObject = {
    Scheduled: "scheduled",
    Offering: "offering",
    Paused: "paused",
    Faulted: "faulted",
    Archived: "archived",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const MonitoringActionObject = {
    AlertError: "alertError",
    OfferFallback: "offerFallback",
    PauseDeployment: "pauseDeployment",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const MonitoringSignalObject = {
    Rollback: "rollback",
    Ineligible: "ineligible",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const QualityUpdateCadenceObject = {
    Monthly: "monthly",
    OutOfBand: "outOfBand",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const QualityUpdateClassificationObject = {
    All: "all",
    Security: "security",
    NonSecurity: "nonSecurity",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RequestedDeploymentStateValueObject = {
    None: "none",
    Paused: "paused",
    Archived: "archived",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ResourceConnectionStateObject = {
    Connected: "connected",
    NotAuthorized: "notAuthorized",
    NotFound: "notFound",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const SafeguardCategoryObject = {
    LikelyIssues: "likelyIssues",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const UpdateCategoryObject = {
    Feature: "feature",
    Quality: "quality",
    UnknownFutureValue: "unknownFutureValue",
    Driver: "driver",
} as const;
export const WindowsReleaseHealthStatusObject = {
    Resolved: "resolved",
    MitigatedExternal: "mitigatedExternal",
    Mitigated: "mitigated",
    ResolvedExternal: "resolvedExternal",
    Confirmed: "confirmed",
    Reported: "reported",
    Investigating: "investigating",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
