/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createGroupFromDiscriminatorValue, createIdentitySetFromDiscriminatorValue, createResultInfoFromDiscriminatorValue, createSiteFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, serializeGroup, serializeIdentitySet, serializeResultInfo, serializeSite, type BaseCollectionPaginationCountResponse, type Entity, type Group, type IdentitySet, type ResultInfo, type Site } from '../index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Duration, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export type AdditionalDataOptions = (typeof AdditionalDataOptionsObject)[keyof typeof AdditionalDataOptionsObject];
export interface AddToReviewSetOperation extends CaseOperation, Parsable {
    /**
     * The review set to which items matching the source collection query are added to.
     */
    reviewSet?: ReviewSet | null;
    /**
     * The sourceCollection that items are being added from.
     */
    sourceCollection?: SourceCollection | null;
}
export type CaseAction = (typeof CaseActionObject)[keyof typeof CaseActionObject];
export interface CaseCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CaseEscaped[] | null;
}
export interface CaseEscaped extends Entity, Parsable {
    /**
     * The user who closed the case.
     */
    closedBy?: IdentitySet | null;
    /**
     * The date and time when the case was closed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    closedDateTime?: Date | null;
    /**
     * The date and time when the entity was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    createdDateTime?: Date | null;
    /**
     * Returns a list of case custodian objects for this case.  Nullable.
     */
    custodians?: Custodian[] | null;
    /**
     * The case description.
     */
    description?: string | null;
    /**
     * The case name.
     */
    displayName?: string | null;
    /**
     * The external case number for customer reference.
     */
    externalId?: string | null;
    /**
     * The last user who modified the entity.
     */
    lastModifiedBy?: IdentitySet | null;
    /**
     * The latest date and time when the case was modified. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    lastModifiedDateTime?: Date | null;
    /**
     * Returns a list of case legalHold objects for this case.  Nullable.
     */
    legalHolds?: LegalHold[] | null;
    /**
     * Returns a list of case noncustodialDataSource objects for this case.  Nullable.
     */
    noncustodialDataSources?: NoncustodialDataSource[] | null;
    /**
     * Returns a list of case operation objects for this case. Nullable.
     */
    operations?: CaseOperation[] | null;
    /**
     * Returns a list of reviewSet objects in the case. Read-only. Nullable.
     */
    reviewSets?: ReviewSet[] | null;
    /**
     * The settings property
     */
    settings?: CaseSettings | null;
    /**
     * Returns a list of sourceCollection objects associated with this case.
     */
    sourceCollections?: SourceCollection[] | null;
    /**
     * The case status. Possible values are unknown, active, pendingDelete, closing, closed, and closedWithError. For details, see the following table.
     */
    status?: CaseStatus | null;
    /**
     * Returns a list of tag objects associated to this case.
     */
    tags?: Tag[] | null;
}
export interface CaseExportOperation extends CaseOperation, Parsable {
    /**
     * The name of the Azure storage location where the export will be stored. This only applies to exports stored in your own Azure storage location.
     */
    azureBlobContainer?: string | null;
    /**
     * The SAS token for the Azure storage location.  This only applies to exports stored in your own Azure storage location.
     */
    azureBlobToken?: string | null;
    /**
     * The description provided for the export.
     */
    description?: string | null;
    /**
     * The options provided for the export. For more information, see reviewSet: export. Possible values are: originalFiles, text, pdfReplacement, fileInfo, tags.
     */
    exportOptions?: ExportOptions[] | null;
    /**
     * The options provided specify the structure of the export. For more information, see reviewSet: export. Possible values are: none, directory, pst.
     */
    exportStructure?: ExportFileStructure | null;
    /**
     * The output folder ID.
     */
    outputFolderId?: string | null;
    /**
     * The name provided for the export.
     */
    outputName?: string | null;
    /**
     * The review set the content is being exported from.
     */
    reviewSet?: ReviewSet | null;
}
export interface CaseExportOperationCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CaseExportOperation[] | null;
}
export interface CaseHoldOperation extends CaseOperation, Parsable {
}
export interface CaseIndexOperation extends CaseOperation, Parsable {
}
export interface CaseOperation extends Entity, Parsable {
    /**
     * The type of action the operation represents. Possible values are: addToReviewSet,applyTags,contentExport,convertToPdf,estimateStatistics, purgeData
     */
    action?: CaseAction | null;
    /**
     * The date and time the operation was completed.
     */
    completedDateTime?: Date | null;
    /**
     * The user that created the operation.
     */
    createdBy?: IdentitySet | null;
    /**
     * The date and time the operation was created.
     */
    createdDateTime?: Date | null;
    /**
     * The progress of the operation.
     */
    percentProgress?: number | null;
    /**
     * Contains success and failure-specific result information.
     */
    resultInfo?: ResultInfo | null;
    /**
     * The status of the case operation. Possible values are: notStarted, submissionFailed, running, succeeded, partiallySucceeded, failed.
     */
    status?: CaseOperationStatus | null;
}
export interface CaseOperationCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CaseOperation[] | null;
}
export type CaseOperationStatus = (typeof CaseOperationStatusObject)[keyof typeof CaseOperationStatusObject];
export interface CaseSettings extends Entity, Parsable {
    /**
     * The OCR (Optical Character Recognition) settings for the case.
     */
    ocr?: OcrSettings | null;
    /**
     * The redundancy (near duplicate and email threading) detection settings for the case.
     */
    redundancyDetection?: RedundancyDetectionSettings | null;
    /**
     * The article Modeling (Themes) settings for the case.
     */
    topicModeling?: TopicModelingSettings | null;
}
export type CaseStatus = (typeof CaseStatusObject)[keyof typeof CaseStatusObject];
export type ChildSelectability = (typeof ChildSelectabilityObject)[keyof typeof ChildSelectabilityObject];
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AddToReviewSetOperation}
 */
// @ts-ignore
export function createAddToReviewSetOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAddToReviewSetOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseCollectionResponse}
 */
// @ts-ignore
export function createCaseCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCaseCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseEscaped}
 */
// @ts-ignore
export function createCaseEscapedFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCaseEscaped;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseExportOperationCollectionResponse}
 */
// @ts-ignore
export function createCaseExportOperationCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCaseExportOperationCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseExportOperation}
 */
// @ts-ignore
export function createCaseExportOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCaseExportOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseHoldOperation}
 */
// @ts-ignore
export function createCaseHoldOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCaseHoldOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseIndexOperation}
 */
// @ts-ignore
export function createCaseIndexOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCaseIndexOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseOperationCollectionResponse}
 */
// @ts-ignore
export function createCaseOperationCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCaseOperationCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseOperation}
 */
// @ts-ignore
export function createCaseOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.ediscovery.addToReviewSetOperation":
                    return deserializeIntoAddToReviewSetOperation;
                case "#microsoft.graph.ediscovery.caseExportOperation":
                    return deserializeIntoCaseExportOperation;
                case "#microsoft.graph.ediscovery.caseHoldOperation":
                    return deserializeIntoCaseHoldOperation;
                case "#microsoft.graph.ediscovery.caseIndexOperation":
                    return deserializeIntoCaseIndexOperation;
                case "#microsoft.graph.ediscovery.estimateStatisticsOperation":
                    return deserializeIntoEstimateStatisticsOperation;
                case "#microsoft.graph.ediscovery.purgeDataOperation":
                    return deserializeIntoPurgeDataOperation;
                case "#microsoft.graph.ediscovery.tagOperation":
                    return deserializeIntoTagOperation;
            }
        }
    }
    return deserializeIntoCaseOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseSettings}
 */
// @ts-ignore
export function createCaseSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCaseSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CustodianCollectionResponse}
 */
// @ts-ignore
export function createCustodianCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCustodianCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Custodian}
 */
// @ts-ignore
export function createCustodianFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCustodian;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DataSourceCollectionResponse}
 */
// @ts-ignore
export function createDataSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDataSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DataSourceContainer}
 */
// @ts-ignore
export function createDataSourceContainerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.ediscovery.custodian":
                    return deserializeIntoCustodian;
                case "#microsoft.graph.ediscovery.noncustodialDataSource":
                    return deserializeIntoNoncustodialDataSource;
            }
        }
    }
    return deserializeIntoDataSourceContainer;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DataSource}
 */
// @ts-ignore
export function createDataSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.ediscovery.siteSource":
                    return deserializeIntoSiteSource;
                case "#microsoft.graph.ediscovery.unifiedGroupSource":
                    return deserializeIntoUnifiedGroupSource;
                case "#microsoft.graph.ediscovery.userSource":
                    return deserializeIntoUserSource;
            }
        }
    }
    return deserializeIntoDataSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Ediscoveryroot}
 */
// @ts-ignore
export function createEdiscoveryrootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryroot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EstimateStatisticsOperation}
 */
// @ts-ignore
export function createEstimateStatisticsOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEstimateStatisticsOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LegalHoldCollectionResponse}
 */
// @ts-ignore
export function createLegalHoldCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLegalHoldCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LegalHold}
 */
// @ts-ignore
export function createLegalHoldFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLegalHold;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NoncustodialDataSourceCollectionResponse}
 */
// @ts-ignore
export function createNoncustodialDataSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNoncustodialDataSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NoncustodialDataSource}
 */
// @ts-ignore
export function createNoncustodialDataSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNoncustodialDataSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OcrSettings}
 */
// @ts-ignore
export function createOcrSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOcrSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PurgeDataOperation}
 */
// @ts-ignore
export function createPurgeDataOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPurgeDataOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RedundancyDetectionSettings}
 */
// @ts-ignore
export function createRedundancyDetectionSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRedundancyDetectionSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ReviewSetCollectionResponse}
 */
// @ts-ignore
export function createReviewSetCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoReviewSetCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ReviewSet}
 */
// @ts-ignore
export function createReviewSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoReviewSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ReviewSetQueryCollectionResponse}
 */
// @ts-ignore
export function createReviewSetQueryCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoReviewSetQueryCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ReviewSetQuery}
 */
// @ts-ignore
export function createReviewSetQueryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoReviewSetQuery;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SiteSourceCollectionResponse}
 */
// @ts-ignore
export function createSiteSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSiteSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SiteSource}
 */
// @ts-ignore
export function createSiteSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSiteSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SourceCollectionCollectionResponse}
 */
// @ts-ignore
export function createSourceCollectionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSourceCollectionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SourceCollection}
 */
// @ts-ignore
export function createSourceCollectionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSourceCollection;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TagCollectionResponse}
 */
// @ts-ignore
export function createTagCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTagCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Tag}
 */
// @ts-ignore
export function createTagFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTag;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TagOperation}
 */
// @ts-ignore
export function createTagOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTagOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TopicModelingSettings}
 */
// @ts-ignore
export function createTopicModelingSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTopicModelingSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UnifiedGroupSourceCollectionResponse}
 */
// @ts-ignore
export function createUnifiedGroupSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUnifiedGroupSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UnifiedGroupSource}
 */
// @ts-ignore
export function createUnifiedGroupSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUnifiedGroupSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserSourceCollectionResponse}
 */
// @ts-ignore
export function createUserSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserSource}
 */
// @ts-ignore
export function createUserSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserSource;
}
export interface Custodian extends DataSourceContainer, Parsable {
    /**
     * Date and time the custodian acknowledged a hold notification.
     */
    acknowledgedDateTime?: Date | null;
    /**
     * Identifies whether a custodian's sources were placed on hold during creation.
     */
    applyHoldToSources?: boolean | null;
    /**
     * Email address of the custodian.
     */
    email?: string | null;
    /**
     * Data source entity for SharePoint sites associated with the custodian.
     */
    siteSources?: SiteSource[] | null;
    /**
     * Data source entity for groups associated with the custodian.
     */
    unifiedGroupSources?: UnifiedGroupSource[] | null;
    /**
     * Data source entity for a the custodian. This is the container for a custodian's mailbox and OneDrive for Business site.
     */
    userSources?: UserSource[] | null;
}
export interface CustodianCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Custodian[] | null;
}
export interface DataSource extends Entity, Parsable {
    /**
     * The user who created the dataSource.
     */
    createdBy?: IdentitySet | null;
    /**
     * The date and time the dataSource was created.
     */
    createdDateTime?: Date | null;
    /**
     * The display name of the dataSource, and is the name of the SharePoint site.
     */
    displayName?: string | null;
    /**
     * The holdStatus property
     */
    holdStatus?: DataSourceHoldStatus | null;
}
export interface DataSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: DataSource[] | null;
}
export interface DataSourceContainer extends Entity, Parsable {
    /**
     * Created date and time of the dataSourceContainer entity.
     */
    createdDateTime?: Date | null;
    /**
     * Display name of the dataSourceContainer entity.
     */
    displayName?: string | null;
    /**
     * The holdStatus property
     */
    holdStatus?: DataSourceHoldStatus | null;
    /**
     * The lastIndexOperation property
     */
    lastIndexOperation?: CaseIndexOperation | null;
    /**
     * Last modified date and time of the dataSourceContainer.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * Date and time that the dataSourceContainer was released from the case.
     */
    releasedDateTime?: Date | null;
    /**
     * Latest status of the dataSourceContainer. Possible values are: Active, Released.
     */
    status?: DataSourceContainerStatus | null;
}
export type DataSourceContainerStatus = (typeof DataSourceContainerStatusObject)[keyof typeof DataSourceContainerStatusObject];
export type DataSourceHoldStatus = (typeof DataSourceHoldStatusObject)[keyof typeof DataSourceHoldStatusObject];
export type DataSourceScopes = (typeof DataSourceScopesObject)[keyof typeof DataSourceScopesObject];
/**
 * The deserialization information for the current model
 * @param AddToReviewSetOperation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAddToReviewSetOperation(addToReviewSetOperation: Partial<AddToReviewSetOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(addToReviewSetOperation),
        "reviewSet": n => { addToReviewSetOperation.reviewSet = n.getObjectValue<ReviewSet>(createReviewSetFromDiscriminatorValue); },
        "sourceCollection": n => { addToReviewSetOperation.sourceCollection = n.getObjectValue<SourceCollection>(createSourceCollectionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param CaseCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCaseCollectionResponse(caseCollectionResponse: Partial<CaseCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(caseCollectionResponse),
        "value": n => { caseCollectionResponse.value = n.getCollectionOfObjectValues<CaseEscaped>(createCaseEscapedFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param CaseEscaped The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCaseEscaped(caseEscaped: Partial<CaseEscaped> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(caseEscaped),
        "closedBy": n => { caseEscaped.closedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "closedDateTime": n => { caseEscaped.closedDateTime = n.getDateValue(); },
        "createdDateTime": n => { caseEscaped.createdDateTime = n.getDateValue(); },
        "custodians": n => { caseEscaped.custodians = n.getCollectionOfObjectValues<Custodian>(createCustodianFromDiscriminatorValue); },
        "description": n => { caseEscaped.description = n.getStringValue(); },
        "displayName": n => { caseEscaped.displayName = n.getStringValue(); },
        "externalId": n => { caseEscaped.externalId = n.getStringValue(); },
        "lastModifiedBy": n => { caseEscaped.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { caseEscaped.lastModifiedDateTime = n.getDateValue(); },
        "legalHolds": n => { caseEscaped.legalHolds = n.getCollectionOfObjectValues<LegalHold>(createLegalHoldFromDiscriminatorValue); },
        "noncustodialDataSources": n => { caseEscaped.noncustodialDataSources = n.getCollectionOfObjectValues<NoncustodialDataSource>(createNoncustodialDataSourceFromDiscriminatorValue); },
        "operations": n => { caseEscaped.operations = n.getCollectionOfObjectValues<CaseOperation>(createCaseOperationFromDiscriminatorValue); },
        "reviewSets": n => { caseEscaped.reviewSets = n.getCollectionOfObjectValues<ReviewSet>(createReviewSetFromDiscriminatorValue); },
        "settings": n => { caseEscaped.settings = n.getObjectValue<CaseSettings>(createCaseSettingsFromDiscriminatorValue); },
        "sourceCollections": n => { caseEscaped.sourceCollections = n.getCollectionOfObjectValues<SourceCollection>(createSourceCollectionFromDiscriminatorValue); },
        "status": n => { caseEscaped.status = n.getEnumValue<CaseStatus>(CaseStatusObject); },
        "tags": n => { caseEscaped.tags = n.getCollectionOfObjectValues<Tag>(createTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param CaseExportOperation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCaseExportOperation(caseExportOperation: Partial<CaseExportOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(caseExportOperation),
        "azureBlobContainer": n => { caseExportOperation.azureBlobContainer = n.getStringValue(); },
        "azureBlobToken": n => { caseExportOperation.azureBlobToken = n.getStringValue(); },
        "description": n => { caseExportOperation.description = n.getStringValue(); },
        "exportOptions": n => { caseExportOperation.exportOptions = n.getCollectionOfEnumValues<ExportOptions>(ExportOptionsObject); },
        "exportStructure": n => { caseExportOperation.exportStructure = n.getEnumValue<ExportFileStructure>(ExportFileStructureObject); },
        "outputFolderId": n => { caseExportOperation.outputFolderId = n.getStringValue(); },
        "outputName": n => { caseExportOperation.outputName = n.getStringValue(); },
        "reviewSet": n => { caseExportOperation.reviewSet = n.getObjectValue<ReviewSet>(createReviewSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param CaseExportOperationCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCaseExportOperationCollectionResponse(caseExportOperationCollectionResponse: Partial<CaseExportOperationCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(caseExportOperationCollectionResponse),
        "value": n => { caseExportOperationCollectionResponse.value = n.getCollectionOfObjectValues<CaseExportOperation>(createCaseExportOperationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param CaseHoldOperation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCaseHoldOperation(caseHoldOperation: Partial<CaseHoldOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(caseHoldOperation),
    }
}
/**
 * The deserialization information for the current model
 * @param CaseIndexOperation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCaseIndexOperation(caseIndexOperation: Partial<CaseIndexOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(caseIndexOperation),
    }
}
/**
 * The deserialization information for the current model
 * @param CaseOperation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCaseOperation(caseOperation: Partial<CaseOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(caseOperation),
        "action": n => { caseOperation.action = n.getEnumValue<CaseAction>(CaseActionObject); },
        "completedDateTime": n => { caseOperation.completedDateTime = n.getDateValue(); },
        "createdBy": n => { caseOperation.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { caseOperation.createdDateTime = n.getDateValue(); },
        "percentProgress": n => { caseOperation.percentProgress = n.getNumberValue(); },
        "resultInfo": n => { caseOperation.resultInfo = n.getObjectValue<ResultInfo>(createResultInfoFromDiscriminatorValue); },
        "status": n => { caseOperation.status = n.getEnumValue<CaseOperationStatus>(CaseOperationStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param CaseOperationCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCaseOperationCollectionResponse(caseOperationCollectionResponse: Partial<CaseOperationCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(caseOperationCollectionResponse),
        "value": n => { caseOperationCollectionResponse.value = n.getCollectionOfObjectValues<CaseOperation>(createCaseOperationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param CaseSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCaseSettings(caseSettings: Partial<CaseSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(caseSettings),
        "ocr": n => { caseSettings.ocr = n.getObjectValue<OcrSettings>(createOcrSettingsFromDiscriminatorValue); },
        "redundancyDetection": n => { caseSettings.redundancyDetection = n.getObjectValue<RedundancyDetectionSettings>(createRedundancyDetectionSettingsFromDiscriminatorValue); },
        "topicModeling": n => { caseSettings.topicModeling = n.getObjectValue<TopicModelingSettings>(createTopicModelingSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Custodian The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCustodian(custodian: Partial<Custodian> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSourceContainer(custodian),
        "acknowledgedDateTime": n => { custodian.acknowledgedDateTime = n.getDateValue(); },
        "applyHoldToSources": n => { custodian.applyHoldToSources = n.getBooleanValue(); },
        "email": n => { custodian.email = n.getStringValue(); },
        "siteSources": n => { custodian.siteSources = n.getCollectionOfObjectValues<SiteSource>(createSiteSourceFromDiscriminatorValue); },
        "unifiedGroupSources": n => { custodian.unifiedGroupSources = n.getCollectionOfObjectValues<UnifiedGroupSource>(createUnifiedGroupSourceFromDiscriminatorValue); },
        "userSources": n => { custodian.userSources = n.getCollectionOfObjectValues<UserSource>(createUserSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param CustodianCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCustodianCollectionResponse(custodianCollectionResponse: Partial<CustodianCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(custodianCollectionResponse),
        "value": n => { custodianCollectionResponse.value = n.getCollectionOfObjectValues<Custodian>(createCustodianFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param DataSource The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDataSource(dataSource: Partial<DataSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(dataSource),
        "createdBy": n => { dataSource.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { dataSource.createdDateTime = n.getDateValue(); },
        "displayName": n => { dataSource.displayName = n.getStringValue(); },
        "holdStatus": n => { dataSource.holdStatus = n.getEnumValue<DataSourceHoldStatus>(DataSourceHoldStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param DataSourceCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDataSourceCollectionResponse(dataSourceCollectionResponse: Partial<DataSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(dataSourceCollectionResponse),
        "value": n => { dataSourceCollectionResponse.value = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param DataSourceContainer The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDataSourceContainer(dataSourceContainer: Partial<DataSourceContainer> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(dataSourceContainer),
        "createdDateTime": n => { dataSourceContainer.createdDateTime = n.getDateValue(); },
        "displayName": n => { dataSourceContainer.displayName = n.getStringValue(); },
        "holdStatus": n => { dataSourceContainer.holdStatus = n.getEnumValue<DataSourceHoldStatus>(DataSourceHoldStatusObject); },
        "lastIndexOperation": n => { dataSourceContainer.lastIndexOperation = n.getObjectValue<CaseIndexOperation>(createCaseIndexOperationFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { dataSourceContainer.lastModifiedDateTime = n.getDateValue(); },
        "releasedDateTime": n => { dataSourceContainer.releasedDateTime = n.getDateValue(); },
        "status": n => { dataSourceContainer.status = n.getEnumValue<DataSourceContainerStatus>(DataSourceContainerStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param Ediscoveryroot The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEdiscoveryroot(ediscoveryroot: Partial<Ediscoveryroot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(ediscoveryroot),
        "cases": n => { ediscoveryroot.cases = n.getCollectionOfObjectValues<CaseEscaped>(createCaseEscapedFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param EstimateStatisticsOperation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEstimateStatisticsOperation(estimateStatisticsOperation: Partial<EstimateStatisticsOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(estimateStatisticsOperation),
        "indexedItemCount": n => { estimateStatisticsOperation.indexedItemCount = n.getNumberValue(); },
        "indexedItemsSize": n => { estimateStatisticsOperation.indexedItemsSize = n.getNumberValue(); },
        "mailboxCount": n => { estimateStatisticsOperation.mailboxCount = n.getNumberValue(); },
        "siteCount": n => { estimateStatisticsOperation.siteCount = n.getNumberValue(); },
        "sourceCollection": n => { estimateStatisticsOperation.sourceCollection = n.getObjectValue<SourceCollection>(createSourceCollectionFromDiscriminatorValue); },
        "unindexedItemCount": n => { estimateStatisticsOperation.unindexedItemCount = n.getNumberValue(); },
        "unindexedItemsSize": n => { estimateStatisticsOperation.unindexedItemsSize = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param LegalHold The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoLegalHold(legalHold: Partial<LegalHold> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(legalHold),
        "contentQuery": n => { legalHold.contentQuery = n.getStringValue(); },
        "createdBy": n => { legalHold.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { legalHold.createdDateTime = n.getDateValue(); },
        "description": n => { legalHold.description = n.getStringValue(); },
        "displayName": n => { legalHold.displayName = n.getStringValue(); },
        "errors": n => { legalHold.errors = n.getCollectionOfPrimitiveValues<string>(); },
        "isEnabled": n => { legalHold.isEnabled = n.getBooleanValue(); },
        "lastModifiedBy": n => { legalHold.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { legalHold.lastModifiedDateTime = n.getDateValue(); },
        "siteSources": n => { legalHold.siteSources = n.getCollectionOfObjectValues<SiteSource>(createSiteSourceFromDiscriminatorValue); },
        "status": n => { legalHold.status = n.getEnumValue<LegalHoldStatus>(LegalHoldStatusObject); },
        "unifiedGroupSources": n => { legalHold.unifiedGroupSources = n.getCollectionOfObjectValues<UnifiedGroupSource>(createUnifiedGroupSourceFromDiscriminatorValue); },
        "userSources": n => { legalHold.userSources = n.getCollectionOfObjectValues<UserSource>(createUserSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param LegalHoldCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoLegalHoldCollectionResponse(legalHoldCollectionResponse: Partial<LegalHoldCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(legalHoldCollectionResponse),
        "value": n => { legalHoldCollectionResponse.value = n.getCollectionOfObjectValues<LegalHold>(createLegalHoldFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param NoncustodialDataSource The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoNoncustodialDataSource(noncustodialDataSource: Partial<NoncustodialDataSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSourceContainer(noncustodialDataSource),
        "applyHoldToSource": n => { noncustodialDataSource.applyHoldToSource = n.getBooleanValue(); },
        "dataSource": n => { noncustodialDataSource.dataSource = n.getObjectValue<DataSource>(createDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param NoncustodialDataSourceCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoNoncustodialDataSourceCollectionResponse(noncustodialDataSourceCollectionResponse: Partial<NoncustodialDataSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(noncustodialDataSourceCollectionResponse),
        "value": n => { noncustodialDataSourceCollectionResponse.value = n.getCollectionOfObjectValues<NoncustodialDataSource>(createNoncustodialDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param OcrSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoOcrSettings(ocrSettings: Partial<OcrSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { ocrSettings.backingStoreEnabled = true; },
        "isEnabled": n => { ocrSettings.isEnabled = n.getBooleanValue(); },
        "maxImageSize": n => { ocrSettings.maxImageSize = n.getNumberValue(); },
        "@odata.type": n => { ocrSettings.odataType = n.getStringValue(); },
        "timeout": n => { ocrSettings.timeout = n.getDurationValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param PurgeDataOperation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPurgeDataOperation(purgeDataOperation: Partial<PurgeDataOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(purgeDataOperation),
    }
}
/**
 * The deserialization information for the current model
 * @param RedundancyDetectionSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRedundancyDetectionSettings(redundancyDetectionSettings: Partial<RedundancyDetectionSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { redundancyDetectionSettings.backingStoreEnabled = true; },
        "isEnabled": n => { redundancyDetectionSettings.isEnabled = n.getBooleanValue(); },
        "maxWords": n => { redundancyDetectionSettings.maxWords = n.getNumberValue(); },
        "minWords": n => { redundancyDetectionSettings.minWords = n.getNumberValue(); },
        "@odata.type": n => { redundancyDetectionSettings.odataType = n.getStringValue(); },
        "similarityThreshold": n => { redundancyDetectionSettings.similarityThreshold = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ReviewSet The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoReviewSet(reviewSet: Partial<ReviewSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(reviewSet),
        "createdBy": n => { reviewSet.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { reviewSet.createdDateTime = n.getDateValue(); },
        "displayName": n => { reviewSet.displayName = n.getStringValue(); },
        "queries": n => { reviewSet.queries = n.getCollectionOfObjectValues<ReviewSetQuery>(createReviewSetQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ReviewSetCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoReviewSetCollectionResponse(reviewSetCollectionResponse: Partial<ReviewSetCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(reviewSetCollectionResponse),
        "value": n => { reviewSetCollectionResponse.value = n.getCollectionOfObjectValues<ReviewSet>(createReviewSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ReviewSetQuery The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoReviewSetQuery(reviewSetQuery: Partial<ReviewSetQuery> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(reviewSetQuery),
        "createdBy": n => { reviewSetQuery.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { reviewSetQuery.createdDateTime = n.getDateValue(); },
        "displayName": n => { reviewSetQuery.displayName = n.getStringValue(); },
        "lastModifiedBy": n => { reviewSetQuery.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { reviewSetQuery.lastModifiedDateTime = n.getDateValue(); },
        "query": n => { reviewSetQuery.query = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ReviewSetQueryCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoReviewSetQueryCollectionResponse(reviewSetQueryCollectionResponse: Partial<ReviewSetQueryCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(reviewSetQueryCollectionResponse),
        "value": n => { reviewSetQueryCollectionResponse.value = n.getCollectionOfObjectValues<ReviewSetQuery>(createReviewSetQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param SiteSource The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSiteSource(siteSource: Partial<SiteSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(siteSource),
        "site": n => { siteSource.site = n.getObjectValue<Site>(createSiteFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param SiteSourceCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSiteSourceCollectionResponse(siteSourceCollectionResponse: Partial<SiteSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(siteSourceCollectionResponse),
        "value": n => { siteSourceCollectionResponse.value = n.getCollectionOfObjectValues<SiteSource>(createSiteSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param SourceCollection The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSourceCollection(sourceCollection: Partial<SourceCollection> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(sourceCollection),
        "additionalSources": n => { sourceCollection.additionalSources = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
        "addToReviewSetOperation": n => { sourceCollection.addToReviewSetOperation = n.getObjectValue<AddToReviewSetOperation>(createAddToReviewSetOperationFromDiscriminatorValue); },
        "contentQuery": n => { sourceCollection.contentQuery = n.getStringValue(); },
        "createdBy": n => { sourceCollection.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { sourceCollection.createdDateTime = n.getDateValue(); },
        "custodianSources": n => { sourceCollection.custodianSources = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
        "dataSourceScopes": n => { sourceCollection.dataSourceScopes = n.getCollectionOfEnumValues<DataSourceScopes>(DataSourceScopesObject); },
        "description": n => { sourceCollection.description = n.getStringValue(); },
        "displayName": n => { sourceCollection.displayName = n.getStringValue(); },
        "lastEstimateStatisticsOperation": n => { sourceCollection.lastEstimateStatisticsOperation = n.getObjectValue<EstimateStatisticsOperation>(createEstimateStatisticsOperationFromDiscriminatorValue); },
        "lastModifiedBy": n => { sourceCollection.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { sourceCollection.lastModifiedDateTime = n.getDateValue(); },
        "noncustodialSources": n => { sourceCollection.noncustodialSources = n.getCollectionOfObjectValues<NoncustodialDataSource>(createNoncustodialDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param SourceCollectionCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSourceCollectionCollectionResponse(sourceCollectionCollectionResponse: Partial<SourceCollectionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(sourceCollectionCollectionResponse),
        "value": n => { sourceCollectionCollectionResponse.value = n.getCollectionOfObjectValues<SourceCollection>(createSourceCollectionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Tag The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTag(tag: Partial<Tag> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(tag),
        "childSelectability": n => { tag.childSelectability = n.getEnumValue<ChildSelectability>(ChildSelectabilityObject); },
        "childTags": n => { tag.childTags = n.getCollectionOfObjectValues<Tag>(createTagFromDiscriminatorValue); },
        "createdBy": n => { tag.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "description": n => { tag.description = n.getStringValue(); },
        "displayName": n => { tag.displayName = n.getStringValue(); },
        "lastModifiedDateTime": n => { tag.lastModifiedDateTime = n.getDateValue(); },
        "parent": n => { tag.parent = n.getObjectValue<Tag>(createTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TagCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTagCollectionResponse(tagCollectionResponse: Partial<TagCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(tagCollectionResponse),
        "value": n => { tagCollectionResponse.value = n.getCollectionOfObjectValues<Tag>(createTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TagOperation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTagOperation(tagOperation: Partial<TagOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(tagOperation),
    }
}
/**
 * The deserialization information for the current model
 * @param TopicModelingSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTopicModelingSettings(topicModelingSettings: Partial<TopicModelingSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { topicModelingSettings.backingStoreEnabled = true; },
        "dynamicallyAdjustTopicCount": n => { topicModelingSettings.dynamicallyAdjustTopicCount = n.getBooleanValue(); },
        "ignoreNumbers": n => { topicModelingSettings.ignoreNumbers = n.getBooleanValue(); },
        "isEnabled": n => { topicModelingSettings.isEnabled = n.getBooleanValue(); },
        "@odata.type": n => { topicModelingSettings.odataType = n.getStringValue(); },
        "topicCount": n => { topicModelingSettings.topicCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UnifiedGroupSource The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUnifiedGroupSource(unifiedGroupSource: Partial<UnifiedGroupSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(unifiedGroupSource),
        "group": n => { unifiedGroupSource.group = n.getObjectValue<Group>(createGroupFromDiscriminatorValue); },
        "includedSources": n => { unifiedGroupSource.includedSources = n.getCollectionOfEnumValues<SourceType>(SourceTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param UnifiedGroupSourceCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUnifiedGroupSourceCollectionResponse(unifiedGroupSourceCollectionResponse: Partial<UnifiedGroupSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(unifiedGroupSourceCollectionResponse),
        "value": n => { unifiedGroupSourceCollectionResponse.value = n.getCollectionOfObjectValues<UnifiedGroupSource>(createUnifiedGroupSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param UserSource The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUserSource(userSource: Partial<UserSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(userSource),
        "email": n => { userSource.email = n.getStringValue(); },
        "includedSources": n => { userSource.includedSources = n.getCollectionOfEnumValues<SourceType>(SourceTypeObject); },
        "siteWebUrl": n => { userSource.siteWebUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UserSourceCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUserSourceCollectionResponse(userSourceCollectionResponse: Partial<UserSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(userSourceCollectionResponse),
        "value": n => { userSourceCollectionResponse.value = n.getCollectionOfObjectValues<UserSource>(createUserSourceFromDiscriminatorValue); },
    }
}
export interface Ediscoveryroot extends Entity, Parsable {
    /**
     * The cases property
     */
    cases?: CaseEscaped[] | null;
}
export interface EstimateStatisticsOperation extends CaseOperation, Parsable {
    /**
     * The estimated count of items for the sourceCollection that matched the content query.
     */
    indexedItemCount?: number | null;
    /**
     * The estimated size of items for the sourceCollection that matched the content query.
     */
    indexedItemsSize?: number | null;
    /**
     * The number of mailboxes that had search hits.
     */
    mailboxCount?: number | null;
    /**
     * The number of mailboxes that had search hits.
     */
    siteCount?: number | null;
    /**
     * eDiscovery collection, commonly known as a search.
     */
    sourceCollection?: SourceCollection | null;
    /**
     * The estimated count of unindexed items for the collection.
     */
    unindexedItemCount?: number | null;
    /**
     * The estimated size of unindexed items for the collection.
     */
    unindexedItemsSize?: number | null;
}
export type ExportFileStructure = (typeof ExportFileStructureObject)[keyof typeof ExportFileStructureObject];
export type ExportOptions = (typeof ExportOptionsObject)[keyof typeof ExportOptionsObject];
export interface LegalHold extends Entity, Parsable {
    /**
     * KQL query that specifies content to be held in the specified locations. To learn more, see Keyword queries and search conditions for Content Search and eDiscovery.  To hold all content in the specified locations, leave contentQuery blank.
     */
    contentQuery?: string | null;
    /**
     * The user who created the legal hold.
     */
    createdBy?: IdentitySet | null;
    /**
     * The date and time the legal hold was created.
     */
    createdDateTime?: Date | null;
    /**
     * The legal hold description.
     */
    description?: string | null;
    /**
     * The display name of the legal hold.
     */
    displayName?: string | null;
    /**
     * Lists any errors that happened while placing the hold.
     */
    errors?: string[] | null;
    /**
     * Indicates whether the hold is enabled and actively holding content.
     */
    isEnabled?: boolean | null;
    /**
     * the user who last modified the legal hold.
     */
    lastModifiedBy?: IdentitySet | null;
    /**
     * The date and time the legal hold was last modified.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * Data source entity for SharePoint sites associated with the legal hold.
     */
    siteSources?: SiteSource[] | null;
    /**
     * The status of the legal hold. Possible values are: Pending, Error, Success, UnknownFutureValue.
     */
    status?: LegalHoldStatus | null;
    /**
     * The unifiedGroupSources property
     */
    unifiedGroupSources?: UnifiedGroupSource[] | null;
    /**
     * Data source entity for a the legal hold. This is the container for a mailbox and OneDrive for Business site.
     */
    userSources?: UserSource[] | null;
}
export interface LegalHoldCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: LegalHold[] | null;
}
export type LegalHoldStatus = (typeof LegalHoldStatusObject)[keyof typeof LegalHoldStatusObject];
export interface NoncustodialDataSource extends DataSourceContainer, Parsable {
    /**
     * Indicates if hold is applied to noncustodial data source (such as mailbox or site).
     */
    applyHoldToSource?: boolean | null;
    /**
     * User source or SharePoint site data source as noncustodial data source.
     */
    dataSource?: DataSource | null;
}
export interface NoncustodialDataSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: NoncustodialDataSource[] | null;
}
export interface OcrSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Indicates whether or not OCR is enabled for the case.
     */
    isEnabled?: boolean | null;
    /**
     * Maximum image size that will be processed in KB).
     */
    maxImageSize?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The timeout duration for the OCR engine. A longer timeout may increase success of OCR, but may add to the total processing time.
     */
    timeout?: Duration | null;
}
export interface PurgeDataOperation extends CaseOperation, Parsable {
}
export interface RedundancyDetectionSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Indicates whether email threading and near duplicate detection are enabled.
     */
    isEnabled?: boolean | null;
    /**
     * Specifies the maximum number of words used for email threading and near duplicate detection. To learn more, see Minimum/maximum number of words.
     */
    maxWords?: number | null;
    /**
     * Specifies the minimum number of words used for email threading and near duplicate detection. To learn more, see Minimum/maximum number of words.
     */
    minWords?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Specifies the similarity level for documents to be put in the same near duplicate set. To learn more, see Document and email similarity threshold.
     */
    similarityThreshold?: number | null;
}
export interface ReviewSet extends Entity, Parsable {
    /**
     * The user who created the review set. Read-only.
     */
    createdBy?: IdentitySet | null;
    /**
     * The datetime when the review set was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    createdDateTime?: Date | null;
    /**
     * The review set name. The name is unique with a maximum limit of 64 characters.
     */
    displayName?: string | null;
    /**
     * The queries property
     */
    queries?: ReviewSetQuery[] | null;
}
export interface ReviewSetCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ReviewSet[] | null;
}
export interface ReviewSetQuery extends Entity, Parsable {
    /**
     * The user who created the query.
     */
    createdBy?: IdentitySet | null;
    /**
     * The time and date when the query was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    createdDateTime?: Date | null;
    /**
     * The name of the query.
     */
    displayName?: string | null;
    /**
     * The user who last modified the query.
     */
    lastModifiedBy?: IdentitySet | null;
    /**
     * The date and time the query was last modified. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    lastModifiedDateTime?: Date | null;
    /**
     * The query string in KQL (Keyword Query Language) query. For details, see Document metadata fields in Advanced eDiscovery.  This field maps directly to the keywords condition.  You can refine searches by using fields listed in the searchable field name paired with values; for example, subject:'Quarterly Financials' AND Date>=06/01/2016 AND Date<=07/01/2016.
     */
    query?: string | null;
}
export interface ReviewSetQueryCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ReviewSetQuery[] | null;
}
/**
 * Serializes information the current object
 * @param AddToReviewSetOperation The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAddToReviewSetOperation(writer: SerializationWriter, addToReviewSetOperation: Partial<AddToReviewSetOperation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!addToReviewSetOperation || isSerializingDerivedType) { return; }
    serializeCaseOperation(writer, addToReviewSetOperation, isSerializingDerivedType)
    writer.writeObjectValue<ReviewSet>("reviewSet", addToReviewSetOperation.reviewSet, serializeReviewSet);
    writer.writeObjectValue<SourceCollection>("sourceCollection", addToReviewSetOperation.sourceCollection, serializeSourceCollection);
}
/**
 * Serializes information the current object
 * @param CaseCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCaseCollectionResponse(writer: SerializationWriter, caseCollectionResponse: Partial<CaseCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!caseCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, caseCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<CaseEscaped>("value", caseCollectionResponse.value, serializeCaseEscaped);
}
/**
 * Serializes information the current object
 * @param CaseEscaped The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCaseEscaped(writer: SerializationWriter, caseEscaped: Partial<CaseEscaped> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!caseEscaped || isSerializingDerivedType) { return; }
    serializeEntity(writer, caseEscaped, isSerializingDerivedType)
    writer.writeObjectValue<IdentitySet>("closedBy", caseEscaped.closedBy, serializeIdentitySet);
    writer.writeDateValue("closedDateTime", caseEscaped.closedDateTime);
    writer.writeDateValue("createdDateTime", caseEscaped.createdDateTime);
    writer.writeCollectionOfObjectValues<Custodian>("custodians", caseEscaped.custodians, serializeCustodian);
    writer.writeStringValue("description", caseEscaped.description);
    writer.writeStringValue("displayName", caseEscaped.displayName);
    writer.writeStringValue("externalId", caseEscaped.externalId);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", caseEscaped.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", caseEscaped.lastModifiedDateTime);
    writer.writeCollectionOfObjectValues<LegalHold>("legalHolds", caseEscaped.legalHolds, serializeLegalHold);
    writer.writeCollectionOfObjectValues<NoncustodialDataSource>("noncustodialDataSources", caseEscaped.noncustodialDataSources, serializeNoncustodialDataSource);
    writer.writeCollectionOfObjectValues<CaseOperation>("operations", caseEscaped.operations, serializeCaseOperation);
    writer.writeCollectionOfObjectValues<ReviewSet>("reviewSets", caseEscaped.reviewSets, serializeReviewSet);
    writer.writeObjectValue<CaseSettings>("settings", caseEscaped.settings, serializeCaseSettings);
    writer.writeCollectionOfObjectValues<SourceCollection>("sourceCollections", caseEscaped.sourceCollections, serializeSourceCollection);
    writer.writeEnumValue<CaseStatus>("status", caseEscaped.status);
    writer.writeCollectionOfObjectValues<Tag>("tags", caseEscaped.tags, serializeTag);
}
/**
 * Serializes information the current object
 * @param CaseExportOperation The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCaseExportOperation(writer: SerializationWriter, caseExportOperation: Partial<CaseExportOperation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!caseExportOperation || isSerializingDerivedType) { return; }
    serializeCaseOperation(writer, caseExportOperation, isSerializingDerivedType)
    writer.writeStringValue("azureBlobContainer", caseExportOperation.azureBlobContainer);
    writer.writeStringValue("azureBlobToken", caseExportOperation.azureBlobToken);
    writer.writeStringValue("description", caseExportOperation.description);
    writer.writeEnumValue<ExportOptions[]>("exportOptions", caseExportOperation.exportOptions);
    writer.writeEnumValue<ExportFileStructure>("exportStructure", caseExportOperation.exportStructure);
    writer.writeStringValue("outputFolderId", caseExportOperation.outputFolderId);
    writer.writeStringValue("outputName", caseExportOperation.outputName);
    writer.writeObjectValue<ReviewSet>("reviewSet", caseExportOperation.reviewSet, serializeReviewSet);
}
/**
 * Serializes information the current object
 * @param CaseExportOperationCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCaseExportOperationCollectionResponse(writer: SerializationWriter, caseExportOperationCollectionResponse: Partial<CaseExportOperationCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!caseExportOperationCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, caseExportOperationCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<CaseExportOperation>("value", caseExportOperationCollectionResponse.value, serializeCaseExportOperation);
}
/**
 * Serializes information the current object
 * @param CaseHoldOperation The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCaseHoldOperation(writer: SerializationWriter, caseHoldOperation: Partial<CaseHoldOperation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!caseHoldOperation || isSerializingDerivedType) { return; }
    serializeCaseOperation(writer, caseHoldOperation, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param CaseIndexOperation The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCaseIndexOperation(writer: SerializationWriter, caseIndexOperation: Partial<CaseIndexOperation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!caseIndexOperation || isSerializingDerivedType) { return; }
    serializeCaseOperation(writer, caseIndexOperation, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param CaseOperation The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCaseOperation(writer: SerializationWriter, caseOperation: Partial<CaseOperation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!caseOperation || isSerializingDerivedType) { return; }
    serializeEntity(writer, caseOperation, isSerializingDerivedType)
    writer.writeEnumValue<CaseAction>("action", caseOperation.action);
    writer.writeDateValue("completedDateTime", caseOperation.completedDateTime);
    writer.writeObjectValue<IdentitySet>("createdBy", caseOperation.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", caseOperation.createdDateTime);
    writer.writeNumberValue("percentProgress", caseOperation.percentProgress);
    writer.writeObjectValue<ResultInfo>("resultInfo", caseOperation.resultInfo, serializeResultInfo);
    writer.writeEnumValue<CaseOperationStatus>("status", caseOperation.status);
    switch (caseOperation.odataType) {
        case "#microsoft.graph.ediscovery.addToReviewSetOperation":
            serializeAddToReviewSetOperation(writer, caseOperation as AddToReviewSetOperation, true);
        break;
        case "#microsoft.graph.ediscovery.caseExportOperation":
            serializeCaseExportOperation(writer, caseOperation as CaseExportOperation, true);
        break;
        case "#microsoft.graph.ediscovery.caseHoldOperation":
            serializeCaseHoldOperation(writer, caseOperation as CaseHoldOperation, true);
        break;
        case "#microsoft.graph.ediscovery.caseIndexOperation":
            serializeCaseIndexOperation(writer, caseOperation as CaseIndexOperation, true);
        break;
        case "#microsoft.graph.ediscovery.estimateStatisticsOperation":
            serializeEstimateStatisticsOperation(writer, caseOperation as EstimateStatisticsOperation, true);
        break;
        case "#microsoft.graph.ediscovery.purgeDataOperation":
            serializePurgeDataOperation(writer, caseOperation as PurgeDataOperation, true);
        break;
        case "#microsoft.graph.ediscovery.tagOperation":
            serializeTagOperation(writer, caseOperation as TagOperation, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param CaseOperationCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCaseOperationCollectionResponse(writer: SerializationWriter, caseOperationCollectionResponse: Partial<CaseOperationCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!caseOperationCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, caseOperationCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<CaseOperation>("value", caseOperationCollectionResponse.value, serializeCaseOperation);
}
/**
 * Serializes information the current object
 * @param CaseSettings The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCaseSettings(writer: SerializationWriter, caseSettings: Partial<CaseSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!caseSettings || isSerializingDerivedType) { return; }
    serializeEntity(writer, caseSettings, isSerializingDerivedType)
    writer.writeObjectValue<OcrSettings>("ocr", caseSettings.ocr, serializeOcrSettings);
    writer.writeObjectValue<RedundancyDetectionSettings>("redundancyDetection", caseSettings.redundancyDetection, serializeRedundancyDetectionSettings);
    writer.writeObjectValue<TopicModelingSettings>("topicModeling", caseSettings.topicModeling, serializeTopicModelingSettings);
}
/**
 * Serializes information the current object
 * @param Custodian The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCustodian(writer: SerializationWriter, custodian: Partial<Custodian> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!custodian || isSerializingDerivedType) { return; }
    serializeDataSourceContainer(writer, custodian, isSerializingDerivedType)
    writer.writeDateValue("acknowledgedDateTime", custodian.acknowledgedDateTime);
    writer.writeBooleanValue("applyHoldToSources", custodian.applyHoldToSources);
    writer.writeStringValue("email", custodian.email);
    writer.writeCollectionOfObjectValues<SiteSource>("siteSources", custodian.siteSources, serializeSiteSource);
    writer.writeCollectionOfObjectValues<UnifiedGroupSource>("unifiedGroupSources", custodian.unifiedGroupSources, serializeUnifiedGroupSource);
    writer.writeCollectionOfObjectValues<UserSource>("userSources", custodian.userSources, serializeUserSource);
}
/**
 * Serializes information the current object
 * @param CustodianCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCustodianCollectionResponse(writer: SerializationWriter, custodianCollectionResponse: Partial<CustodianCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!custodianCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, custodianCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Custodian>("value", custodianCollectionResponse.value, serializeCustodian);
}
/**
 * Serializes information the current object
 * @param DataSource The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDataSource(writer: SerializationWriter, dataSource: Partial<DataSource> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!dataSource || isSerializingDerivedType) { return; }
    serializeEntity(writer, dataSource, isSerializingDerivedType)
    writer.writeObjectValue<IdentitySet>("createdBy", dataSource.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", dataSource.createdDateTime);
    writer.writeStringValue("displayName", dataSource.displayName);
    writer.writeEnumValue<DataSourceHoldStatus>("holdStatus", dataSource.holdStatus);
    switch (dataSource.odataType) {
        case "#microsoft.graph.ediscovery.siteSource":
            serializeSiteSource(writer, dataSource as SiteSource, true);
        break;
        case "#microsoft.graph.ediscovery.unifiedGroupSource":
            serializeUnifiedGroupSource(writer, dataSource as UnifiedGroupSource, true);
        break;
        case "#microsoft.graph.ediscovery.userSource":
            serializeUserSource(writer, dataSource as UserSource, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param DataSourceCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDataSourceCollectionResponse(writer: SerializationWriter, dataSourceCollectionResponse: Partial<DataSourceCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!dataSourceCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, dataSourceCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<DataSource>("value", dataSourceCollectionResponse.value, serializeDataSource);
}
/**
 * Serializes information the current object
 * @param DataSourceContainer The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDataSourceContainer(writer: SerializationWriter, dataSourceContainer: Partial<DataSourceContainer> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!dataSourceContainer || isSerializingDerivedType) { return; }
    serializeEntity(writer, dataSourceContainer, isSerializingDerivedType)
    writer.writeDateValue("createdDateTime", dataSourceContainer.createdDateTime);
    writer.writeStringValue("displayName", dataSourceContainer.displayName);
    writer.writeEnumValue<DataSourceHoldStatus>("holdStatus", dataSourceContainer.holdStatus);
    writer.writeObjectValue<CaseIndexOperation>("lastIndexOperation", dataSourceContainer.lastIndexOperation, serializeCaseIndexOperation);
    writer.writeDateValue("lastModifiedDateTime", dataSourceContainer.lastModifiedDateTime);
    writer.writeDateValue("releasedDateTime", dataSourceContainer.releasedDateTime);
    writer.writeEnumValue<DataSourceContainerStatus>("status", dataSourceContainer.status);
    switch (dataSourceContainer.odataType) {
        case "#microsoft.graph.ediscovery.custodian":
            serializeCustodian(writer, dataSourceContainer as Custodian, true);
        break;
        case "#microsoft.graph.ediscovery.noncustodialDataSource":
            serializeNoncustodialDataSource(writer, dataSourceContainer as NoncustodialDataSource, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param Ediscoveryroot The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEdiscoveryroot(writer: SerializationWriter, ediscoveryroot: Partial<Ediscoveryroot> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!ediscoveryroot || isSerializingDerivedType) { return; }
    serializeEntity(writer, ediscoveryroot, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<CaseEscaped>("cases", ediscoveryroot.cases, serializeCaseEscaped);
}
/**
 * Serializes information the current object
 * @param EstimateStatisticsOperation The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEstimateStatisticsOperation(writer: SerializationWriter, estimateStatisticsOperation: Partial<EstimateStatisticsOperation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!estimateStatisticsOperation || isSerializingDerivedType) { return; }
    serializeCaseOperation(writer, estimateStatisticsOperation, isSerializingDerivedType)
    writer.writeNumberValue("indexedItemCount", estimateStatisticsOperation.indexedItemCount);
    writer.writeNumberValue("indexedItemsSize", estimateStatisticsOperation.indexedItemsSize);
    writer.writeNumberValue("mailboxCount", estimateStatisticsOperation.mailboxCount);
    writer.writeNumberValue("siteCount", estimateStatisticsOperation.siteCount);
    writer.writeObjectValue<SourceCollection>("sourceCollection", estimateStatisticsOperation.sourceCollection, serializeSourceCollection);
    writer.writeNumberValue("unindexedItemCount", estimateStatisticsOperation.unindexedItemCount);
    writer.writeNumberValue("unindexedItemsSize", estimateStatisticsOperation.unindexedItemsSize);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param LegalHold The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeLegalHold(writer: SerializationWriter, legalHold: Partial<LegalHold> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!legalHold || isSerializingDerivedType) { return; }
    serializeEntity(writer, legalHold, isSerializingDerivedType)
    writer.writeStringValue("contentQuery", legalHold.contentQuery);
    writer.writeObjectValue<IdentitySet>("createdBy", legalHold.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", legalHold.createdDateTime);
    writer.writeStringValue("description", legalHold.description);
    writer.writeStringValue("displayName", legalHold.displayName);
    writer.writeCollectionOfPrimitiveValues<string>("errors", legalHold.errors);
    writer.writeBooleanValue("isEnabled", legalHold.isEnabled);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", legalHold.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", legalHold.lastModifiedDateTime);
    writer.writeCollectionOfObjectValues<SiteSource>("siteSources", legalHold.siteSources, serializeSiteSource);
    writer.writeEnumValue<LegalHoldStatus>("status", legalHold.status);
    writer.writeCollectionOfObjectValues<UnifiedGroupSource>("unifiedGroupSources", legalHold.unifiedGroupSources, serializeUnifiedGroupSource);
    writer.writeCollectionOfObjectValues<UserSource>("userSources", legalHold.userSources, serializeUserSource);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param LegalHoldCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeLegalHoldCollectionResponse(writer: SerializationWriter, legalHoldCollectionResponse: Partial<LegalHoldCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!legalHoldCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, legalHoldCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<LegalHold>("value", legalHoldCollectionResponse.value, serializeLegalHold);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param NoncustodialDataSource The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeNoncustodialDataSource(writer: SerializationWriter, noncustodialDataSource: Partial<NoncustodialDataSource> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!noncustodialDataSource || isSerializingDerivedType) { return; }
    serializeDataSourceContainer(writer, noncustodialDataSource, isSerializingDerivedType)
    writer.writeBooleanValue("applyHoldToSource", noncustodialDataSource.applyHoldToSource);
    writer.writeObjectValue<DataSource>("dataSource", noncustodialDataSource.dataSource, serializeDataSource);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param NoncustodialDataSourceCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeNoncustodialDataSourceCollectionResponse(writer: SerializationWriter, noncustodialDataSourceCollectionResponse: Partial<NoncustodialDataSourceCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!noncustodialDataSourceCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, noncustodialDataSourceCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<NoncustodialDataSource>("value", noncustodialDataSourceCollectionResponse.value, serializeNoncustodialDataSource);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param OcrSettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeOcrSettings(writer: SerializationWriter, ocrSettings: Partial<OcrSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!ocrSettings || isSerializingDerivedType) { return; }
    writer.writeBooleanValue("isEnabled", ocrSettings.isEnabled);
    writer.writeNumberValue("maxImageSize", ocrSettings.maxImageSize);
    writer.writeStringValue("@odata.type", ocrSettings.odataType);
    writer.writeDurationValue("timeout", ocrSettings.timeout);
    writer.writeAdditionalData(ocrSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PurgeDataOperation The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePurgeDataOperation(writer: SerializationWriter, purgeDataOperation: Partial<PurgeDataOperation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!purgeDataOperation || isSerializingDerivedType) { return; }
    serializeCaseOperation(writer, purgeDataOperation, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RedundancyDetectionSettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRedundancyDetectionSettings(writer: SerializationWriter, redundancyDetectionSettings: Partial<RedundancyDetectionSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!redundancyDetectionSettings || isSerializingDerivedType) { return; }
    writer.writeBooleanValue("isEnabled", redundancyDetectionSettings.isEnabled);
    writer.writeNumberValue("maxWords", redundancyDetectionSettings.maxWords);
    writer.writeNumberValue("minWords", redundancyDetectionSettings.minWords);
    writer.writeStringValue("@odata.type", redundancyDetectionSettings.odataType);
    writer.writeNumberValue("similarityThreshold", redundancyDetectionSettings.similarityThreshold);
    writer.writeAdditionalData(redundancyDetectionSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ReviewSet The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeReviewSet(writer: SerializationWriter, reviewSet: Partial<ReviewSet> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!reviewSet || isSerializingDerivedType) { return; }
    serializeEntity(writer, reviewSet, isSerializingDerivedType)
    writer.writeObjectValue<IdentitySet>("createdBy", reviewSet.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", reviewSet.createdDateTime);
    writer.writeStringValue("displayName", reviewSet.displayName);
    writer.writeCollectionOfObjectValues<ReviewSetQuery>("queries", reviewSet.queries, serializeReviewSetQuery);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ReviewSetCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeReviewSetCollectionResponse(writer: SerializationWriter, reviewSetCollectionResponse: Partial<ReviewSetCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!reviewSetCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, reviewSetCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ReviewSet>("value", reviewSetCollectionResponse.value, serializeReviewSet);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ReviewSetQuery The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeReviewSetQuery(writer: SerializationWriter, reviewSetQuery: Partial<ReviewSetQuery> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!reviewSetQuery || isSerializingDerivedType) { return; }
    serializeEntity(writer, reviewSetQuery, isSerializingDerivedType)
    writer.writeObjectValue<IdentitySet>("createdBy", reviewSetQuery.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", reviewSetQuery.createdDateTime);
    writer.writeStringValue("displayName", reviewSetQuery.displayName);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", reviewSetQuery.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", reviewSetQuery.lastModifiedDateTime);
    writer.writeStringValue("query", reviewSetQuery.query);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ReviewSetQueryCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeReviewSetQueryCollectionResponse(writer: SerializationWriter, reviewSetQueryCollectionResponse: Partial<ReviewSetQueryCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!reviewSetQueryCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, reviewSetQueryCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<ReviewSetQuery>("value", reviewSetQueryCollectionResponse.value, serializeReviewSetQuery);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SiteSource The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSiteSource(writer: SerializationWriter, siteSource: Partial<SiteSource> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!siteSource || isSerializingDerivedType) { return; }
    serializeDataSource(writer, siteSource, isSerializingDerivedType)
    writer.writeObjectValue<Site>("site", siteSource.site, serializeSite);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SiteSourceCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSiteSourceCollectionResponse(writer: SerializationWriter, siteSourceCollectionResponse: Partial<SiteSourceCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!siteSourceCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, siteSourceCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<SiteSource>("value", siteSourceCollectionResponse.value, serializeSiteSource);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SourceCollection The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSourceCollection(writer: SerializationWriter, sourceCollection: Partial<SourceCollection> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!sourceCollection || isSerializingDerivedType) { return; }
    serializeEntity(writer, sourceCollection, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<DataSource>("additionalSources", sourceCollection.additionalSources, serializeDataSource);
    writer.writeObjectValue<AddToReviewSetOperation>("addToReviewSetOperation", sourceCollection.addToReviewSetOperation, serializeAddToReviewSetOperation);
    writer.writeStringValue("contentQuery", sourceCollection.contentQuery);
    writer.writeObjectValue<IdentitySet>("createdBy", sourceCollection.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", sourceCollection.createdDateTime);
    writer.writeCollectionOfObjectValues<DataSource>("custodianSources", sourceCollection.custodianSources, serializeDataSource);
    writer.writeEnumValue<DataSourceScopes[]>("dataSourceScopes", sourceCollection.dataSourceScopes);
    writer.writeStringValue("description", sourceCollection.description);
    writer.writeStringValue("displayName", sourceCollection.displayName);
    writer.writeObjectValue<EstimateStatisticsOperation>("lastEstimateStatisticsOperation", sourceCollection.lastEstimateStatisticsOperation, serializeEstimateStatisticsOperation);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", sourceCollection.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", sourceCollection.lastModifiedDateTime);
    writer.writeCollectionOfObjectValues<NoncustodialDataSource>("noncustodialSources", sourceCollection.noncustodialSources, serializeNoncustodialDataSource);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SourceCollectionCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSourceCollectionCollectionResponse(writer: SerializationWriter, sourceCollectionCollectionResponse: Partial<SourceCollectionCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!sourceCollectionCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, sourceCollectionCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<SourceCollection>("value", sourceCollectionCollectionResponse.value, serializeSourceCollection);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Tag The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTag(writer: SerializationWriter, tag: Partial<Tag> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tag || isSerializingDerivedType) { return; }
    serializeEntity(writer, tag, isSerializingDerivedType)
    writer.writeEnumValue<ChildSelectability>("childSelectability", tag.childSelectability);
    writer.writeCollectionOfObjectValues<Tag>("childTags", tag.childTags, serializeTag);
    writer.writeObjectValue<IdentitySet>("createdBy", tag.createdBy, serializeIdentitySet);
    writer.writeStringValue("description", tag.description);
    writer.writeStringValue("displayName", tag.displayName);
    writer.writeDateValue("lastModifiedDateTime", tag.lastModifiedDateTime);
    writer.writeObjectValue<Tag>("parent", tag.parent, serializeTag);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TagCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTagCollectionResponse(writer: SerializationWriter, tagCollectionResponse: Partial<TagCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tagCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, tagCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Tag>("value", tagCollectionResponse.value, serializeTag);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TagOperation The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTagOperation(writer: SerializationWriter, tagOperation: Partial<TagOperation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tagOperation || isSerializingDerivedType) { return; }
    serializeCaseOperation(writer, tagOperation, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TopicModelingSettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTopicModelingSettings(writer: SerializationWriter, topicModelingSettings: Partial<TopicModelingSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!topicModelingSettings || isSerializingDerivedType) { return; }
    writer.writeBooleanValue("dynamicallyAdjustTopicCount", topicModelingSettings.dynamicallyAdjustTopicCount);
    writer.writeBooleanValue("ignoreNumbers", topicModelingSettings.ignoreNumbers);
    writer.writeBooleanValue("isEnabled", topicModelingSettings.isEnabled);
    writer.writeStringValue("@odata.type", topicModelingSettings.odataType);
    writer.writeNumberValue("topicCount", topicModelingSettings.topicCount);
    writer.writeAdditionalData(topicModelingSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UnifiedGroupSource The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUnifiedGroupSource(writer: SerializationWriter, unifiedGroupSource: Partial<UnifiedGroupSource> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!unifiedGroupSource || isSerializingDerivedType) { return; }
    serializeDataSource(writer, unifiedGroupSource, isSerializingDerivedType)
    writer.writeObjectValue<Group>("group", unifiedGroupSource.group, serializeGroup);
    writer.writeEnumValue<SourceType[]>("includedSources", unifiedGroupSource.includedSources);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UnifiedGroupSourceCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUnifiedGroupSourceCollectionResponse(writer: SerializationWriter, unifiedGroupSourceCollectionResponse: Partial<UnifiedGroupSourceCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!unifiedGroupSourceCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, unifiedGroupSourceCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<UnifiedGroupSource>("value", unifiedGroupSourceCollectionResponse.value, serializeUnifiedGroupSource);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UserSource The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUserSource(writer: SerializationWriter, userSource: Partial<UserSource> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!userSource || isSerializingDerivedType) { return; }
    serializeDataSource(writer, userSource, isSerializingDerivedType)
    writer.writeStringValue("email", userSource.email);
    writer.writeEnumValue<SourceType[]>("includedSources", userSource.includedSources);
    writer.writeStringValue("siteWebUrl", userSource.siteWebUrl);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UserSourceCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUserSourceCollectionResponse(writer: SerializationWriter, userSourceCollectionResponse: Partial<UserSourceCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!userSourceCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, userSourceCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<UserSource>("value", userSourceCollectionResponse.value, serializeUserSource);
}
export interface SiteSource extends DataSource, Parsable {
    /**
     * The site property
     */
    site?: Site | null;
}
export interface SiteSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: SiteSource[] | null;
}
export interface SourceCollection extends Entity, Parsable {
    /**
     * Adds an additional source to the sourceCollection.
     */
    additionalSources?: DataSource[] | null;
    /**
     * Adds the results of the sourceCollection to the specified reviewSet.
     */
    addToReviewSetOperation?: AddToReviewSetOperation | null;
    /**
     * The query string in KQL (Keyword Query Language) query. For details, see Keyword queries and search conditions for Content Search and eDiscovery. You can refine searches by using fields paired with values; for example, subject:'Quarterly Financials' AND Date>=06/01/2016 AND Date<=07/01/2016.
     */
    contentQuery?: string | null;
    /**
     * The user who created the sourceCollection.
     */
    createdBy?: IdentitySet | null;
    /**
     * The date and time the sourceCollection was created.
     */
    createdDateTime?: Date | null;
    /**
     * Custodian sources that are included in the sourceCollection.
     */
    custodianSources?: DataSource[] | null;
    /**
     * When specified, the collection spans across a service for an entire workload. Possible values are: none, allTenantMailboxes, allTenantSites, allCaseCustodians, allCaseNoncustodialDataSources.
     */
    dataSourceScopes?: DataSourceScopes[] | null;
    /**
     * The description of the sourceCollection.
     */
    description?: string | null;
    /**
     * The display name of the sourceCollection.
     */
    displayName?: string | null;
    /**
     * The last estimate operation associated with the sourceCollection.
     */
    lastEstimateStatisticsOperation?: EstimateStatisticsOperation | null;
    /**
     * The last user who modified the sourceCollection.
     */
    lastModifiedBy?: IdentitySet | null;
    /**
     * The last date and time the sourceCollection was modified.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * noncustodialDataSource sources that are included in the sourceCollection
     */
    noncustodialSources?: NoncustodialDataSource[] | null;
}
export interface SourceCollectionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: SourceCollection[] | null;
}
export type SourceType = (typeof SourceTypeObject)[keyof typeof SourceTypeObject];
export interface Tag extends Entity, Parsable {
    /**
     * Indicates whether a single or multiple child tags can be associated with a document. Possible values are: One, Many.  This value controls whether the UX presents the tags as checkboxes or a radio button group.
     */
    childSelectability?: ChildSelectability | null;
    /**
     * Returns the tags that are a child of a tag.
     */
    childTags?: Tag[] | null;
    /**
     * The user who created the tag.
     */
    createdBy?: IdentitySet | null;
    /**
     * The description for the tag.
     */
    description?: string | null;
    /**
     * Display name of the tag.
     */
    displayName?: string | null;
    /**
     * The date and time the tag was last modified.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * Returns the parent tag of the specified tag.
     */
    parent?: Tag | null;
}
export interface TagCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Tag[] | null;
}
export interface TagOperation extends CaseOperation, Parsable {
}
export interface TopicModelingSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * To learn more, see Adjust maximum number of themes dynamically.
     */
    dynamicallyAdjustTopicCount?: boolean | null;
    /**
     * To learn more, see Include numbers in themes.
     */
    ignoreNumbers?: boolean | null;
    /**
     * Indicates whether themes are enabled for the case.
     */
    isEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * To learn more, see Maximum number of themes.
     */
    topicCount?: number | null;
}
export interface UnifiedGroupSource extends DataSource, Parsable {
    /**
     * The group property
     */
    group?: Group | null;
    /**
     * Specifies which sources are included in this group. Possible values are: mailbox, site.
     */
    includedSources?: SourceType[] | null;
}
export interface UnifiedGroupSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UnifiedGroupSource[] | null;
}
export interface UserSource extends DataSource, Parsable {
    /**
     * Email address of the user's mailbox.
     */
    email?: string | null;
    /**
     * Specifies which sources are included in this group. Possible values are: mailbox, site.
     */
    includedSources?: SourceType[] | null;
    /**
     * The URL of the user's OneDrive for Business site. Read-only.
     */
    siteWebUrl?: string | null;
}
export interface UserSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UserSource[] | null;
}
export const AdditionalDataOptionsObject = {
    AllVersions: "allVersions",
    LinkedFiles: "linkedFiles",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const CaseActionObject = {
    ContentExport: "contentExport",
    ApplyTags: "applyTags",
    ConvertToPdf: "convertToPdf",
    Index: "index",
    EstimateStatistics: "estimateStatistics",
    AddToReviewSet: "addToReviewSet",
    HoldUpdate: "holdUpdate",
    UnknownFutureValue: "unknownFutureValue",
    PurgeData: "purgeData",
} as const;
export const CaseOperationStatusObject = {
    NotStarted: "notStarted",
    SubmissionFailed: "submissionFailed",
    Running: "running",
    Succeeded: "succeeded",
    PartiallySucceeded: "partiallySucceeded",
    Failed: "failed",
} as const;
export const CaseStatusObject = {
    Unknown: "unknown",
    Active: "active",
    PendingDelete: "pendingDelete",
    Closing: "closing",
    Closed: "closed",
    ClosedWithError: "closedWithError",
} as const;
export const ChildSelectabilityObject = {
    One: "One",
    Many: "Many",
} as const;
export const DataSourceContainerStatusObject = {
    Active: "Active",
    Released: "Released",
    UnknownFutureValue: "UnknownFutureValue",
} as const;
export const DataSourceHoldStatusObject = {
    NotApplied: "notApplied",
    Applied: "applied",
    Applying: "applying",
    Removing: "removing",
    Partial: "partial",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DataSourceScopesObject = {
    None: "none",
    AllTenantMailboxes: "allTenantMailboxes",
    AllTenantSites: "allTenantSites",
    AllCaseCustodians: "allCaseCustodians",
    AllCaseNoncustodialDataSources: "allCaseNoncustodialDataSources",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ExportFileStructureObject = {
    None: "none",
    Directory: "directory",
    Pst: "pst",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ExportOptionsObject = {
    OriginalFiles: "originalFiles",
    Text: "text",
    PdfReplacement: "pdfReplacement",
    FileInfo: "fileInfo",
    Tags: "tags",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const LegalHoldStatusObject = {
    Pending: "Pending",
    ErrorEscaped: "Error",
    Success: "Success",
    UnknownFutureValue: "UnknownFutureValue",
} as const;
export const SourceTypeObject = {
    Mailbox: "mailbox",
    Site: "site",
} as const;
/* tslint:enable */
/* eslint-enable */
