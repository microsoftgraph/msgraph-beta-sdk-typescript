/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
import { createGroupFromDiscriminatorValue, createIdentitySetFromDiscriminatorValue, createResultInfoFromDiscriminatorValue, createSiteFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, serializeGroup, serializeIdentitySet, serializeResultInfo, serializeSite, type BaseCollectionPaginationCountResponse, type Entity, type Group, type IdentitySet, type ResultInfo, type Site } from '../';
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Duration, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export type AdditionalDataOptions = (typeof AdditionalDataOptionsObject)[keyof typeof AdditionalDataOptionsObject];
export interface AddToReviewSetOperation extends CaseOperation, Parsable {
    /**
     * The review set to which items matching the source collection query are added to.
     */
    reviewSet?: ReviewSet;
    /**
     * The sourceCollection that items are being added from.
     */
    sourceCollection?: SourceCollection;
}
export type CaseAction = (typeof CaseActionObject)[keyof typeof CaseActionObject];
export interface CaseCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CaseEscaped[];
}
export interface CaseEscaped extends Entity, Parsable {
    /**
     * The user who closed the case.
     */
    closedBy?: IdentitySet;
    /**
     * The date and time when the case was closed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    closedDateTime?: Date;
    /**
     * The date and time when the entity was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    createdDateTime?: Date;
    /**
     * Returns a list of case custodian objects for this case.  Nullable.
     */
    custodians?: Custodian[];
    /**
     * The case description.
     */
    description?: string;
    /**
     * The case name.
     */
    displayName?: string;
    /**
     * The external case number for customer reference.
     */
    externalId?: string;
    /**
     * The last user who modified the entity.
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The latest date and time when the case was modified. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    lastModifiedDateTime?: Date;
    /**
     * Returns a list of case legalHold objects for this case.  Nullable.
     */
    legalHolds?: LegalHold[];
    /**
     * Returns a list of case noncustodialDataSource objects for this case.  Nullable.
     */
    noncustodialDataSources?: NoncustodialDataSource[];
    /**
     * Returns a list of case operation objects for this case. Nullable.
     */
    operations?: CaseOperation[];
    /**
     * Returns a list of reviewSet objects in the case. Read-only. Nullable.
     */
    reviewSets?: ReviewSet[];
    /**
     * The settings property
     */
    settings?: CaseSettings;
    /**
     * Returns a list of sourceCollection objects associated with this case.
     */
    sourceCollections?: SourceCollection[];
    /**
     * The case status. Possible values are unknown, active, pendingDelete, closing, closed, and closedWithError. For details, see the following table.
     */
    status?: CaseStatus;
    /**
     * Returns a list of tag objects associated to this case.
     */
    tags?: Tag[];
}
export interface CaseExportOperation extends CaseOperation, Parsable {
    /**
     * The name of the Azure storage location where the export will be stored. This only applies to exports stored in your own Azure storage location.
     */
    azureBlobContainer?: string;
    /**
     * The SAS token for the Azure storage location.  This only applies to exports stored in your own Azure storage location.
     */
    azureBlobToken?: string;
    /**
     * The description provided for the export.
     */
    description?: string;
    /**
     * The options provided for the export. For more information, see reviewSet: export. Possible values are: originalFiles, text, pdfReplacement, fileInfo, tags.
     */
    exportOptions?: ExportOptions[];
    /**
     * The options provided specify the structure of the export. For more information, see reviewSet: export. Possible values are: none, directory, pst.
     */
    exportStructure?: ExportFileStructure;
    /**
     * The outputFolderId property
     */
    outputFolderId?: string;
    /**
     * The name provided for the export.
     */
    outputName?: string;
    /**
     * The review set the content is being exported from.
     */
    reviewSet?: ReviewSet;
}
export interface CaseExportOperationCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CaseExportOperation[];
}
export interface CaseHoldOperation extends CaseOperation, Parsable {
}
export interface CaseIndexOperation extends CaseOperation, Parsable {
}
export interface CaseOperation extends Entity, Parsable {
    /**
     * The type of action the operation represents. Possible values are: addToReviewSet,applyTags,contentExport,convertToPdf,estimateStatistics, purgeData
     */
    action?: CaseAction;
    /**
     * The date and time the operation was completed.
     */
    completedDateTime?: Date;
    /**
     * The user that created the operation.
     */
    createdBy?: IdentitySet;
    /**
     * The date and time the operation was created.
     */
    createdDateTime?: Date;
    /**
     * The progress of the operation.
     */
    percentProgress?: number;
    /**
     * Contains success and failure-specific result information.
     */
    resultInfo?: ResultInfo;
    /**
     * The status of the case operation. Possible values are: notStarted, submissionFailed, running, succeeded, partiallySucceeded, failed.
     */
    status?: CaseOperationStatus;
}
export interface CaseOperationCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CaseOperation[];
}
export type CaseOperationStatus = (typeof CaseOperationStatusObject)[keyof typeof CaseOperationStatusObject];
export interface CaseSettings extends Entity, Parsable {
    /**
     * The OCR (Optical Character Recognition) settings for the case.
     */
    ocr?: OcrSettings;
    /**
     * The redundancy (near duplicate and email threading) detection settings for the case.
     */
    redundancyDetection?: RedundancyDetectionSettings;
    /**
     * The article Modeling (Themes) settings for the case.
     */
    topicModeling?: TopicModelingSettings;
}
export type CaseStatus = (typeof CaseStatusObject)[keyof typeof CaseStatusObject];
export type ChildSelectability = (typeof ChildSelectabilityObject)[keyof typeof ChildSelectabilityObject];
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a addToReviewSetOperation
 */
export function createAddToReviewSetOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoAddToReviewSetOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a caseCollectionResponse
 */
export function createCaseCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCaseCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a caseEscaped
 */
export function createCaseEscapedFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCaseEscaped;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a caseExportOperationCollectionResponse
 */
export function createCaseExportOperationCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCaseExportOperationCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a caseExportOperation
 */
export function createCaseExportOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCaseExportOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a caseHoldOperation
 */
export function createCaseHoldOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCaseHoldOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a caseIndexOperation
 */
export function createCaseIndexOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCaseIndexOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a caseOperationCollectionResponse
 */
export function createCaseOperationCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCaseOperationCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a caseOperation
 */
export function createCaseOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.ediscovery.addToReviewSetOperation":
                    return deserializeIntoAddToReviewSetOperation;
                case "#microsoft.graph.ediscovery.caseExportOperation":
                    return deserializeIntoCaseExportOperation;
                case "#microsoft.graph.ediscovery.caseHoldOperation":
                    return deserializeIntoCaseHoldOperation;
                case "#microsoft.graph.ediscovery.caseIndexOperation":
                    return deserializeIntoCaseIndexOperation;
                case "#microsoft.graph.ediscovery.estimateStatisticsOperation":
                    return deserializeIntoEstimateStatisticsOperation;
                case "#microsoft.graph.ediscovery.purgeDataOperation":
                    return deserializeIntoPurgeDataOperation;
                case "#microsoft.graph.ediscovery.tagOperation":
                    return deserializeIntoTagOperation;
            }
        }
    }
    return deserializeIntoCaseOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a caseSettings
 */
export function createCaseSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCaseSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a custodianCollectionResponse
 */
export function createCustodianCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCustodianCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a custodian
 */
export function createCustodianFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCustodian;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a dataSourceCollectionResponse
 */
export function createDataSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoDataSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a dataSourceContainer
 */
export function createDataSourceContainerFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.ediscovery.custodian":
                    return deserializeIntoCustodian;
                case "#microsoft.graph.ediscovery.noncustodialDataSource":
                    return deserializeIntoNoncustodialDataSource;
            }
        }
    }
    return deserializeIntoDataSourceContainer;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a dataSource
 */
export function createDataSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.ediscovery.siteSource":
                    return deserializeIntoSiteSource;
                case "#microsoft.graph.ediscovery.unifiedGroupSource":
                    return deserializeIntoUnifiedGroupSource;
                case "#microsoft.graph.ediscovery.userSource":
                    return deserializeIntoUserSource;
            }
        }
    }
    return deserializeIntoDataSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a ediscoveryroot
 */
export function createEdiscoveryrootFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoEdiscoveryroot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a estimateStatisticsOperation
 */
export function createEstimateStatisticsOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoEstimateStatisticsOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a legalHoldCollectionResponse
 */
export function createLegalHoldCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoLegalHoldCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a legalHold
 */
export function createLegalHoldFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoLegalHold;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a noncustodialDataSourceCollectionResponse
 */
export function createNoncustodialDataSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoNoncustodialDataSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a noncustodialDataSource
 */
export function createNoncustodialDataSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoNoncustodialDataSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a ocrSettings
 */
export function createOcrSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoOcrSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a purgeDataOperation
 */
export function createPurgeDataOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoPurgeDataOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a redundancyDetectionSettings
 */
export function createRedundancyDetectionSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoRedundancyDetectionSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a reviewSetCollectionResponse
 */
export function createReviewSetCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoReviewSetCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a reviewSet
 */
export function createReviewSetFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoReviewSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a reviewSetQueryCollectionResponse
 */
export function createReviewSetQueryCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoReviewSetQueryCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a reviewSetQuery
 */
export function createReviewSetQueryFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoReviewSetQuery;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a siteSourceCollectionResponse
 */
export function createSiteSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoSiteSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a siteSource
 */
export function createSiteSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoSiteSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a sourceCollectionCollectionResponse
 */
export function createSourceCollectionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoSourceCollectionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a sourceCollection
 */
export function createSourceCollectionFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoSourceCollection;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a tagCollectionResponse
 */
export function createTagCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoTagCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a tag
 */
export function createTagFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoTag;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a tagOperation
 */
export function createTagOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoTagOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a topicModelingSettings
 */
export function createTopicModelingSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoTopicModelingSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a unifiedGroupSourceCollectionResponse
 */
export function createUnifiedGroupSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoUnifiedGroupSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a unifiedGroupSource
 */
export function createUnifiedGroupSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoUnifiedGroupSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a userSourceCollectionResponse
 */
export function createUserSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoUserSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a userSource
 */
export function createUserSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoUserSource;
}
export interface Custodian extends DataSourceContainer, Parsable {
    /**
     * Date and time the custodian acknowledged a hold notification.
     */
    acknowledgedDateTime?: Date;
    /**
     * Identifies whether a custodian's sources were placed on hold during creation.
     */
    applyHoldToSources?: boolean;
    /**
     * Email address of the custodian.
     */
    email?: string;
    /**
     * Data source entity for SharePoint sites associated with the custodian.
     */
    siteSources?: SiteSource[];
    /**
     * Data source entity for groups associated with the custodian.
     */
    unifiedGroupSources?: UnifiedGroupSource[];
    /**
     * Data source entity for a the custodian. This is the container for a custodian's mailbox and OneDrive for Business site.
     */
    userSources?: UserSource[];
}
export interface CustodianCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Custodian[];
}
export interface DataSource extends Entity, Parsable {
    /**
     * The user who created the dataSource.
     */
    createdBy?: IdentitySet;
    /**
     * The date and time the dataSource was created.
     */
    createdDateTime?: Date;
    /**
     * The display name of the dataSource, and is the name of the SharePoint site.
     */
    displayName?: string;
    /**
     * The holdStatus property
     */
    holdStatus?: DataSourceHoldStatus;
}
export interface DataSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: DataSource[];
}
export interface DataSourceContainer extends Entity, Parsable {
    /**
     * Created date and time of the dataSourceContainer entity.
     */
    createdDateTime?: Date;
    /**
     * Display name of the dataSourceContainer entity.
     */
    displayName?: string;
    /**
     * The holdStatus property
     */
    holdStatus?: DataSourceHoldStatus;
    /**
     * The lastIndexOperation property
     */
    lastIndexOperation?: CaseIndexOperation;
    /**
     * Last modified date and time of the dataSourceContainer.
     */
    lastModifiedDateTime?: Date;
    /**
     * Date and time that the dataSourceContainer was released from the case.
     */
    releasedDateTime?: Date;
    /**
     * Latest status of the dataSourceContainer. Possible values are: Active, Released.
     */
    status?: DataSourceContainerStatus;
}
export type DataSourceContainerStatus = (typeof DataSourceContainerStatusObject)[keyof typeof DataSourceContainerStatusObject];
export type DataSourceHoldStatus = (typeof DataSourceHoldStatusObject)[keyof typeof DataSourceHoldStatusObject];
export type DataSourceScopes = (typeof DataSourceScopesObject)[keyof typeof DataSourceScopesObject];
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoAddToReviewSetOperation(addToReviewSetOperation: AddToReviewSetOperation | undefined = {} as AddToReviewSetOperation) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(addToReviewSetOperation),
        "reviewSet": n => { addToReviewSetOperation.reviewSet = n.getObjectValue<ReviewSet>(createReviewSetFromDiscriminatorValue); },
        "sourceCollection": n => { addToReviewSetOperation.sourceCollection = n.getObjectValue<SourceCollection>(createSourceCollectionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCaseCollectionResponse(caseCollectionResponse: CaseCollectionResponse | undefined = {} as CaseCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(caseCollectionResponse),
        "value": n => { caseCollectionResponse.value = n.getCollectionOfObjectValues<CaseEscaped>(createCaseEscapedFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCaseEscaped(caseEscaped: CaseEscaped | undefined = {} as CaseEscaped) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(caseEscaped),
        "closedBy": n => { caseEscaped.closedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "closedDateTime": n => { caseEscaped.closedDateTime = n.getDateValue(); },
        "createdDateTime": n => { caseEscaped.createdDateTime = n.getDateValue(); },
        "custodians": n => { caseEscaped.custodians = n.getCollectionOfObjectValues<Custodian>(createCustodianFromDiscriminatorValue); },
        "description": n => { caseEscaped.description = n.getStringValue(); },
        "displayName": n => { caseEscaped.displayName = n.getStringValue(); },
        "externalId": n => { caseEscaped.externalId = n.getStringValue(); },
        "lastModifiedBy": n => { caseEscaped.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { caseEscaped.lastModifiedDateTime = n.getDateValue(); },
        "legalHolds": n => { caseEscaped.legalHolds = n.getCollectionOfObjectValues<LegalHold>(createLegalHoldFromDiscriminatorValue); },
        "noncustodialDataSources": n => { caseEscaped.noncustodialDataSources = n.getCollectionOfObjectValues<NoncustodialDataSource>(createNoncustodialDataSourceFromDiscriminatorValue); },
        "operations": n => { caseEscaped.operations = n.getCollectionOfObjectValues<CaseOperation>(createCaseOperationFromDiscriminatorValue); },
        "reviewSets": n => { caseEscaped.reviewSets = n.getCollectionOfObjectValues<ReviewSet>(createReviewSetFromDiscriminatorValue); },
        "settings": n => { caseEscaped.settings = n.getObjectValue<CaseSettings>(createCaseSettingsFromDiscriminatorValue); },
        "sourceCollections": n => { caseEscaped.sourceCollections = n.getCollectionOfObjectValues<SourceCollection>(createSourceCollectionFromDiscriminatorValue); },
        "status": n => { caseEscaped.status = n.getEnumValue<CaseStatus>(CaseStatusObject); },
        "tags": n => { caseEscaped.tags = n.getCollectionOfObjectValues<Tag>(createTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCaseExportOperation(caseExportOperation: CaseExportOperation | undefined = {} as CaseExportOperation) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(caseExportOperation),
        "azureBlobContainer": n => { caseExportOperation.azureBlobContainer = n.getStringValue(); },
        "azureBlobToken": n => { caseExportOperation.azureBlobToken = n.getStringValue(); },
        "description": n => { caseExportOperation.description = n.getStringValue(); },
        "exportOptions": n => { caseExportOperation.exportOptions = n.getCollectionOfEnumValues<ExportOptions>(ExportOptionsObject); },
        "exportStructure": n => { caseExportOperation.exportStructure = n.getEnumValue<ExportFileStructure>(ExportFileStructureObject); },
        "outputFolderId": n => { caseExportOperation.outputFolderId = n.getStringValue(); },
        "outputName": n => { caseExportOperation.outputName = n.getStringValue(); },
        "reviewSet": n => { caseExportOperation.reviewSet = n.getObjectValue<ReviewSet>(createReviewSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCaseExportOperationCollectionResponse(caseExportOperationCollectionResponse: CaseExportOperationCollectionResponse | undefined = {} as CaseExportOperationCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(caseExportOperationCollectionResponse),
        "value": n => { caseExportOperationCollectionResponse.value = n.getCollectionOfObjectValues<CaseExportOperation>(createCaseExportOperationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCaseHoldOperation(caseHoldOperation: CaseHoldOperation | undefined = {} as CaseHoldOperation) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(caseHoldOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCaseIndexOperation(caseIndexOperation: CaseIndexOperation | undefined = {} as CaseIndexOperation) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(caseIndexOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCaseOperation(caseOperation: CaseOperation | undefined = {} as CaseOperation) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(caseOperation),
        "action": n => { caseOperation.action = n.getEnumValue<CaseAction>(CaseActionObject); },
        "completedDateTime": n => { caseOperation.completedDateTime = n.getDateValue(); },
        "createdBy": n => { caseOperation.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { caseOperation.createdDateTime = n.getDateValue(); },
        "percentProgress": n => { caseOperation.percentProgress = n.getNumberValue(); },
        "resultInfo": n => { caseOperation.resultInfo = n.getObjectValue<ResultInfo>(createResultInfoFromDiscriminatorValue); },
        "status": n => { caseOperation.status = n.getEnumValue<CaseOperationStatus>(CaseOperationStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCaseOperationCollectionResponse(caseOperationCollectionResponse: CaseOperationCollectionResponse | undefined = {} as CaseOperationCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(caseOperationCollectionResponse),
        "value": n => { caseOperationCollectionResponse.value = n.getCollectionOfObjectValues<CaseOperation>(createCaseOperationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCaseSettings(caseSettings: CaseSettings | undefined = {} as CaseSettings) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(caseSettings),
        "ocr": n => { caseSettings.ocr = n.getObjectValue<OcrSettings>(createOcrSettingsFromDiscriminatorValue); },
        "redundancyDetection": n => { caseSettings.redundancyDetection = n.getObjectValue<RedundancyDetectionSettings>(createRedundancyDetectionSettingsFromDiscriminatorValue); },
        "topicModeling": n => { caseSettings.topicModeling = n.getObjectValue<TopicModelingSettings>(createTopicModelingSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCustodian(custodian: Custodian | undefined = {} as Custodian) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSourceContainer(custodian),
        "acknowledgedDateTime": n => { custodian.acknowledgedDateTime = n.getDateValue(); },
        "applyHoldToSources": n => { custodian.applyHoldToSources = n.getBooleanValue(); },
        "email": n => { custodian.email = n.getStringValue(); },
        "siteSources": n => { custodian.siteSources = n.getCollectionOfObjectValues<SiteSource>(createSiteSourceFromDiscriminatorValue); },
        "unifiedGroupSources": n => { custodian.unifiedGroupSources = n.getCollectionOfObjectValues<UnifiedGroupSource>(createUnifiedGroupSourceFromDiscriminatorValue); },
        "userSources": n => { custodian.userSources = n.getCollectionOfObjectValues<UserSource>(createUserSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCustodianCollectionResponse(custodianCollectionResponse: CustodianCollectionResponse | undefined = {} as CustodianCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(custodianCollectionResponse),
        "value": n => { custodianCollectionResponse.value = n.getCollectionOfObjectValues<Custodian>(createCustodianFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoDataSource(dataSource: DataSource | undefined = {} as DataSource) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(dataSource),
        "createdBy": n => { dataSource.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { dataSource.createdDateTime = n.getDateValue(); },
        "displayName": n => { dataSource.displayName = n.getStringValue(); },
        "holdStatus": n => { dataSource.holdStatus = n.getEnumValue<DataSourceHoldStatus>(DataSourceHoldStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoDataSourceCollectionResponse(dataSourceCollectionResponse: DataSourceCollectionResponse | undefined = {} as DataSourceCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(dataSourceCollectionResponse),
        "value": n => { dataSourceCollectionResponse.value = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoDataSourceContainer(dataSourceContainer: DataSourceContainer | undefined = {} as DataSourceContainer) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(dataSourceContainer),
        "createdDateTime": n => { dataSourceContainer.createdDateTime = n.getDateValue(); },
        "displayName": n => { dataSourceContainer.displayName = n.getStringValue(); },
        "holdStatus": n => { dataSourceContainer.holdStatus = n.getEnumValue<DataSourceHoldStatus>(DataSourceHoldStatusObject); },
        "lastIndexOperation": n => { dataSourceContainer.lastIndexOperation = n.getObjectValue<CaseIndexOperation>(createCaseIndexOperationFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { dataSourceContainer.lastModifiedDateTime = n.getDateValue(); },
        "releasedDateTime": n => { dataSourceContainer.releasedDateTime = n.getDateValue(); },
        "status": n => { dataSourceContainer.status = n.getEnumValue<DataSourceContainerStatus>(DataSourceContainerStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoEdiscoveryroot(ediscoveryroot: Ediscoveryroot | undefined = {} as Ediscoveryroot) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(ediscoveryroot),
        "cases": n => { ediscoveryroot.cases = n.getCollectionOfObjectValues<CaseEscaped>(createCaseEscapedFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoEstimateStatisticsOperation(estimateStatisticsOperation: EstimateStatisticsOperation | undefined = {} as EstimateStatisticsOperation) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(estimateStatisticsOperation),
        "indexedItemCount": n => { estimateStatisticsOperation.indexedItemCount = n.getNumberValue(); },
        "indexedItemsSize": n => { estimateStatisticsOperation.indexedItemsSize = n.getNumberValue(); },
        "mailboxCount": n => { estimateStatisticsOperation.mailboxCount = n.getNumberValue(); },
        "siteCount": n => { estimateStatisticsOperation.siteCount = n.getNumberValue(); },
        "sourceCollection": n => { estimateStatisticsOperation.sourceCollection = n.getObjectValue<SourceCollection>(createSourceCollectionFromDiscriminatorValue); },
        "unindexedItemCount": n => { estimateStatisticsOperation.unindexedItemCount = n.getNumberValue(); },
        "unindexedItemsSize": n => { estimateStatisticsOperation.unindexedItemsSize = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoLegalHold(legalHold: LegalHold | undefined = {} as LegalHold) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(legalHold),
        "contentQuery": n => { legalHold.contentQuery = n.getStringValue(); },
        "createdBy": n => { legalHold.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { legalHold.createdDateTime = n.getDateValue(); },
        "description": n => { legalHold.description = n.getStringValue(); },
        "displayName": n => { legalHold.displayName = n.getStringValue(); },
        "errors": n => { legalHold.errors = n.getCollectionOfPrimitiveValues<string>(); },
        "isEnabled": n => { legalHold.isEnabled = n.getBooleanValue(); },
        "lastModifiedBy": n => { legalHold.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { legalHold.lastModifiedDateTime = n.getDateValue(); },
        "siteSources": n => { legalHold.siteSources = n.getCollectionOfObjectValues<SiteSource>(createSiteSourceFromDiscriminatorValue); },
        "status": n => { legalHold.status = n.getEnumValue<LegalHoldStatus>(LegalHoldStatusObject); },
        "unifiedGroupSources": n => { legalHold.unifiedGroupSources = n.getCollectionOfObjectValues<UnifiedGroupSource>(createUnifiedGroupSourceFromDiscriminatorValue); },
        "userSources": n => { legalHold.userSources = n.getCollectionOfObjectValues<UserSource>(createUserSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoLegalHoldCollectionResponse(legalHoldCollectionResponse: LegalHoldCollectionResponse | undefined = {} as LegalHoldCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(legalHoldCollectionResponse),
        "value": n => { legalHoldCollectionResponse.value = n.getCollectionOfObjectValues<LegalHold>(createLegalHoldFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoNoncustodialDataSource(noncustodialDataSource: NoncustodialDataSource | undefined = {} as NoncustodialDataSource) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSourceContainer(noncustodialDataSource),
        "applyHoldToSource": n => { noncustodialDataSource.applyHoldToSource = n.getBooleanValue(); },
        "dataSource": n => { noncustodialDataSource.dataSource = n.getObjectValue<DataSource>(createDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoNoncustodialDataSourceCollectionResponse(noncustodialDataSourceCollectionResponse: NoncustodialDataSourceCollectionResponse | undefined = {} as NoncustodialDataSourceCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(noncustodialDataSourceCollectionResponse),
        "value": n => { noncustodialDataSourceCollectionResponse.value = n.getCollectionOfObjectValues<NoncustodialDataSource>(createNoncustodialDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoOcrSettings(ocrSettings: OcrSettings | undefined = {} as OcrSettings) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { ocrSettings.backingStoreEnabled = true; },
        "isEnabled": n => { ocrSettings.isEnabled = n.getBooleanValue(); },
        "maxImageSize": n => { ocrSettings.maxImageSize = n.getNumberValue(); },
        "@odata.type": n => { ocrSettings.odataType = n.getStringValue(); },
        "timeout": n => { ocrSettings.timeout = n.getDurationValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoPurgeDataOperation(purgeDataOperation: PurgeDataOperation | undefined = {} as PurgeDataOperation) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(purgeDataOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoRedundancyDetectionSettings(redundancyDetectionSettings: RedundancyDetectionSettings | undefined = {} as RedundancyDetectionSettings) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { redundancyDetectionSettings.backingStoreEnabled = true; },
        "isEnabled": n => { redundancyDetectionSettings.isEnabled = n.getBooleanValue(); },
        "maxWords": n => { redundancyDetectionSettings.maxWords = n.getNumberValue(); },
        "minWords": n => { redundancyDetectionSettings.minWords = n.getNumberValue(); },
        "@odata.type": n => { redundancyDetectionSettings.odataType = n.getStringValue(); },
        "similarityThreshold": n => { redundancyDetectionSettings.similarityThreshold = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoReviewSet(reviewSet: ReviewSet | undefined = {} as ReviewSet) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(reviewSet),
        "createdBy": n => { reviewSet.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { reviewSet.createdDateTime = n.getDateValue(); },
        "displayName": n => { reviewSet.displayName = n.getStringValue(); },
        "queries": n => { reviewSet.queries = n.getCollectionOfObjectValues<ReviewSetQuery>(createReviewSetQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoReviewSetCollectionResponse(reviewSetCollectionResponse: ReviewSetCollectionResponse | undefined = {} as ReviewSetCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(reviewSetCollectionResponse),
        "value": n => { reviewSetCollectionResponse.value = n.getCollectionOfObjectValues<ReviewSet>(createReviewSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoReviewSetQuery(reviewSetQuery: ReviewSetQuery | undefined = {} as ReviewSetQuery) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(reviewSetQuery),
        "createdBy": n => { reviewSetQuery.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { reviewSetQuery.createdDateTime = n.getDateValue(); },
        "displayName": n => { reviewSetQuery.displayName = n.getStringValue(); },
        "lastModifiedBy": n => { reviewSetQuery.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { reviewSetQuery.lastModifiedDateTime = n.getDateValue(); },
        "query": n => { reviewSetQuery.query = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoReviewSetQueryCollectionResponse(reviewSetQueryCollectionResponse: ReviewSetQueryCollectionResponse | undefined = {} as ReviewSetQueryCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(reviewSetQueryCollectionResponse),
        "value": n => { reviewSetQueryCollectionResponse.value = n.getCollectionOfObjectValues<ReviewSetQuery>(createReviewSetQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoSiteSource(siteSource: SiteSource | undefined = {} as SiteSource) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(siteSource),
        "site": n => { siteSource.site = n.getObjectValue<Site>(createSiteFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoSiteSourceCollectionResponse(siteSourceCollectionResponse: SiteSourceCollectionResponse | undefined = {} as SiteSourceCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(siteSourceCollectionResponse),
        "value": n => { siteSourceCollectionResponse.value = n.getCollectionOfObjectValues<SiteSource>(createSiteSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoSourceCollection(sourceCollection: SourceCollection | undefined = {} as SourceCollection) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(sourceCollection),
        "additionalSources": n => { sourceCollection.additionalSources = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
        "addToReviewSetOperation": n => { sourceCollection.addToReviewSetOperation = n.getObjectValue<AddToReviewSetOperation>(createAddToReviewSetOperationFromDiscriminatorValue); },
        "contentQuery": n => { sourceCollection.contentQuery = n.getStringValue(); },
        "createdBy": n => { sourceCollection.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { sourceCollection.createdDateTime = n.getDateValue(); },
        "custodianSources": n => { sourceCollection.custodianSources = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
        "dataSourceScopes": n => { sourceCollection.dataSourceScopes = n.getCollectionOfEnumValues<DataSourceScopes>(DataSourceScopesObject); },
        "description": n => { sourceCollection.description = n.getStringValue(); },
        "displayName": n => { sourceCollection.displayName = n.getStringValue(); },
        "lastEstimateStatisticsOperation": n => { sourceCollection.lastEstimateStatisticsOperation = n.getObjectValue<EstimateStatisticsOperation>(createEstimateStatisticsOperationFromDiscriminatorValue); },
        "lastModifiedBy": n => { sourceCollection.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { sourceCollection.lastModifiedDateTime = n.getDateValue(); },
        "noncustodialSources": n => { sourceCollection.noncustodialSources = n.getCollectionOfObjectValues<NoncustodialDataSource>(createNoncustodialDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoSourceCollectionCollectionResponse(sourceCollectionCollectionResponse: SourceCollectionCollectionResponse | undefined = {} as SourceCollectionCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(sourceCollectionCollectionResponse),
        "value": n => { sourceCollectionCollectionResponse.value = n.getCollectionOfObjectValues<SourceCollection>(createSourceCollectionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoTag(tag: Tag | undefined = {} as Tag) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(tag),
        "childSelectability": n => { tag.childSelectability = n.getEnumValue<ChildSelectability>(ChildSelectabilityObject); },
        "childTags": n => { tag.childTags = n.getCollectionOfObjectValues<Tag>(createTagFromDiscriminatorValue); },
        "createdBy": n => { tag.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "description": n => { tag.description = n.getStringValue(); },
        "displayName": n => { tag.displayName = n.getStringValue(); },
        "lastModifiedDateTime": n => { tag.lastModifiedDateTime = n.getDateValue(); },
        "parent": n => { tag.parent = n.getObjectValue<Tag>(createTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoTagCollectionResponse(tagCollectionResponse: TagCollectionResponse | undefined = {} as TagCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(tagCollectionResponse),
        "value": n => { tagCollectionResponse.value = n.getCollectionOfObjectValues<Tag>(createTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoTagOperation(tagOperation: TagOperation | undefined = {} as TagOperation) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(tagOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoTopicModelingSettings(topicModelingSettings: TopicModelingSettings | undefined = {} as TopicModelingSettings) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { topicModelingSettings.backingStoreEnabled = true; },
        "dynamicallyAdjustTopicCount": n => { topicModelingSettings.dynamicallyAdjustTopicCount = n.getBooleanValue(); },
        "ignoreNumbers": n => { topicModelingSettings.ignoreNumbers = n.getBooleanValue(); },
        "isEnabled": n => { topicModelingSettings.isEnabled = n.getBooleanValue(); },
        "@odata.type": n => { topicModelingSettings.odataType = n.getStringValue(); },
        "topicCount": n => { topicModelingSettings.topicCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoUnifiedGroupSource(unifiedGroupSource: UnifiedGroupSource | undefined = {} as UnifiedGroupSource) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(unifiedGroupSource),
        "group": n => { unifiedGroupSource.group = n.getObjectValue<Group>(createGroupFromDiscriminatorValue); },
        "includedSources": n => { unifiedGroupSource.includedSources = n.getCollectionOfEnumValues<SourceType>(SourceTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoUnifiedGroupSourceCollectionResponse(unifiedGroupSourceCollectionResponse: UnifiedGroupSourceCollectionResponse | undefined = {} as UnifiedGroupSourceCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(unifiedGroupSourceCollectionResponse),
        "value": n => { unifiedGroupSourceCollectionResponse.value = n.getCollectionOfObjectValues<UnifiedGroupSource>(createUnifiedGroupSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoUserSource(userSource: UserSource | undefined = {} as UserSource) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(userSource),
        "email": n => { userSource.email = n.getStringValue(); },
        "includedSources": n => { userSource.includedSources = n.getCollectionOfEnumValues<SourceType>(SourceTypeObject); },
        "siteWebUrl": n => { userSource.siteWebUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoUserSourceCollectionResponse(userSourceCollectionResponse: UserSourceCollectionResponse | undefined = {} as UserSourceCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(userSourceCollectionResponse),
        "value": n => { userSourceCollectionResponse.value = n.getCollectionOfObjectValues<UserSource>(createUserSourceFromDiscriminatorValue); },
    }
}
export interface Ediscoveryroot extends Entity, Parsable {
    /**
     * The cases property
     */
    cases?: CaseEscaped[];
}
export interface EstimateStatisticsOperation extends CaseOperation, Parsable {
    /**
     * The estimated count of items for the sourceCollection that matched the content query.
     */
    indexedItemCount?: number;
    /**
     * The estimated size of items for the sourceCollection that matched the content query.
     */
    indexedItemsSize?: number;
    /**
     * The number of mailboxes that had search hits.
     */
    mailboxCount?: number;
    /**
     * The number of mailboxes that had search hits.
     */
    siteCount?: number;
    /**
     * eDiscovery collection, commonly known as a search.
     */
    sourceCollection?: SourceCollection;
    /**
     * The estimated count of unindexed items for the collection.
     */
    unindexedItemCount?: number;
    /**
     * The estimated size of unindexed items for the collection.
     */
    unindexedItemsSize?: number;
}
export type ExportFileStructure = (typeof ExportFileStructureObject)[keyof typeof ExportFileStructureObject];
export type ExportOptions = (typeof ExportOptionsObject)[keyof typeof ExportOptionsObject];
export interface LegalHold extends Entity, Parsable {
    /**
     * KQL query that specifies content to be held in the specified locations. To learn more, see Keyword queries and search conditions for Content Search and eDiscovery.  To hold all content in the specified locations, leave contentQuery blank.
     */
    contentQuery?: string;
    /**
     * The user who created the legal hold.
     */
    createdBy?: IdentitySet;
    /**
     * The date and time the legal hold was created.
     */
    createdDateTime?: Date;
    /**
     * The legal hold description.
     */
    description?: string;
    /**
     * The display name of the legal hold.
     */
    displayName?: string;
    /**
     * Lists any errors that happened while placing the hold.
     */
    errors?: string[];
    /**
     * Indicates whether the hold is enabled and actively holding content.
     */
    isEnabled?: boolean;
    /**
     * the user who last modified the legal hold.
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The date and time the legal hold was last modified.
     */
    lastModifiedDateTime?: Date;
    /**
     * Data source entity for SharePoint sites associated with the legal hold.
     */
    siteSources?: SiteSource[];
    /**
     * The status of the legal hold. Possible values are: Pending, Error, Success, UnknownFutureValue.
     */
    status?: LegalHoldStatus;
    /**
     * The unifiedGroupSources property
     */
    unifiedGroupSources?: UnifiedGroupSource[];
    /**
     * Data source entity for a the legal hold. This is the container for a mailbox and OneDrive for Business site.
     */
    userSources?: UserSource[];
}
export interface LegalHoldCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: LegalHold[];
}
export type LegalHoldStatus = (typeof LegalHoldStatusObject)[keyof typeof LegalHoldStatusObject];
export interface NoncustodialDataSource extends DataSourceContainer, Parsable {
    /**
     * Indicates if hold is applied to noncustodial data source (such as mailbox or site).
     */
    applyHoldToSource?: boolean;
    /**
     * User source or SharePoint site data source as noncustodial data source.
     */
    dataSource?: DataSource;
}
export interface NoncustodialDataSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: NoncustodialDataSource[];
}
export interface OcrSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Indicates whether or not OCR is enabled for the case.
     */
    isEnabled?: boolean;
    /**
     * Maximum image size that will be processed in KB).
     */
    maxImageSize?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The timeout duration for the OCR engine. A longer timeout may increase success of OCR, but may add to the total processing time.
     */
    timeout?: Duration;
}
export interface PurgeDataOperation extends CaseOperation, Parsable {
}
export interface RedundancyDetectionSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Indicates whether email threading and near duplicate detection are enabled.
     */
    isEnabled?: boolean;
    /**
     * Specifies the maximum number of words used for email threading and near duplicate detection. To learn more, see Minimum/maximum number of words.
     */
    maxWords?: number;
    /**
     * Specifies the minimum number of words used for email threading and near duplicate detection. To learn more, see Minimum/maximum number of words.
     */
    minWords?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Specifies the similarity level for documents to be put in the same near duplicate set. To learn more, see Document and email similarity threshold.
     */
    similarityThreshold?: number;
}
export interface ReviewSet extends Entity, Parsable {
    /**
     * The user who created the review set. Read-only.
     */
    createdBy?: IdentitySet;
    /**
     * The datetime when the review set was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    createdDateTime?: Date;
    /**
     * The review set name. The name is unique with a maximum limit of 64 characters.
     */
    displayName?: string;
    /**
     * The queries property
     */
    queries?: ReviewSetQuery[];
}
export interface ReviewSetCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ReviewSet[];
}
export interface ReviewSetQuery extends Entity, Parsable {
    /**
     * The user who created the query.
     */
    createdBy?: IdentitySet;
    /**
     * The time and date when the query was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    createdDateTime?: Date;
    /**
     * The name of the query.
     */
    displayName?: string;
    /**
     * The user who last modified the query.
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The date and time the query was last modified. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    lastModifiedDateTime?: Date;
    /**
     * The query string in KQL (Keyword Query Language) query. For details, see Document metadata fields in Advanced eDiscovery.  This field maps directly to the keywords condition.  You can refine searches by using fields listed in the searchable field name paired with values; for example, subject:'Quarterly Financials' AND Date>=06/01/2016 AND Date<=07/01/2016.
     */
    query?: string;
}
export interface ReviewSetQueryCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ReviewSetQuery[];
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAddToReviewSetOperation(writer: SerializationWriter, addToReviewSetOperation: AddToReviewSetOperation | undefined = {} as AddToReviewSetOperation) : void {
    serializeCaseOperation(writer, addToReviewSetOperation)
    writer.writeObjectValue<ReviewSet>("reviewSet", addToReviewSetOperation.reviewSet, serializeReviewSet);
    writer.writeObjectValue<SourceCollection>("sourceCollection", addToReviewSetOperation.sourceCollection, serializeSourceCollection);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseCollectionResponse(writer: SerializationWriter, caseCollectionResponse: CaseCollectionResponse | undefined = {} as CaseCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, caseCollectionResponse)
    writer.writeCollectionOfObjectValues<CaseEscaped>("value", caseCollectionResponse.value, serializeCaseEscaped);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseEscaped(writer: SerializationWriter, caseEscaped: CaseEscaped | undefined = {} as CaseEscaped) : void {
    serializeEntity(writer, caseEscaped)
    writer.writeObjectValue<IdentitySet>("closedBy", caseEscaped.closedBy, serializeIdentitySet);
    writer.writeDateValue("closedDateTime", caseEscaped.closedDateTime);
    writer.writeDateValue("createdDateTime", caseEscaped.createdDateTime);
    writer.writeCollectionOfObjectValues<Custodian>("custodians", caseEscaped.custodians, serializeCustodian);
    writer.writeStringValue("description", caseEscaped.description);
    writer.writeStringValue("displayName", caseEscaped.displayName);
    writer.writeStringValue("externalId", caseEscaped.externalId);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", caseEscaped.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", caseEscaped.lastModifiedDateTime);
    writer.writeCollectionOfObjectValues<LegalHold>("legalHolds", caseEscaped.legalHolds, serializeLegalHold);
    writer.writeCollectionOfObjectValues<NoncustodialDataSource>("noncustodialDataSources", caseEscaped.noncustodialDataSources, serializeNoncustodialDataSource);
    writer.writeCollectionOfObjectValues<CaseOperation>("operations", caseEscaped.operations, serializeCaseOperation);
    writer.writeCollectionOfObjectValues<ReviewSet>("reviewSets", caseEscaped.reviewSets, serializeReviewSet);
    writer.writeObjectValue<CaseSettings>("settings", caseEscaped.settings, serializeCaseSettings);
    writer.writeCollectionOfObjectValues<SourceCollection>("sourceCollections", caseEscaped.sourceCollections, serializeSourceCollection);
    writer.writeEnumValue<CaseStatus>("status", caseEscaped.status);
    writer.writeCollectionOfObjectValues<Tag>("tags", caseEscaped.tags, serializeTag);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseExportOperation(writer: SerializationWriter, caseExportOperation: CaseExportOperation | undefined = {} as CaseExportOperation) : void {
    serializeCaseOperation(writer, caseExportOperation)
    writer.writeStringValue("azureBlobContainer", caseExportOperation.azureBlobContainer);
    writer.writeStringValue("azureBlobToken", caseExportOperation.azureBlobToken);
    writer.writeStringValue("description", caseExportOperation.description);
    writer.writeEnumValue<ExportOptions[]>("exportOptions", caseExportOperation.exportOptions);
    writer.writeEnumValue<ExportFileStructure>("exportStructure", caseExportOperation.exportStructure);
    writer.writeStringValue("outputFolderId", caseExportOperation.outputFolderId);
    writer.writeStringValue("outputName", caseExportOperation.outputName);
    writer.writeObjectValue<ReviewSet>("reviewSet", caseExportOperation.reviewSet, serializeReviewSet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseExportOperationCollectionResponse(writer: SerializationWriter, caseExportOperationCollectionResponse: CaseExportOperationCollectionResponse | undefined = {} as CaseExportOperationCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, caseExportOperationCollectionResponse)
    writer.writeCollectionOfObjectValues<CaseExportOperation>("value", caseExportOperationCollectionResponse.value, serializeCaseExportOperation);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseHoldOperation(writer: SerializationWriter, caseHoldOperation: CaseHoldOperation | undefined = {} as CaseHoldOperation) : void {
    serializeCaseOperation(writer, caseHoldOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseIndexOperation(writer: SerializationWriter, caseIndexOperation: CaseIndexOperation | undefined = {} as CaseIndexOperation) : void {
    serializeCaseOperation(writer, caseIndexOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseOperation(writer: SerializationWriter, caseOperation: CaseOperation | undefined = {} as CaseOperation) : void {
    serializeEntity(writer, caseOperation)
    writer.writeEnumValue<CaseAction>("action", caseOperation.action);
    writer.writeDateValue("completedDateTime", caseOperation.completedDateTime);
    writer.writeObjectValue<IdentitySet>("createdBy", caseOperation.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", caseOperation.createdDateTime);
    writer.writeNumberValue("percentProgress", caseOperation.percentProgress);
    writer.writeObjectValue<ResultInfo>("resultInfo", caseOperation.resultInfo, serializeResultInfo);
    writer.writeEnumValue<CaseOperationStatus>("status", caseOperation.status);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseOperationCollectionResponse(writer: SerializationWriter, caseOperationCollectionResponse: CaseOperationCollectionResponse | undefined = {} as CaseOperationCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, caseOperationCollectionResponse)
    writer.writeCollectionOfObjectValues<CaseOperation>("value", caseOperationCollectionResponse.value, serializeCaseOperation);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseSettings(writer: SerializationWriter, caseSettings: CaseSettings | undefined = {} as CaseSettings) : void {
    serializeEntity(writer, caseSettings)
    writer.writeObjectValue<OcrSettings>("ocr", caseSettings.ocr, serializeOcrSettings);
    writer.writeObjectValue<RedundancyDetectionSettings>("redundancyDetection", caseSettings.redundancyDetection, serializeRedundancyDetectionSettings);
    writer.writeObjectValue<TopicModelingSettings>("topicModeling", caseSettings.topicModeling, serializeTopicModelingSettings);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCustodian(writer: SerializationWriter, custodian: Custodian | undefined = {} as Custodian) : void {
    serializeDataSourceContainer(writer, custodian)
    writer.writeDateValue("acknowledgedDateTime", custodian.acknowledgedDateTime);
    writer.writeBooleanValue("applyHoldToSources", custodian.applyHoldToSources);
    writer.writeStringValue("email", custodian.email);
    writer.writeCollectionOfObjectValues<SiteSource>("siteSources", custodian.siteSources, serializeSiteSource);
    writer.writeCollectionOfObjectValues<UnifiedGroupSource>("unifiedGroupSources", custodian.unifiedGroupSources, serializeUnifiedGroupSource);
    writer.writeCollectionOfObjectValues<UserSource>("userSources", custodian.userSources, serializeUserSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCustodianCollectionResponse(writer: SerializationWriter, custodianCollectionResponse: CustodianCollectionResponse | undefined = {} as CustodianCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, custodianCollectionResponse)
    writer.writeCollectionOfObjectValues<Custodian>("value", custodianCollectionResponse.value, serializeCustodian);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDataSource(writer: SerializationWriter, dataSource: DataSource | undefined = {} as DataSource) : void {
    serializeEntity(writer, dataSource)
    writer.writeObjectValue<IdentitySet>("createdBy", dataSource.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", dataSource.createdDateTime);
    writer.writeStringValue("displayName", dataSource.displayName);
    writer.writeEnumValue<DataSourceHoldStatus>("holdStatus", dataSource.holdStatus);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDataSourceCollectionResponse(writer: SerializationWriter, dataSourceCollectionResponse: DataSourceCollectionResponse | undefined = {} as DataSourceCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, dataSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<DataSource>("value", dataSourceCollectionResponse.value, serializeDataSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDataSourceContainer(writer: SerializationWriter, dataSourceContainer: DataSourceContainer | undefined = {} as DataSourceContainer) : void {
    serializeEntity(writer, dataSourceContainer)
    writer.writeDateValue("createdDateTime", dataSourceContainer.createdDateTime);
    writer.writeStringValue("displayName", dataSourceContainer.displayName);
    writer.writeEnumValue<DataSourceHoldStatus>("holdStatus", dataSourceContainer.holdStatus);
    writer.writeObjectValue<CaseIndexOperation>("lastIndexOperation", dataSourceContainer.lastIndexOperation, serializeCaseIndexOperation);
    writer.writeDateValue("lastModifiedDateTime", dataSourceContainer.lastModifiedDateTime);
    writer.writeDateValue("releasedDateTime", dataSourceContainer.releasedDateTime);
    writer.writeEnumValue<DataSourceContainerStatus>("status", dataSourceContainer.status);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryroot(writer: SerializationWriter, ediscoveryroot: Ediscoveryroot | undefined = {} as Ediscoveryroot) : void {
    serializeEntity(writer, ediscoveryroot)
    writer.writeCollectionOfObjectValues<CaseEscaped>("cases", ediscoveryroot.cases, serializeCaseEscaped);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEstimateStatisticsOperation(writer: SerializationWriter, estimateStatisticsOperation: EstimateStatisticsOperation | undefined = {} as EstimateStatisticsOperation) : void {
    serializeCaseOperation(writer, estimateStatisticsOperation)
    writer.writeNumberValue("indexedItemCount", estimateStatisticsOperation.indexedItemCount);
    writer.writeNumberValue("indexedItemsSize", estimateStatisticsOperation.indexedItemsSize);
    writer.writeNumberValue("mailboxCount", estimateStatisticsOperation.mailboxCount);
    writer.writeNumberValue("siteCount", estimateStatisticsOperation.siteCount);
    writer.writeObjectValue<SourceCollection>("sourceCollection", estimateStatisticsOperation.sourceCollection, serializeSourceCollection);
    writer.writeNumberValue("unindexedItemCount", estimateStatisticsOperation.unindexedItemCount);
    writer.writeNumberValue("unindexedItemsSize", estimateStatisticsOperation.unindexedItemsSize);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeLegalHold(writer: SerializationWriter, legalHold: LegalHold | undefined = {} as LegalHold) : void {
    serializeEntity(writer, legalHold)
    writer.writeStringValue("contentQuery", legalHold.contentQuery);
    writer.writeObjectValue<IdentitySet>("createdBy", legalHold.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", legalHold.createdDateTime);
    writer.writeStringValue("description", legalHold.description);
    writer.writeStringValue("displayName", legalHold.displayName);
    writer.writeCollectionOfPrimitiveValues<string>("errors", legalHold.errors);
    writer.writeBooleanValue("isEnabled", legalHold.isEnabled);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", legalHold.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", legalHold.lastModifiedDateTime);
    writer.writeCollectionOfObjectValues<SiteSource>("siteSources", legalHold.siteSources, serializeSiteSource);
    writer.writeEnumValue<LegalHoldStatus>("status", legalHold.status);
    writer.writeCollectionOfObjectValues<UnifiedGroupSource>("unifiedGroupSources", legalHold.unifiedGroupSources, serializeUnifiedGroupSource);
    writer.writeCollectionOfObjectValues<UserSource>("userSources", legalHold.userSources, serializeUserSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeLegalHoldCollectionResponse(writer: SerializationWriter, legalHoldCollectionResponse: LegalHoldCollectionResponse | undefined = {} as LegalHoldCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, legalHoldCollectionResponse)
    writer.writeCollectionOfObjectValues<LegalHold>("value", legalHoldCollectionResponse.value, serializeLegalHold);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeNoncustodialDataSource(writer: SerializationWriter, noncustodialDataSource: NoncustodialDataSource | undefined = {} as NoncustodialDataSource) : void {
    serializeDataSourceContainer(writer, noncustodialDataSource)
    writer.writeBooleanValue("applyHoldToSource", noncustodialDataSource.applyHoldToSource);
    writer.writeObjectValue<DataSource>("dataSource", noncustodialDataSource.dataSource, serializeDataSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeNoncustodialDataSourceCollectionResponse(writer: SerializationWriter, noncustodialDataSourceCollectionResponse: NoncustodialDataSourceCollectionResponse | undefined = {} as NoncustodialDataSourceCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, noncustodialDataSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<NoncustodialDataSource>("value", noncustodialDataSourceCollectionResponse.value, serializeNoncustodialDataSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOcrSettings(writer: SerializationWriter, ocrSettings: OcrSettings | undefined = {} as OcrSettings) : void {
    writer.writeBooleanValue("isEnabled", ocrSettings.isEnabled);
    writer.writeNumberValue("maxImageSize", ocrSettings.maxImageSize);
    writer.writeStringValue("@odata.type", ocrSettings.odataType);
    writer.writeDurationValue("timeout", ocrSettings.timeout);
    writer.writeAdditionalData(ocrSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePurgeDataOperation(writer: SerializationWriter, purgeDataOperation: PurgeDataOperation | undefined = {} as PurgeDataOperation) : void {
    serializeCaseOperation(writer, purgeDataOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRedundancyDetectionSettings(writer: SerializationWriter, redundancyDetectionSettings: RedundancyDetectionSettings | undefined = {} as RedundancyDetectionSettings) : void {
    writer.writeBooleanValue("isEnabled", redundancyDetectionSettings.isEnabled);
    writer.writeNumberValue("maxWords", redundancyDetectionSettings.maxWords);
    writer.writeNumberValue("minWords", redundancyDetectionSettings.minWords);
    writer.writeStringValue("@odata.type", redundancyDetectionSettings.odataType);
    writer.writeNumberValue("similarityThreshold", redundancyDetectionSettings.similarityThreshold);
    writer.writeAdditionalData(redundancyDetectionSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeReviewSet(writer: SerializationWriter, reviewSet: ReviewSet | undefined = {} as ReviewSet) : void {
    serializeEntity(writer, reviewSet)
    writer.writeObjectValue<IdentitySet>("createdBy", reviewSet.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", reviewSet.createdDateTime);
    writer.writeStringValue("displayName", reviewSet.displayName);
    writer.writeCollectionOfObjectValues<ReviewSetQuery>("queries", reviewSet.queries, serializeReviewSetQuery);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeReviewSetCollectionResponse(writer: SerializationWriter, reviewSetCollectionResponse: ReviewSetCollectionResponse | undefined = {} as ReviewSetCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, reviewSetCollectionResponse)
    writer.writeCollectionOfObjectValues<ReviewSet>("value", reviewSetCollectionResponse.value, serializeReviewSet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeReviewSetQuery(writer: SerializationWriter, reviewSetQuery: ReviewSetQuery | undefined = {} as ReviewSetQuery) : void {
    serializeEntity(writer, reviewSetQuery)
    writer.writeObjectValue<IdentitySet>("createdBy", reviewSetQuery.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", reviewSetQuery.createdDateTime);
    writer.writeStringValue("displayName", reviewSetQuery.displayName);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", reviewSetQuery.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", reviewSetQuery.lastModifiedDateTime);
    writer.writeStringValue("query", reviewSetQuery.query);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeReviewSetQueryCollectionResponse(writer: SerializationWriter, reviewSetQueryCollectionResponse: ReviewSetQueryCollectionResponse | undefined = {} as ReviewSetQueryCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, reviewSetQueryCollectionResponse)
    writer.writeCollectionOfObjectValues<ReviewSetQuery>("value", reviewSetQueryCollectionResponse.value, serializeReviewSetQuery);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSiteSource(writer: SerializationWriter, siteSource: SiteSource | undefined = {} as SiteSource) : void {
    serializeDataSource(writer, siteSource)
    writer.writeObjectValue<Site>("site", siteSource.site, serializeSite);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSiteSourceCollectionResponse(writer: SerializationWriter, siteSourceCollectionResponse: SiteSourceCollectionResponse | undefined = {} as SiteSourceCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, siteSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<SiteSource>("value", siteSourceCollectionResponse.value, serializeSiteSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSourceCollection(writer: SerializationWriter, sourceCollection: SourceCollection | undefined = {} as SourceCollection) : void {
    serializeEntity(writer, sourceCollection)
    writer.writeCollectionOfObjectValues<DataSource>("additionalSources", sourceCollection.additionalSources, serializeDataSource);
    writer.writeObjectValue<AddToReviewSetOperation>("addToReviewSetOperation", sourceCollection.addToReviewSetOperation, serializeAddToReviewSetOperation);
    writer.writeStringValue("contentQuery", sourceCollection.contentQuery);
    writer.writeObjectValue<IdentitySet>("createdBy", sourceCollection.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", sourceCollection.createdDateTime);
    writer.writeCollectionOfObjectValues<DataSource>("custodianSources", sourceCollection.custodianSources, serializeDataSource);
    writer.writeEnumValue<DataSourceScopes[]>("dataSourceScopes", sourceCollection.dataSourceScopes);
    writer.writeStringValue("description", sourceCollection.description);
    writer.writeStringValue("displayName", sourceCollection.displayName);
    writer.writeObjectValue<EstimateStatisticsOperation>("lastEstimateStatisticsOperation", sourceCollection.lastEstimateStatisticsOperation, serializeEstimateStatisticsOperation);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", sourceCollection.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", sourceCollection.lastModifiedDateTime);
    writer.writeCollectionOfObjectValues<NoncustodialDataSource>("noncustodialSources", sourceCollection.noncustodialSources, serializeNoncustodialDataSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSourceCollectionCollectionResponse(writer: SerializationWriter, sourceCollectionCollectionResponse: SourceCollectionCollectionResponse | undefined = {} as SourceCollectionCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, sourceCollectionCollectionResponse)
    writer.writeCollectionOfObjectValues<SourceCollection>("value", sourceCollectionCollectionResponse.value, serializeSourceCollection);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTag(writer: SerializationWriter, tag: Tag | undefined = {} as Tag) : void {
    serializeEntity(writer, tag)
    writer.writeEnumValue<ChildSelectability>("childSelectability", tag.childSelectability);
    writer.writeCollectionOfObjectValues<Tag>("childTags", tag.childTags, serializeTag);
    writer.writeObjectValue<IdentitySet>("createdBy", tag.createdBy, serializeIdentitySet);
    writer.writeStringValue("description", tag.description);
    writer.writeStringValue("displayName", tag.displayName);
    writer.writeDateValue("lastModifiedDateTime", tag.lastModifiedDateTime);
    writer.writeObjectValue<Tag>("parent", tag.parent, serializeTag);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTagCollectionResponse(writer: SerializationWriter, tagCollectionResponse: TagCollectionResponse | undefined = {} as TagCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, tagCollectionResponse)
    writer.writeCollectionOfObjectValues<Tag>("value", tagCollectionResponse.value, serializeTag);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTagOperation(writer: SerializationWriter, tagOperation: TagOperation | undefined = {} as TagOperation) : void {
    serializeCaseOperation(writer, tagOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTopicModelingSettings(writer: SerializationWriter, topicModelingSettings: TopicModelingSettings | undefined = {} as TopicModelingSettings) : void {
    writer.writeBooleanValue("dynamicallyAdjustTopicCount", topicModelingSettings.dynamicallyAdjustTopicCount);
    writer.writeBooleanValue("ignoreNumbers", topicModelingSettings.ignoreNumbers);
    writer.writeBooleanValue("isEnabled", topicModelingSettings.isEnabled);
    writer.writeStringValue("@odata.type", topicModelingSettings.odataType);
    writer.writeNumberValue("topicCount", topicModelingSettings.topicCount);
    writer.writeAdditionalData(topicModelingSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUnifiedGroupSource(writer: SerializationWriter, unifiedGroupSource: UnifiedGroupSource | undefined = {} as UnifiedGroupSource) : void {
    serializeDataSource(writer, unifiedGroupSource)
    writer.writeObjectValue<Group>("group", unifiedGroupSource.group, serializeGroup);
    writer.writeEnumValue<SourceType[]>("includedSources", unifiedGroupSource.includedSources);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUnifiedGroupSourceCollectionResponse(writer: SerializationWriter, unifiedGroupSourceCollectionResponse: UnifiedGroupSourceCollectionResponse | undefined = {} as UnifiedGroupSourceCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, unifiedGroupSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<UnifiedGroupSource>("value", unifiedGroupSourceCollectionResponse.value, serializeUnifiedGroupSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserSource(writer: SerializationWriter, userSource: UserSource | undefined = {} as UserSource) : void {
    serializeDataSource(writer, userSource)
    writer.writeStringValue("email", userSource.email);
    writer.writeEnumValue<SourceType[]>("includedSources", userSource.includedSources);
    writer.writeStringValue("siteWebUrl", userSource.siteWebUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserSourceCollectionResponse(writer: SerializationWriter, userSourceCollectionResponse: UserSourceCollectionResponse | undefined = {} as UserSourceCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, userSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<UserSource>("value", userSourceCollectionResponse.value, serializeUserSource);
}
export interface SiteSource extends DataSource, Parsable {
    /**
     * The site property
     */
    site?: Site;
}
export interface SiteSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: SiteSource[];
}
export interface SourceCollection extends Entity, Parsable {
    /**
     * Adds an additional source to the sourceCollection.
     */
    additionalSources?: DataSource[];
    /**
     * Adds the results of the sourceCollection to the specified reviewSet.
     */
    addToReviewSetOperation?: AddToReviewSetOperation;
    /**
     * The query string in KQL (Keyword Query Language) query. For details, see Keyword queries and search conditions for Content Search and eDiscovery. You can refine searches by using fields paired with values; for example, subject:'Quarterly Financials' AND Date>=06/01/2016 AND Date<=07/01/2016.
     */
    contentQuery?: string;
    /**
     * The user who created the sourceCollection.
     */
    createdBy?: IdentitySet;
    /**
     * The date and time the sourceCollection was created.
     */
    createdDateTime?: Date;
    /**
     * Custodian sources that are included in the sourceCollection.
     */
    custodianSources?: DataSource[];
    /**
     * When specified, the collection spans across a service for an entire workload. Possible values are: none, allTenantMailboxes, allTenantSites, allCaseCustodians, allCaseNoncustodialDataSources.
     */
    dataSourceScopes?: DataSourceScopes[];
    /**
     * The description of the sourceCollection.
     */
    description?: string;
    /**
     * The display name of the sourceCollection.
     */
    displayName?: string;
    /**
     * The last estimate operation associated with the sourceCollection.
     */
    lastEstimateStatisticsOperation?: EstimateStatisticsOperation;
    /**
     * The last user who modified the sourceCollection.
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The last date and time the sourceCollection was modified.
     */
    lastModifiedDateTime?: Date;
    /**
     * noncustodialDataSource sources that are included in the sourceCollection
     */
    noncustodialSources?: NoncustodialDataSource[];
}
export interface SourceCollectionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: SourceCollection[];
}
export type SourceType = (typeof SourceTypeObject)[keyof typeof SourceTypeObject];
export interface Tag extends Entity, Parsable {
    /**
     * Indicates whether a single or multiple child tags can be associated with a document. Possible values are: One, Many.  This value controls whether the UX presents the tags as checkboxes or a radio button group.
     */
    childSelectability?: ChildSelectability;
    /**
     * Returns the tags that are a child of a tag.
     */
    childTags?: Tag[];
    /**
     * The user who created the tag.
     */
    createdBy?: IdentitySet;
    /**
     * The description for the tag.
     */
    description?: string;
    /**
     * Display name of the tag.
     */
    displayName?: string;
    /**
     * The date and time the tag was last modified.
     */
    lastModifiedDateTime?: Date;
    /**
     * Returns the parent tag of the specified tag.
     */
    parent?: Tag;
}
export interface TagCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Tag[];
}
export interface TagOperation extends CaseOperation, Parsable {
}
export interface TopicModelingSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * To learn more, see Adjust maximum number of themes dynamically.
     */
    dynamicallyAdjustTopicCount?: boolean;
    /**
     * To learn more, see Include numbers in themes.
     */
    ignoreNumbers?: boolean;
    /**
     * Indicates whether themes are enabled for the case.
     */
    isEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * To learn more, see Maximum number of themes.
     */
    topicCount?: number;
}
export interface UnifiedGroupSource extends DataSource, Parsable {
    /**
     * The group property
     */
    group?: Group;
    /**
     * Specifies which sources are included in this group. Possible values are: mailbox, site.
     */
    includedSources?: SourceType[];
}
export interface UnifiedGroupSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UnifiedGroupSource[];
}
export interface UserSource extends DataSource, Parsable {
    /**
     * Email address of the user's mailbox.
     */
    email?: string;
    /**
     * Specifies which sources are included in this group. Possible values are: mailbox, site.
     */
    includedSources?: SourceType[];
    /**
     * The URL of the user's OneDrive for Business site. Read-only.
     */
    siteWebUrl?: string;
}
export interface UserSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UserSource[];
}
export const AdditionalDataOptionsObject = {
    AllVersions: "allVersions",
    LinkedFiles: "linkedFiles",
    UnknownFutureValue: "unknownFutureValue",
}  as const;
export const CaseActionObject = {
    ContentExport: "contentExport",
    ApplyTags: "applyTags",
    ConvertToPdf: "convertToPdf",
    Index: "index",
    EstimateStatistics: "estimateStatistics",
    AddToReviewSet: "addToReviewSet",
    HoldUpdate: "holdUpdate",
    UnknownFutureValue: "unknownFutureValue",
    PurgeData: "purgeData",
}  as const;
export const CaseOperationStatusObject = {
    NotStarted: "notStarted",
    SubmissionFailed: "submissionFailed",
    Running: "running",
    Succeeded: "succeeded",
    PartiallySucceeded: "partiallySucceeded",
    Failed: "failed",
}  as const;
export const CaseStatusObject = {
    Unknown: "unknown",
    Active: "active",
    PendingDelete: "pendingDelete",
    Closing: "closing",
    Closed: "closed",
    ClosedWithError: "closedWithError",
}  as const;
export const ChildSelectabilityObject = {
    One: "One",
    Many: "Many",
}  as const;
export const DataSourceContainerStatusObject = {
    Active: "Active",
    Released: "Released",
    UnknownFutureValue: "UnknownFutureValue",
}  as const;
export const DataSourceHoldStatusObject = {
    NotApplied: "notApplied",
    Applied: "applied",
    Applying: "applying",
    Removing: "removing",
    Partial: "partial",
    UnknownFutureValue: "unknownFutureValue",
}  as const;
export const DataSourceScopesObject = {
    None: "none",
    AllTenantMailboxes: "allTenantMailboxes",
    AllTenantSites: "allTenantSites",
    AllCaseCustodians: "allCaseCustodians",
    AllCaseNoncustodialDataSources: "allCaseNoncustodialDataSources",
    UnknownFutureValue: "unknownFutureValue",
}  as const;
export const ExportFileStructureObject = {
    None: "none",
    Directory: "directory",
    Pst: "pst",
    UnknownFutureValue: "unknownFutureValue",
}  as const;
export const ExportOptionsObject = {
    OriginalFiles: "originalFiles",
    Text: "text",
    PdfReplacement: "pdfReplacement",
    FileInfo: "fileInfo",
    Tags: "tags",
    UnknownFutureValue: "unknownFutureValue",
}  as const;
export const LegalHoldStatusObject = {
    Pending: "Pending",
    ErrorEscaped: "Error",
    Success: "Success",
    UnknownFutureValue: "UnknownFutureValue",
}  as const;
export const SourceTypeObject = {
    Mailbox: "mailbox",
    Site: "site",
}  as const;
/* tslint:enable */
/* eslint-enable */
