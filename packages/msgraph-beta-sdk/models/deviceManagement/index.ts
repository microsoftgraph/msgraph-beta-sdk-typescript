/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createKeyValuePairFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, serializeKeyValuePair, type BaseCollectionPaginationCountResponse, type Entity, type KeyValuePair } from '../index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export type AggregationType = (typeof AggregationTypeObject)[keyof typeof AggregationTypeObject];
export interface AlertImpact extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The aggregation type of the impact. The possible values are: count, percentage, affectedCloudPcCount, affectedCloudPcPercentage, unknownFutureValue.
     */
    aggregationType?: AggregationType | null;
    /**
     * The detail information of the impact. For example, if the Frontline Cloud PCs near concurrency limit alert is triggered, the details contain the impacted Frontline license SKU name, such as Windows 365 Frontline 2 vCPU/8GB/128GB, and the corresponding impacted value.
     */
    alertImpactDetails?: KeyValuePair[] | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The number value of the impact. For the aggregation types of count and affectedCloudPcCount, the value indicates the number of affected instances. For example, 6 affectedCloudPcCount means that six Cloud PCs are affected. For the aggregation types of percentage and affectedCloudPcPercentage, the value indicates the percent of affected instances. For example, 12 affectedCloudPcPercentage means that 12% of Cloud PCs are affected.
     */
    value?: number | null;
}
export interface AlertRecord extends Entity, Parsable {
    /**
     * The impact of the alert event. Consists of a list of key-value pair and a number followed by the aggregation type. For example, 6 affectedCloudPcCount means that 6 Cloud PCs are affected. 12 affectedCloudPcPercentage means 12% of Cloud PCs are affected. The list of key-value pair indicates the details of the alert impact.
     */
    alertImpact?: AlertImpact | null;
    /**
     * The corresponding ID of the alert rule.
     */
    alertRuleId?: string | null;
    /**
     * The rule template of the alert event. The possible values are: cloudPcProvisionScenario, cloudPcImageUploadScenario, cloudPcOnPremiseNetworkConnectionCheckScenario, unknownFutureValue, cloudPcInGracePeriodScenario, cloudPcFrontlineInsufficientLicensesScenario, cloudPcInaccessibleScenario, cloudPcFrontlineConcurrencyScenario, cloudPcUserSettingsPersistenceScenario, cloudPcDeprovisionFailedScenario. Use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: cloudPcInGracePeriodScenario, cloudPcFrontlineInsufficientLicensesScenario, cloudPcInaccessibleScenario, cloudPcFrontlineConcurrencyScenario, cloudPcUserSettingsPersistenceScenario, cloudPcDeprovisionFailedScenario.
     */
    alertRuleTemplate?: AlertRuleTemplate | null;
    /**
     * The date and time when the alert event was detected. The Timestamp type represents date and time information using ISO 8601 format. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    detectedDateTime?: Date | null;
    /**
     * The display name of the alert record.
     */
    displayName?: string | null;
    /**
     * The date and time when the alert record was last updated. The Timestamp type represents date and time information using ISO 8601 format. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastUpdatedDateTime?: Date | null;
    /**
     * The date and time when the alert event was resolved. The Timestamp type represents date and time information using ISO 8601 format. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    resolvedDateTime?: Date | null;
    /**
     * The severity of the alert event. The possible values are: unknown, informational, warning, critical, unknownFutureValue.
     */
    severity?: RuleSeverityType | null;
    /**
     * The status of the alert record. The possible values are: active, resolved, unknownFutureValue.
     */
    status?: AlertStatusType | null;
}
export interface AlertRecordCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: AlertRecord[] | null;
}
export interface AlertRule extends Entity, Parsable {
    /**
     * The rule template of the alert event. The possible values are: cloudPcProvisionScenario, cloudPcImageUploadScenario, cloudPcOnPremiseNetworkConnectionCheckScenario, unknownFutureValue, cloudPcInGracePeriodScenario, cloudPcFrontlineInsufficientLicensesScenario, cloudPcInaccessibleScenario, cloudPcFrontlineConcurrencyScenario, cloudPcUserSettingsPersistenceScenario, cloudPcDeprovisionFailedScenario.  Use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: cloudPcInGracePeriodScenario, cloudPcFrontlineInsufficientLicensesScenario, cloudPcInaccessibleScenario, cloudPcFrontlineConcurrencyScenario, cloudPcUserSettingsPersistenceScenario, cloudPcDeprovisionFailedScenario.
     */
    alertRuleTemplate?: AlertRuleTemplate | null;
    /**
     * The conditions that determine when to send alerts. For example, you can configure a condition to send an alert when provisioning fails for six or more Cloud PCs.
     */
    conditions?: RuleCondition[] | null;
    /**
     * The rule description.
     */
    description?: string | null;
    /**
     * The display name of the rule.
     */
    displayName?: string | null;
    /**
     * The status of the rule that indicates whether the rule is enabled or disabled. If true, the rule is enabled; otherwise, the rule is disabled.
     */
    enabled?: boolean | null;
    /**
     * Indicates whether the rule is a system rule. If true, the rule is a system rule; otherwise, the rule is a custom-defined rule and can be edited. System rules are built in and only a few properties can be edited.
     */
    isSystemRule?: boolean | null;
    /**
     * The notification channels of the rule selected by the user.
     */
    notificationChannels?: NotificationChannel[] | null;
    /**
     * The severity of the rule. The possible values are: unknown, informational, warning, critical, unknownFutureValue.
     */
    severity?: RuleSeverityType | null;
    /**
     * The conditions that determine when to send alerts. For example, you can configure a condition to send an alert when provisioning fails for six or more Cloud PCs. This property is deprecated. Use conditions instead.
     */
    threshold?: RuleThreshold | null;
}
export interface AlertRuleCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: AlertRule[] | null;
}
export type AlertRuleTemplate = (typeof AlertRuleTemplateObject)[keyof typeof AlertRuleTemplateObject];
export type AlertStatusType = (typeof AlertStatusTypeObject)[keyof typeof AlertStatusTypeObject];
export type ConditionCategory = (typeof ConditionCategoryObject)[keyof typeof ConditionCategoryObject];
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertImpact}
 */
// @ts-ignore
export function createAlertImpactFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertImpact;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertRecordCollectionResponse}
 */
// @ts-ignore
export function createAlertRecordCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertRecordCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertRecord}
 */
// @ts-ignore
export function createAlertRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertRecord;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertRuleCollectionResponse}
 */
// @ts-ignore
export function createAlertRuleCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertRuleCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertRule}
 */
// @ts-ignore
export function createAlertRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Monitoring}
 */
// @ts-ignore
export function createMonitoringFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMonitoring;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NotificationChannel}
 */
// @ts-ignore
export function createNotificationChannelFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNotificationChannel;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NotificationReceiver}
 */
// @ts-ignore
export function createNotificationReceiverFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNotificationReceiver;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PortalNotification}
 */
// @ts-ignore
export function createPortalNotificationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPortalNotification;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RuleCondition}
 */
// @ts-ignore
export function createRuleConditionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRuleCondition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RuleThreshold}
 */
// @ts-ignore
export function createRuleThresholdFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRuleThreshold;
}
/**
 * The deserialization information for the current model
 * @param AlertImpact The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertImpact(alertImpact: Partial<AlertImpact> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "aggregationType": n => { alertImpact.aggregationType = n.getEnumValue<AggregationType>(AggregationTypeObject); },
        "alertImpactDetails": n => { alertImpact.alertImpactDetails = n.getCollectionOfObjectValues<KeyValuePair>(createKeyValuePairFromDiscriminatorValue); },
        "backingStoreEnabled": n => { alertImpact.backingStoreEnabled = true; },
        "@odata.type": n => { alertImpact.odataType = n.getStringValue(); },
        "value": n => { alertImpact.value = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertRecord The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertRecord(alertRecord: Partial<AlertRecord> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(alertRecord),
        "alertImpact": n => { alertRecord.alertImpact = n.getObjectValue<AlertImpact>(createAlertImpactFromDiscriminatorValue); },
        "alertRuleId": n => { alertRecord.alertRuleId = n.getStringValue(); },
        "alertRuleTemplate": n => { alertRecord.alertRuleTemplate = n.getEnumValue<AlertRuleTemplate>(AlertRuleTemplateObject); },
        "detectedDateTime": n => { alertRecord.detectedDateTime = n.getDateValue(); },
        "displayName": n => { alertRecord.displayName = n.getStringValue(); },
        "lastUpdatedDateTime": n => { alertRecord.lastUpdatedDateTime = n.getDateValue(); },
        "resolvedDateTime": n => { alertRecord.resolvedDateTime = n.getDateValue(); },
        "severity": n => { alertRecord.severity = n.getEnumValue<RuleSeverityType>(RuleSeverityTypeObject); },
        "status": n => { alertRecord.status = n.getEnumValue<AlertStatusType>(AlertStatusTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertRecordCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertRecordCollectionResponse(alertRecordCollectionResponse: Partial<AlertRecordCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(alertRecordCollectionResponse),
        "value": n => { alertRecordCollectionResponse.value = n.getCollectionOfObjectValues<AlertRecord>(createAlertRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertRule The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertRule(alertRule: Partial<AlertRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(alertRule),
        "alertRuleTemplate": n => { alertRule.alertRuleTemplate = n.getEnumValue<AlertRuleTemplate>(AlertRuleTemplateObject); },
        "conditions": n => { alertRule.conditions = n.getCollectionOfObjectValues<RuleCondition>(createRuleConditionFromDiscriminatorValue); },
        "description": n => { alertRule.description = n.getStringValue(); },
        "displayName": n => { alertRule.displayName = n.getStringValue(); },
        "enabled": n => { alertRule.enabled = n.getBooleanValue(); },
        "isSystemRule": n => { alertRule.isSystemRule = n.getBooleanValue(); },
        "notificationChannels": n => { alertRule.notificationChannels = n.getCollectionOfObjectValues<NotificationChannel>(createNotificationChannelFromDiscriminatorValue); },
        "severity": n => { alertRule.severity = n.getEnumValue<RuleSeverityType>(RuleSeverityTypeObject); },
        "threshold": n => { alertRule.threshold = n.getObjectValue<RuleThreshold>(createRuleThresholdFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param AlertRuleCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAlertRuleCollectionResponse(alertRuleCollectionResponse: Partial<AlertRuleCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(alertRuleCollectionResponse),
        "value": n => { alertRuleCollectionResponse.value = n.getCollectionOfObjectValues<AlertRule>(createAlertRuleFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Monitoring The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoMonitoring(monitoring: Partial<Monitoring> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(monitoring),
        "alertRecords": n => { monitoring.alertRecords = n.getCollectionOfObjectValues<AlertRecord>(createAlertRecordFromDiscriminatorValue); },
        "alertRules": n => { monitoring.alertRules = n.getCollectionOfObjectValues<AlertRule>(createAlertRuleFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param NotificationChannel The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoNotificationChannel(notificationChannel: Partial<NotificationChannel> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { notificationChannel.backingStoreEnabled = true; },
        "notificationChannelType": n => { notificationChannel.notificationChannelType = n.getEnumValue<NotificationChannelType>(NotificationChannelTypeObject); },
        "notificationReceivers": n => { notificationChannel.notificationReceivers = n.getCollectionOfObjectValues<NotificationReceiver>(createNotificationReceiverFromDiscriminatorValue); },
        "@odata.type": n => { notificationChannel.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param NotificationReceiver The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoNotificationReceiver(notificationReceiver: Partial<NotificationReceiver> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { notificationReceiver.backingStoreEnabled = true; },
        "contactInformation": n => { notificationReceiver.contactInformation = n.getStringValue(); },
        "locale": n => { notificationReceiver.locale = n.getStringValue(); },
        "@odata.type": n => { notificationReceiver.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param PortalNotification The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPortalNotification(portalNotification: Partial<PortalNotification> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "alertImpact": n => { portalNotification.alertImpact = n.getObjectValue<AlertImpact>(createAlertImpactFromDiscriminatorValue); },
        "alertRecordId": n => { portalNotification.alertRecordId = n.getStringValue(); },
        "alertRuleId": n => { portalNotification.alertRuleId = n.getStringValue(); },
        "alertRuleName": n => { portalNotification.alertRuleName = n.getStringValue(); },
        "alertRuleTemplate": n => { portalNotification.alertRuleTemplate = n.getEnumValue<AlertRuleTemplate>(AlertRuleTemplateObject); },
        "backingStoreEnabled": n => { portalNotification.backingStoreEnabled = true; },
        "id": n => { portalNotification.id = n.getStringValue(); },
        "isPortalNotificationSent": n => { portalNotification.isPortalNotificationSent = n.getBooleanValue(); },
        "@odata.type": n => { portalNotification.odataType = n.getStringValue(); },
        "severity": n => { portalNotification.severity = n.getEnumValue<RuleSeverityType>(RuleSeverityTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param RuleCondition The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRuleCondition(ruleCondition: Partial<RuleCondition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "aggregation": n => { ruleCondition.aggregation = n.getEnumValue<AggregationType>(AggregationTypeObject); },
        "backingStoreEnabled": n => { ruleCondition.backingStoreEnabled = true; },
        "conditionCategory": n => { ruleCondition.conditionCategory = n.getEnumValue<ConditionCategory>(ConditionCategoryObject); },
        "@odata.type": n => { ruleCondition.odataType = n.getStringValue(); },
        "operator": n => { ruleCondition.operator = n.getEnumValue<OperatorType>(OperatorTypeObject); },
        "relationshipType": n => { ruleCondition.relationshipType = n.getEnumValue<RelationshipType>(RelationshipTypeObject); },
        "thresholdValue": n => { ruleCondition.thresholdValue = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RuleThreshold The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRuleThreshold(ruleThreshold: Partial<RuleThreshold> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "aggregation": n => { ruleThreshold.aggregation = n.getEnumValue<AggregationType>(AggregationTypeObject); },
        "backingStoreEnabled": n => { ruleThreshold.backingStoreEnabled = true; },
        "@odata.type": n => { ruleThreshold.odataType = n.getStringValue(); },
        "operator": n => { ruleThreshold.operator = n.getEnumValue<OperatorType>(OperatorTypeObject); },
        "target": n => { ruleThreshold.target = n.getNumberValue(); },
    }
}
export interface Monitoring extends Entity, Parsable {
    /**
     * The collection of records of alert events.
     */
    alertRecords?: AlertRecord[] | null;
    /**
     * The collection of alert rules.
     */
    alertRules?: AlertRule[] | null;
}
export interface NotificationChannel extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The type of the notification channel. The possible values are: portal, email, phoneCall, sms, unknownFutureValue.
     */
    notificationChannelType?: NotificationChannelType | null;
    /**
     * Information about the notification receivers, such as locale and contact information. For example, en-us for locale and serena.davis@contoso.com for contact information.
     */
    notificationReceivers?: NotificationReceiver[] | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export type NotificationChannelType = (typeof NotificationChannelTypeObject)[keyof typeof NotificationChannelTypeObject];
export interface NotificationReceiver extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The contact information about the notification receivers, such as an email address. Currently, only email and portal notifications are supported. For portal notifications, contactInformation can be left blank. For email notifications, contactInformation consists of an email address such as serena.davis@contoso.com.
     */
    contactInformation?: string | null;
    /**
     * Defines the language and format in which the notification will be sent. Supported locale values are: en-us, cs-cz, de-de, es-es, fr-fr, hu-hu, it-it, ja-jp, ko-kr, nl-nl, pl-pl, pt-br, pt-pt, ru-ru, sv-se, tr-tr, zh-cn, zh-tw.
     */
    locale?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export type OperatorType = (typeof OperatorTypeObject)[keyof typeof OperatorTypeObject];
export interface PortalNotification extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The associated alert impact.
     */
    alertImpact?: AlertImpact | null;
    /**
     * The associated alert record ID.
     */
    alertRecordId?: string | null;
    /**
     * The associated alert rule ID.
     */
    alertRuleId?: string | null;
    /**
     * The associated alert rule name.
     */
    alertRuleName?: string | null;
    /**
     * The associated alert rule template. The possible values are: cloudPcProvisionScenario, cloudPcImageUploadScenario, cloudPcOnPremiseNetworkConnectionCheckScenario, unknownFutureValue, cloudPcInGracePeriodScenario. Use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: cloudPcInGracePeriodScenario.
     */
    alertRuleTemplate?: AlertRuleTemplate | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The unique identifier for the portal notification.
     */
    id?: string | null;
    /**
     * true if the portal notification has already been sent to the user; false otherwise.
     */
    isPortalNotificationSent?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The associated alert rule severity. The possible values are: unknown, informational, warning, critical, unknownFutureValue.
     */
    severity?: RuleSeverityType | null;
}
export type RelationshipType = (typeof RelationshipTypeObject)[keyof typeof RelationshipTypeObject];
export interface RuleCondition extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The built-in aggregation method for the rule condition. The possible values are: count, percentage, affectedCloudPcCount, affectedCloudPcPercentage, unknownFutureValue.
     */
    aggregation?: AggregationType | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The property that the rule condition monitors. The possible values are: provisionFailures, imageUploadFailures, azureNetworkConnectionCheckFailures, cloudPcInGracePeriod, frontlineInsufficientLicenses, cloudPcConnectionErrors, cloudPcHostHealthCheckFailures, cloudPcZoneOutage, unknownFutureValue, frontlineBufferUsageDuration, frontlineBufferUsageThreshold, cloudPcUserSettingsPersistenceUsageThreshold, cloudPcDeprovisionedThreshold, cloudPcReserveDeprovisionFailedThreshold. Use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: frontlineBufferUsageDuration, frontlineBufferUsageThreshold, cloudPcUserSettingsPersistenceUsageThreshold, cloudPcDeprovisionedThreshold, cloudPcReserveDeprovisionFailedThreshold.
     */
    conditionCategory?: ConditionCategory | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The built-in operator for the rule condition. The possible values are: greaterOrEqual, equal, greater, less, lessOrEqual, notEqual, unknownFutureValue.
     */
    operator?: OperatorType | null;
    /**
     * The relationship type.  The possible values are: and, or.
     */
    relationshipType?: RelationshipType | null;
    /**
     * The threshold value of the alert condition. The threshold value can be a number in string form or string like 'WestUS'.
     */
    thresholdValue?: string | null;
}
export type RuleSeverityType = (typeof RuleSeverityTypeObject)[keyof typeof RuleSeverityTypeObject];
export interface RuleThreshold extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Indicates the built-in aggregation methods. The possible values are: count, percentage, affectedCloudPcCount, affectedCloudPcPercentage, unknownFutureValue.
     */
    aggregation?: AggregationType | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Indicates the built-in operator. The possible values are: greaterOrEqual, equal, greater, less, lessOrEqual, notEqual, unknownFutureValue.
     */
    operator?: OperatorType | null;
    /**
     * The target threshold value.
     */
    target?: number | null;
}
/**
 * Serializes information the current object
 * @param AlertImpact The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertImpact(writer: SerializationWriter, alertImpact: Partial<AlertImpact> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertImpact || isSerializingDerivedType) { return; }
    writer.writeEnumValue<AggregationType>("aggregationType", alertImpact.aggregationType);
    writer.writeCollectionOfObjectValues<KeyValuePair>("alertImpactDetails", alertImpact.alertImpactDetails, serializeKeyValuePair);
    writer.writeStringValue("@odata.type", alertImpact.odataType);
    writer.writeNumberValue("value", alertImpact.value);
    writer.writeAdditionalData(alertImpact.additionalData);
}
/**
 * Serializes information the current object
 * @param AlertRecord The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertRecord(writer: SerializationWriter, alertRecord: Partial<AlertRecord> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertRecord || isSerializingDerivedType) { return; }
    serializeEntity(writer, alertRecord, isSerializingDerivedType)
    writer.writeObjectValue<AlertImpact>("alertImpact", alertRecord.alertImpact, serializeAlertImpact);
    writer.writeStringValue("alertRuleId", alertRecord.alertRuleId);
    writer.writeEnumValue<AlertRuleTemplate>("alertRuleTemplate", alertRecord.alertRuleTemplate);
    writer.writeDateValue("detectedDateTime", alertRecord.detectedDateTime);
    writer.writeStringValue("displayName", alertRecord.displayName);
    writer.writeDateValue("lastUpdatedDateTime", alertRecord.lastUpdatedDateTime);
    writer.writeDateValue("resolvedDateTime", alertRecord.resolvedDateTime);
    writer.writeEnumValue<RuleSeverityType>("severity", alertRecord.severity);
    writer.writeEnumValue<AlertStatusType>("status", alertRecord.status);
}
/**
 * Serializes information the current object
 * @param AlertRecordCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertRecordCollectionResponse(writer: SerializationWriter, alertRecordCollectionResponse: Partial<AlertRecordCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertRecordCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, alertRecordCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<AlertRecord>("value", alertRecordCollectionResponse.value, serializeAlertRecord);
}
/**
 * Serializes information the current object
 * @param AlertRule The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertRule(writer: SerializationWriter, alertRule: Partial<AlertRule> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertRule || isSerializingDerivedType) { return; }
    serializeEntity(writer, alertRule, isSerializingDerivedType)
    writer.writeEnumValue<AlertRuleTemplate>("alertRuleTemplate", alertRule.alertRuleTemplate);
    writer.writeCollectionOfObjectValues<RuleCondition>("conditions", alertRule.conditions, serializeRuleCondition);
    writer.writeStringValue("description", alertRule.description);
    writer.writeStringValue("displayName", alertRule.displayName);
    writer.writeBooleanValue("enabled", alertRule.enabled);
    writer.writeBooleanValue("isSystemRule", alertRule.isSystemRule);
    writer.writeCollectionOfObjectValues<NotificationChannel>("notificationChannels", alertRule.notificationChannels, serializeNotificationChannel);
    writer.writeEnumValue<RuleSeverityType>("severity", alertRule.severity);
    writer.writeObjectValue<RuleThreshold>("threshold", alertRule.threshold, serializeRuleThreshold);
}
/**
 * Serializes information the current object
 * @param AlertRuleCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAlertRuleCollectionResponse(writer: SerializationWriter, alertRuleCollectionResponse: Partial<AlertRuleCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!alertRuleCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, alertRuleCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<AlertRule>("value", alertRuleCollectionResponse.value, serializeAlertRule);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Monitoring The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeMonitoring(writer: SerializationWriter, monitoring: Partial<Monitoring> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!monitoring || isSerializingDerivedType) { return; }
    serializeEntity(writer, monitoring, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<AlertRecord>("alertRecords", monitoring.alertRecords, serializeAlertRecord);
    writer.writeCollectionOfObjectValues<AlertRule>("alertRules", monitoring.alertRules, serializeAlertRule);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param NotificationChannel The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeNotificationChannel(writer: SerializationWriter, notificationChannel: Partial<NotificationChannel> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!notificationChannel || isSerializingDerivedType) { return; }
    writer.writeEnumValue<NotificationChannelType>("notificationChannelType", notificationChannel.notificationChannelType);
    writer.writeCollectionOfObjectValues<NotificationReceiver>("notificationReceivers", notificationChannel.notificationReceivers, serializeNotificationReceiver);
    writer.writeStringValue("@odata.type", notificationChannel.odataType);
    writer.writeAdditionalData(notificationChannel.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param NotificationReceiver The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeNotificationReceiver(writer: SerializationWriter, notificationReceiver: Partial<NotificationReceiver> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!notificationReceiver || isSerializingDerivedType) { return; }
    writer.writeStringValue("contactInformation", notificationReceiver.contactInformation);
    writer.writeStringValue("locale", notificationReceiver.locale);
    writer.writeStringValue("@odata.type", notificationReceiver.odataType);
    writer.writeAdditionalData(notificationReceiver.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PortalNotification The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePortalNotification(writer: SerializationWriter, portalNotification: Partial<PortalNotification> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!portalNotification || isSerializingDerivedType) { return; }
    writer.writeObjectValue<AlertImpact>("alertImpact", portalNotification.alertImpact, serializeAlertImpact);
    writer.writeStringValue("alertRecordId", portalNotification.alertRecordId);
    writer.writeStringValue("alertRuleId", portalNotification.alertRuleId);
    writer.writeStringValue("alertRuleName", portalNotification.alertRuleName);
    writer.writeEnumValue<AlertRuleTemplate>("alertRuleTemplate", portalNotification.alertRuleTemplate);
    writer.writeStringValue("id", portalNotification.id);
    writer.writeBooleanValue("isPortalNotificationSent", portalNotification.isPortalNotificationSent);
    writer.writeStringValue("@odata.type", portalNotification.odataType);
    writer.writeEnumValue<RuleSeverityType>("severity", portalNotification.severity);
    writer.writeAdditionalData(portalNotification.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RuleCondition The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRuleCondition(writer: SerializationWriter, ruleCondition: Partial<RuleCondition> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!ruleCondition || isSerializingDerivedType) { return; }
    writer.writeEnumValue<AggregationType>("aggregation", ruleCondition.aggregation);
    writer.writeEnumValue<ConditionCategory>("conditionCategory", ruleCondition.conditionCategory);
    writer.writeStringValue("@odata.type", ruleCondition.odataType);
    writer.writeEnumValue<OperatorType>("operator", ruleCondition.operator);
    writer.writeEnumValue<RelationshipType>("relationshipType", ruleCondition.relationshipType);
    writer.writeStringValue("thresholdValue", ruleCondition.thresholdValue);
    writer.writeAdditionalData(ruleCondition.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RuleThreshold The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRuleThreshold(writer: SerializationWriter, ruleThreshold: Partial<RuleThreshold> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!ruleThreshold || isSerializingDerivedType) { return; }
    writer.writeEnumValue<AggregationType>("aggregation", ruleThreshold.aggregation);
    writer.writeStringValue("@odata.type", ruleThreshold.odataType);
    writer.writeEnumValue<OperatorType>("operator", ruleThreshold.operator);
    writer.writeNumberValue("target", ruleThreshold.target);
    writer.writeAdditionalData(ruleThreshold.additionalData);
}
export const AggregationTypeObject = {
    Count: "count",
    Percentage: "percentage",
    AffectedCloudPcCount: "affectedCloudPcCount",
    AffectedCloudPcPercentage: "affectedCloudPcPercentage",
    UnknownFutureValue: "unknownFutureValue",
    DurationInMinutes: "durationInMinutes",
} as const;
export const AlertRuleTemplateObject = {
    CloudPcProvisionScenario: "cloudPcProvisionScenario",
    CloudPcImageUploadScenario: "cloudPcImageUploadScenario",
    CloudPcOnPremiseNetworkConnectionCheckScenario: "cloudPcOnPremiseNetworkConnectionCheckScenario",
    UnknownFutureValue: "unknownFutureValue",
    CloudPcInGracePeriodScenario: "cloudPcInGracePeriodScenario",
    CloudPcFrontlineInsufficientLicensesScenario: "cloudPcFrontlineInsufficientLicensesScenario",
    CloudPcInaccessibleScenario: "cloudPcInaccessibleScenario",
    CloudPcFrontlineConcurrencyScenario: "cloudPcFrontlineConcurrencyScenario",
    CloudPcUserSettingsPersistenceScenario: "cloudPcUserSettingsPersistenceScenario",
    CloudPcDeprovisionFailedScenario: "cloudPcDeprovisionFailedScenario",
} as const;
export const AlertStatusTypeObject = {
    Active: "active",
    Resolved: "resolved",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ConditionCategoryObject = {
    ProvisionFailures: "provisionFailures",
    ImageUploadFailures: "imageUploadFailures",
    AzureNetworkConnectionCheckFailures: "azureNetworkConnectionCheckFailures",
    CloudPcInGracePeriod: "cloudPcInGracePeriod",
    FrontlineInsufficientLicenses: "frontlineInsufficientLicenses",
    CloudPcConnectionErrors: "cloudPcConnectionErrors",
    CloudPcHostHealthCheckFailures: "cloudPcHostHealthCheckFailures",
    CloudPcZoneOutage: "cloudPcZoneOutage",
    UnknownFutureValue: "unknownFutureValue",
    FrontlineBufferUsageDuration: "frontlineBufferUsageDuration",
    FrontlineBufferUsageThreshold: "frontlineBufferUsageThreshold",
    CloudPcUserSettingsPersistenceUsageThreshold: "cloudPcUserSettingsPersistenceUsageThreshold",
    CloudPcDeprovisionedThreshold: "cloudPcDeprovisionedThreshold",
    CloudPcReserveDeprovisionFailedThreshold: "cloudPcReserveDeprovisionFailedThreshold",
} as const;
export const NotificationChannelTypeObject = {
    Portal: "portal",
    Email: "email",
    PhoneCall: "phoneCall",
    Sms: "sms",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const OperatorTypeObject = {
    GreaterOrEqual: "greaterOrEqual",
    Equal: "equal",
    Greater: "greater",
    Less: "less",
    LessOrEqual: "lessOrEqual",
    NotEqual: "notEqual",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RelationshipTypeObject = {
    And: "and",
    Or: "or",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RuleSeverityTypeObject = {
    Unknown: "unknown",
    Informational: "informational",
    Warning: "warning",
    Critical: "critical",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
