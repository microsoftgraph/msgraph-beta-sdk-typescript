/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createUserFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, serializeUser, type BaseCollectionPaginationCountResponse, type Entity, type User } from '../index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export type AccountType = (typeof AccountTypeObject)[keyof typeof AccountTypeObject];
export interface AssignedTelephoneNumber extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The assignmentCategory property
     */
    assignmentCategory?: AssignmentCategory | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The assigned phone number.
     */
    telephoneNumber?: string | null;
}
export type AssignmentCategory = (typeof AssignmentCategoryObject)[keyof typeof AssignmentCategoryObject];
export type AssignmentType = (typeof AssignmentTypeObject)[keyof typeof AssignmentTypeObject];
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AssignedTelephoneNumber}
 */
// @ts-ignore
export function createAssignedTelephoneNumberFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAssignedTelephoneNumber;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EffectivePolicyAssignment}
 */
// @ts-ignore
export function createEffectivePolicyAssignmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEffectivePolicyAssignment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PolicyAssignment}
 */
// @ts-ignore
export function createPolicyAssignmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPolicyAssignment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamsAdminRoot}
 */
// @ts-ignore
export function createTeamsAdminRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamsAdminRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamsPolicyAssignment}
 */
// @ts-ignore
export function createTeamsPolicyAssignmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamsPolicyAssignment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamsUserConfigurationCollectionResponse}
 */
// @ts-ignore
export function createTeamsUserConfigurationCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamsUserConfigurationCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamsUserConfiguration}
 */
// @ts-ignore
export function createTeamsUserConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamsUserConfiguration;
}
/**
 * The deserialization information for the current model
 * @param AssignedTelephoneNumber The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAssignedTelephoneNumber(assignedTelephoneNumber: Partial<AssignedTelephoneNumber> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "assignmentCategory": n => { assignedTelephoneNumber.assignmentCategory = n.getEnumValue<AssignmentCategory>(AssignmentCategoryObject); },
        "backingStoreEnabled": n => { assignedTelephoneNumber.backingStoreEnabled = true; },
        "@odata.type": n => { assignedTelephoneNumber.odataType = n.getStringValue(); },
        "telephoneNumber": n => { assignedTelephoneNumber.telephoneNumber = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param EffectivePolicyAssignment The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEffectivePolicyAssignment(effectivePolicyAssignment: Partial<EffectivePolicyAssignment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { effectivePolicyAssignment.backingStoreEnabled = true; },
        "@odata.type": n => { effectivePolicyAssignment.odataType = n.getStringValue(); },
        "policyAssignment": n => { effectivePolicyAssignment.policyAssignment = n.getObjectValue<PolicyAssignment>(createPolicyAssignmentFromDiscriminatorValue); },
        "policyType": n => { effectivePolicyAssignment.policyType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param PolicyAssignment The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPolicyAssignment(policyAssignment: Partial<PolicyAssignment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "assignmentType": n => { policyAssignment.assignmentType = n.getEnumValue<AssignmentType>(AssignmentTypeObject); },
        "backingStoreEnabled": n => { policyAssignment.backingStoreEnabled = true; },
        "displayName": n => { policyAssignment.displayName = n.getStringValue(); },
        "groupId": n => { policyAssignment.groupId = n.getStringValue(); },
        "@odata.type": n => { policyAssignment.odataType = n.getStringValue(); },
        "policyId": n => { policyAssignment.policyId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TeamsAdminRoot The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTeamsAdminRoot(teamsAdminRoot: Partial<TeamsAdminRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(teamsAdminRoot),
        "policy": n => { teamsAdminRoot.policy = n.getObjectValue<TeamsPolicyAssignment>(createTeamsPolicyAssignmentFromDiscriminatorValue); },
        "userConfigurations": n => { teamsAdminRoot.userConfigurations = n.getCollectionOfObjectValues<TeamsUserConfiguration>(createTeamsUserConfigurationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TeamsPolicyAssignment The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTeamsPolicyAssignment(teamsPolicyAssignment: Partial<TeamsPolicyAssignment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(teamsPolicyAssignment),
    }
}
/**
 * The deserialization information for the current model
 * @param TeamsUserConfiguration The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTeamsUserConfiguration(teamsUserConfiguration: Partial<TeamsUserConfiguration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(teamsUserConfiguration),
        "accountType": n => { teamsUserConfiguration.accountType = n.getEnumValue<AccountType>(AccountTypeObject); },
        "createdDateTime": n => { teamsUserConfiguration.createdDateTime = n.getDateValue(); },
        "effectivePolicyAssignments": n => { teamsUserConfiguration.effectivePolicyAssignments = n.getCollectionOfObjectValues<EffectivePolicyAssignment>(createEffectivePolicyAssignmentFromDiscriminatorValue); },
        "featureTypes": n => { teamsUserConfiguration.featureTypes = n.getCollectionOfPrimitiveValues<string>(); },
        "isEnterpriseVoiceEnabled": n => { teamsUserConfiguration.isEnterpriseVoiceEnabled = n.getBooleanValue(); },
        "modifiedDateTime": n => { teamsUserConfiguration.modifiedDateTime = n.getDateValue(); },
        "telephoneNumbers": n => { teamsUserConfiguration.telephoneNumbers = n.getCollectionOfObjectValues<AssignedTelephoneNumber>(createAssignedTelephoneNumberFromDiscriminatorValue); },
        "tenantId": n => { teamsUserConfiguration.tenantId = n.getStringValue(); },
        "user": n => { teamsUserConfiguration.user = n.getObjectValue<User>(createUserFromDiscriminatorValue); },
        "userPrincipalName": n => { teamsUserConfiguration.userPrincipalName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TeamsUserConfigurationCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTeamsUserConfigurationCollectionResponse(teamsUserConfigurationCollectionResponse: Partial<TeamsUserConfigurationCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(teamsUserConfigurationCollectionResponse),
        "value": n => { teamsUserConfigurationCollectionResponse.value = n.getCollectionOfObjectValues<TeamsUserConfiguration>(createTeamsUserConfigurationFromDiscriminatorValue); },
    }
}
export interface EffectivePolicyAssignment extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The policyAssignment property
     */
    policyAssignment?: PolicyAssignment | null;
    /**
     * The type of the assigned policy; for example, TeamsMeetingPolicy and TeamsCallingPolicy.
     */
    policyType?: string | null;
}
export interface PolicyAssignment extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The assignmentType property
     */
    assignmentType?: AssignmentType | null;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Represents the name of the policy.
     */
    displayName?: string | null;
    /**
     * Represents the group identifier.
     */
    groupId?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Represents the unique identifier for the policy.
     */
    policyId?: string | null;
}
/**
 * Serializes information the current object
 * @param AssignedTelephoneNumber The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAssignedTelephoneNumber(writer: SerializationWriter, assignedTelephoneNumber: Partial<AssignedTelephoneNumber> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!assignedTelephoneNumber || isSerializingDerivedType) { return; }
    writer.writeEnumValue<AssignmentCategory>("assignmentCategory", assignedTelephoneNumber.assignmentCategory);
    writer.writeStringValue("@odata.type", assignedTelephoneNumber.odataType);
    writer.writeStringValue("telephoneNumber", assignedTelephoneNumber.telephoneNumber);
    writer.writeAdditionalData(assignedTelephoneNumber.additionalData);
}
/**
 * Serializes information the current object
 * @param EffectivePolicyAssignment The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEffectivePolicyAssignment(writer: SerializationWriter, effectivePolicyAssignment: Partial<EffectivePolicyAssignment> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!effectivePolicyAssignment || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", effectivePolicyAssignment.odataType);
    writer.writeObjectValue<PolicyAssignment>("policyAssignment", effectivePolicyAssignment.policyAssignment, serializePolicyAssignment);
    writer.writeStringValue("policyType", effectivePolicyAssignment.policyType);
    writer.writeAdditionalData(effectivePolicyAssignment.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PolicyAssignment The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePolicyAssignment(writer: SerializationWriter, policyAssignment: Partial<PolicyAssignment> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!policyAssignment || isSerializingDerivedType) { return; }
    writer.writeEnumValue<AssignmentType>("assignmentType", policyAssignment.assignmentType);
    writer.writeStringValue("displayName", policyAssignment.displayName);
    writer.writeStringValue("groupId", policyAssignment.groupId);
    writer.writeStringValue("@odata.type", policyAssignment.odataType);
    writer.writeStringValue("policyId", policyAssignment.policyId);
    writer.writeAdditionalData(policyAssignment.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TeamsAdminRoot The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTeamsAdminRoot(writer: SerializationWriter, teamsAdminRoot: Partial<TeamsAdminRoot> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!teamsAdminRoot || isSerializingDerivedType) { return; }
    serializeEntity(writer, teamsAdminRoot, isSerializingDerivedType)
    writer.writeObjectValue<TeamsPolicyAssignment>("policy", teamsAdminRoot.policy, serializeTeamsPolicyAssignment);
    writer.writeCollectionOfObjectValues<TeamsUserConfiguration>("userConfigurations", teamsAdminRoot.userConfigurations, serializeTeamsUserConfiguration);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TeamsPolicyAssignment The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTeamsPolicyAssignment(writer: SerializationWriter, teamsPolicyAssignment: Partial<TeamsPolicyAssignment> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!teamsPolicyAssignment || isSerializingDerivedType) { return; }
    serializeEntity(writer, teamsPolicyAssignment, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TeamsUserConfiguration The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTeamsUserConfiguration(writer: SerializationWriter, teamsUserConfiguration: Partial<TeamsUserConfiguration> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!teamsUserConfiguration || isSerializingDerivedType) { return; }
    serializeEntity(writer, teamsUserConfiguration, isSerializingDerivedType)
    writer.writeEnumValue<AccountType>("accountType", teamsUserConfiguration.accountType);
    writer.writeDateValue("createdDateTime", teamsUserConfiguration.createdDateTime);
    writer.writeCollectionOfObjectValues<EffectivePolicyAssignment>("effectivePolicyAssignments", teamsUserConfiguration.effectivePolicyAssignments, serializeEffectivePolicyAssignment);
    writer.writeCollectionOfPrimitiveValues<string>("featureTypes", teamsUserConfiguration.featureTypes);
    writer.writeBooleanValue("isEnterpriseVoiceEnabled", teamsUserConfiguration.isEnterpriseVoiceEnabled);
    writer.writeDateValue("modifiedDateTime", teamsUserConfiguration.modifiedDateTime);
    writer.writeCollectionOfObjectValues<AssignedTelephoneNumber>("telephoneNumbers", teamsUserConfiguration.telephoneNumbers, serializeAssignedTelephoneNumber);
    writer.writeStringValue("tenantId", teamsUserConfiguration.tenantId);
    writer.writeObjectValue<User>("user", teamsUserConfiguration.user, serializeUser);
    writer.writeStringValue("userPrincipalName", teamsUserConfiguration.userPrincipalName);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TeamsUserConfigurationCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTeamsUserConfigurationCollectionResponse(writer: SerializationWriter, teamsUserConfigurationCollectionResponse: Partial<TeamsUserConfigurationCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!teamsUserConfigurationCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, teamsUserConfigurationCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<TeamsUserConfiguration>("value", teamsUserConfigurationCollectionResponse.value, serializeTeamsUserConfiguration);
}
export interface TeamsAdminRoot extends Entity, Parsable {
    /**
     * Represents a navigation property to the Teams policy assignment object.
     */
    policy?: TeamsPolicyAssignment | null;
    /**
     * Represents the configuration information of users who have accounts hosted on Microsoft Teams.
     */
    userConfigurations?: TeamsUserConfiguration[] | null;
}
export interface TeamsPolicyAssignment extends Entity, Parsable {
}
export interface TeamsUserConfiguration extends Entity, Parsable {
    /**
     * The type of the account in the Teams context. The possible values are: user, resourceAccount, guest, sfbOnPremUser, unknown, unknownFutureValue, ineligibleUser. Use the Prefer: include-unknown-enum-members request header to get the following value from this enum evolvable enum: ineligibleUser.
     */
    accountType?: AccountType | null;
    /**
     * The date and time when the user was created. The timestamp represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    createdDateTime?: Date | null;
    /**
     * Contains the user's effective policy assignments, with each assignment including policyType and policyAssignment details.
     */
    effectivePolicyAssignments?: EffectivePolicyAssignment[] | null;
    /**
     * The Teams features enabled for a given user based on licensing or service plan.
     */
    featureTypes?: string[] | null;
    /**
     * Indicates whether voice capability is enabled.
     */
    isEnterpriseVoiceEnabled?: boolean | null;
    /**
     * The date and time when the user's details were last modified. The system updates this value each time the user's details are changed. The timestamp represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    modifiedDateTime?: Date | null;
    /**
     * Includes both the phone number and its corresponding assignment category. The assignment category can include values such as primary, private, and alternate.
     */
    telephoneNumbers?: AssignedTelephoneNumber[] | null;
    /**
     * The unique identifier of the tenant in Entra to which this user is assigned.
     */
    tenantId?: string | null;
    /**
     * Represents an Entra user account.
     */
    user?: User | null;
    /**
     * The sign-in address of the user.
     */
    userPrincipalName?: string | null;
}
export interface TeamsUserConfigurationCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: TeamsUserConfiguration[] | null;
}
export const AccountTypeObject = {
    User: "user",
    ResourceAccount: "resourceAccount",
    Guest: "guest",
    SfbOnPremUser: "sfbOnPremUser",
    Unknown: "unknown",
    UnknownFutureValue: "unknownFutureValue",
    IneligibleUser: "ineligibleUser",
} as const;
export const AssignmentCategoryObject = {
    Primary: "primary",
    Private: "private",
    Alternate: "alternate",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AssignmentTypeObject = {
    Direct: "direct",
    Group: "group",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
