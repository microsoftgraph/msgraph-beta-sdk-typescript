/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, type BaseCollectionPaginationCountResponse, type Entity } from '../index.js';
// @ts-ignore
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GroupCollectionResponse}
 */
// @ts-ignore
export function createGroupCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGroupCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Group}
 */
// @ts-ignore
export function createGroupFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGroup;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelationCollectionResponse}
 */
// @ts-ignore
export function createRelationCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelationCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Relation}
 */
// @ts-ignore
export function createRelationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SetCollectionResponse}
 */
// @ts-ignore
export function createSetCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSetCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Set}
 */
// @ts-ignore
export function createSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Store}
 */
// @ts-ignore
export function createStoreFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStore;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TermCollectionResponse}
 */
// @ts-ignore
export function createTermCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTermCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Term}
 */
// @ts-ignore
export function createTermFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTerm;
}
/**
 * The deserialization information for the current model
 * @param Group The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGroup(group: Partial<Group> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(group),
        "createdDateTime": n => { group.createdDateTime = n.getDateValue(); },
        "description": n => { group.description = n.getStringValue(); },
        "displayName": n => { group.displayName = n.getStringValue(); },
        "parentSiteId": n => { group.parentSiteId = n.getStringValue(); },
        "scope": n => { group.scope = n.getEnumValue<TermGroupScope>(TermGroupScopeObject); },
        "sets": n => { group.sets = n.getCollectionOfObjectValues<Set>(createSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param GroupCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGroupCollectionResponse(groupCollectionResponse: Partial<GroupCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(groupCollectionResponse),
        "value": n => { groupCollectionResponse.value = n.getCollectionOfObjectValues<Group>(createGroupFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Relation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelation(relation: Partial<Relation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(relation),
        "fromTerm": n => { relation.fromTerm = n.getObjectValue<Term>(createTermFromDiscriminatorValue); },
        "relationship": n => { relation.relationship = n.getEnumValue<RelationType>(RelationTypeObject); },
        "set": n => { relation.set = n.getObjectValue<Set>(createSetFromDiscriminatorValue); },
        "toTerm": n => { relation.toTerm = n.getObjectValue<Term>(createTermFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelationCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelationCollectionResponse(relationCollectionResponse: Partial<RelationCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(relationCollectionResponse),
        "value": n => { relationCollectionResponse.value = n.getCollectionOfObjectValues<Relation>(createRelationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Set The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSet(set: Partial<Set> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(set),
    }
}
/**
 * The deserialization information for the current model
 * @param SetCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSetCollectionResponse(setCollectionResponse: Partial<SetCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(setCollectionResponse),
        "value": n => { setCollectionResponse.value = n.getCollectionOfObjectValues<Set>(createSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Store The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStore(store: Partial<Store> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(store),
    }
}
/**
 * The deserialization information for the current model
 * @param Term The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTerm(term: Partial<Term> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(term),
    }
}
/**
 * The deserialization information for the current model
 * @param TermCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTermCollectionResponse(termCollectionResponse: Partial<TermCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(termCollectionResponse),
        "value": n => { termCollectionResponse.value = n.getCollectionOfObjectValues<Term>(createTermFromDiscriminatorValue); },
    }
}
export interface Group extends Entity, Parsable {
    /**
     * Date and time of the group creation. Read-only.
     */
    createdDateTime?: Date | null;
    /**
     * Description that gives details on the term usage.
     */
    description?: string | null;
    /**
     * Name of the group.
     */
    displayName?: string | null;
    /**
     * ID of the parent site of this group.
     */
    parentSiteId?: string | null;
    /**
     * Returns the type of the group. Possible values are: global, system, and siteCollection.
     */
    scope?: TermGroupScope | null;
    /**
     * All sets under the group in a term [store].
     */
    sets?: Set[] | null;
}
export interface GroupCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Group[] | null;
}
export interface Relation extends Entity, Parsable {
    /**
     * The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].
     */
    fromTerm?: Term | null;
    /**
     * The type of relation. Possible values are: pin, reuse.
     */
    relationship?: RelationType | null;
    /**
     * The [set] in which the relation is relevant.
     */
    set?: Set | null;
    /**
     * The to [term] of the relation. The term to which the relationship is defined.
     */
    toTerm?: Term | null;
}
export interface RelationCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Relation[] | null;
}
export type RelationType = (typeof RelationTypeObject)[keyof typeof RelationTypeObject];
/**
 * Serializes information the current object
 * @param Group The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGroup(writer: SerializationWriter, group: Partial<Group> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!group || isSerializingDerivedType) { return; }
    serializeEntity(writer, group, isSerializingDerivedType)
    writer.writeDateValue("createdDateTime", group.createdDateTime);
    writer.writeStringValue("description", group.description);
    writer.writeStringValue("displayName", group.displayName);
    writer.writeStringValue("parentSiteId", group.parentSiteId);
    writer.writeEnumValue<TermGroupScope>("scope", group.scope);
    writer.writeCollectionOfObjectValues<Set>("sets", group.sets, serializeSet);
}
/**
 * Serializes information the current object
 * @param GroupCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGroupCollectionResponse(writer: SerializationWriter, groupCollectionResponse: Partial<GroupCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!groupCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, groupCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Group>("value", groupCollectionResponse.value, serializeGroup);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Relation The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelation(writer: SerializationWriter, relation: Partial<Relation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relation || isSerializingDerivedType) { return; }
    serializeEntity(writer, relation, isSerializingDerivedType)
    writer.writeObjectValue<Term>("fromTerm", relation.fromTerm, serializeTerm);
    writer.writeEnumValue<RelationType>("relationship", relation.relationship);
    writer.writeObjectValue<Set>("set", relation.set, serializeSet);
    writer.writeObjectValue<Term>("toTerm", relation.toTerm, serializeTerm);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelationCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelationCollectionResponse(writer: SerializationWriter, relationCollectionResponse: Partial<RelationCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relationCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, relationCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Relation>("value", relationCollectionResponse.value, serializeRelation);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Set The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSet(writer: SerializationWriter, set: Partial<Set> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!set || isSerializingDerivedType) { return; }
    serializeEntity(writer, set, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SetCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSetCollectionResponse(writer: SerializationWriter, setCollectionResponse: Partial<SetCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!setCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, setCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Set>("value", setCollectionResponse.value, serializeSet);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Store The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStore(writer: SerializationWriter, store: Partial<Store> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!store || isSerializingDerivedType) { return; }
    serializeEntity(writer, store, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Term The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTerm(writer: SerializationWriter, term: Partial<Term> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!term || isSerializingDerivedType) { return; }
    serializeEntity(writer, term, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TermCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTermCollectionResponse(writer: SerializationWriter, termCollectionResponse: Partial<TermCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!termCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, termCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Term>("value", termCollectionResponse.value, serializeTerm);
}
export interface Set extends Entity, Parsable {
}
export interface SetCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Set[] | null;
}
export interface Store extends Entity, Parsable {
}
export interface Term extends Entity, Parsable {
}
export interface TermCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Term[] | null;
}
export type TermGroupScope = (typeof TermGroupScopeObject)[keyof typeof TermGroupScopeObject];
export const RelationTypeObject = {
    Pin: "pin",
    Reuse: "reuse",
} as const;
export const TermGroupScopeObject = {
    Global: "global",
    System: "system",
    SiteCollection: "siteCollection",
} as const;
/* tslint:enable */
/* eslint-enable */
